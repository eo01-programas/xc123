<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tablero de Control de Producción</title>
    <!-- Fuentes e Iconos -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    
    <style>
        :root {
            --primary: #2563eb;
            --primary-light: #eff6ff;
            --success: #10b981;
            --success-light: #ecfdf5;
            --warning: #f59e0b;
            --warning-light: #fffbeb;
            --danger: #ef4444;
            --gray-50: #f8fafc;
            --gray-100: #f1f5f9;
            --gray-200: #e2e8f0;
            --white: #ffffff;
            --gray-300: #cbd5e1;
            --gray-500: #64748b;
            --gray-800: #1e293b;
            --row-group-a: #D9E6FF;          /* Azul muy claro (ahora grupo-a) */
            --row-group-b: #ffffff;          /* Blanco para grupos alternados (ahora grupo-b) */
        }

        /* Highlight para partidas en devolución de lavado */
        tr.lav-devolucion { 
            background-color: #FFF7E0; 
            border-left: 4px solid #FFB74D; 
            transition: background-color 0.25s ease, box-shadow 0.25s ease;
        }
        tr.lav-devolucion:hover { box-shadow: 0 6px 18px rgba(255,183,77,0.12); }
        .lav-wrap { display:inline-flex; gap:6px; align-items:center; }
        .lav-badge {
            background-color: #FFD54A;
            color: #5a3400;
            font-weight:700;
            font-size:11px;
            padding: 3px 8px;
            border-radius: 8px;
            display: inline-block;
            line-height: 1;
            border: 1px solid rgba(255,180,70,0.9);
            box-shadow: 0 2px 8px rgba(255,180,70,0.25);
            transform-origin: center;
            animation: lavBadgePulse 2.2s ease-in-out infinite;
        }
        @keyframes lavBadgePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.06); }
            100% { transform: scale(1); }
        }
        body {
            font-family: 'Calibri', 'Inter', sans-serif;
            background-color: var(--gray-50);
            color: var(--gray-800);
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: 12px; 
        }

        /* --- HEADER --- */
        header {
            background-color: var(--white);
            border-bottom: 1px solid var(--gray-200);
            padding: 0 30px; 
            height: 55px;    
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .brand {
            font-size: 16px; 
            font-weight: 700;
            color: var(--gray-800);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .brand i { color: var(--primary); font-size: 20px; }

        .nav-tabs { display: flex; gap: 20px; height: 100%; }

        .nav-tab {
            background: none; border: none; height: 100%; padding: 0 8px;
            font-size: 13px; 
            font-weight: 500; color: var(--gray-500);
            cursor: pointer; position: relative; transition: color 0.2s;
            display: flex; align-items: center; gap: 6px;
            font-family: 'Calibri', sans-serif;
        }

        .nav-tab:hover { color: var(--primary); }
        .nav-tab.active { color: var(--primary); font-weight: 600; }
        .nav-tab.active::after {
            content: ''; position: absolute; bottom: 0; left: 0; width: 100%;
            height: 3px; background-color: var(--primary); border-radius: 3px 3px 0 0;
        }

        .badge {
            background-color: var(--gray-200); color: var(--gray-800);
            padding: 1px 6px; border-radius: 10px; font-size: 10px; font-weight: 600;
        }
        .nav-tab.active .badge { background-color: var(--primary-light); color: var(--primary); }

        /* --- CONTENIDO --- */
        main { padding: 20px; flex: 1; overflow-y: auto; overflow-x: hidden; }

        .view-section { display: none; animation: fadeIn 0.4s ease; height: 100%; display: flex; flex-direction: column;}
        .view-section.active { display: flex; } 
        .view-section:not(.active) { display: none; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* --- SUB TABS --- */
        .sub-nav {
            background-color: var(--white); padding: 3px; border-radius: 6px;
            display: inline-flex; gap: 3px; margin-bottom: 15px;
            border: 1px solid var(--gray-200); box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            align-self: flex-start;
        }

        /* Contenedor para filtros (switches) a la derecha de los sub-tabs */
        .sub-filters {
            margin-left: auto; display: flex; gap: 10px; align-items: center;
        }

        .filter-item { display: inline-flex; align-items: center; gap: 8px; font-weight:600; color:var(--gray-600); font-size:12px; }
        .filter-item input[type="checkbox"] { width: 36px; height: 20px; appearance: none; -webkit-appearance:none; border-radius: 999px; background: #e5e7eb; position: relative; cursor: pointer; outline: none; transition: background 0.15s ease; }
        .filter-item input[type="checkbox"]::before { content: ''; position: absolute; top: 3px; left: 4px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: transform 0.15s ease; box-shadow: 0 1px 2px rgba(0,0,0,0.12); }
        .filter-item input[type="checkbox"]:checked { background: var(--primary); }
        .filter-item input[type="checkbox"]:checked::before { transform: translateX(16px); }

        /* Reducir tamaño del switch y etiqueta 'Normal' en 40% */
        .filter-item input#flt-normal { width: 22px; height: 12px; }
        .filter-item input#flt-normal::before { top: 2px; left: 2px; width: 8px; height: 8px; }
        .filter-item input#flt-normal:checked::before { transform: translateX(9px); }
        .filter-item input#flt-normal + span { font-size: 7.2px; }

        .sub-tab {
            border: none; background: none; padding: 5px 12px; border-radius: 5px;
            font-size: 15.5px; 
            font-weight: 500; color: var(--gray-500); cursor: pointer; transition: all 0.2s;
            display: flex; align-items: center; gap: 5px;
            font-family: 'Calibri', sans-serif;
        }
        .sub-tab:hover { background-color: var(--gray-50); }
        .sub-tab.active { background-color: var(--primary-light); color: var(--primary); font-weight: 600; }

        .kg-badge {
            font-size: 12px;
            background-color: rgba(0,0,0,0.05);
            padding: 1px 5px;
            border-radius: 3px;
            color: inherit;
        }
        .sub-tab.active .kg-badge { background-color: rgba(37, 99, 235, 0.1); color: var(--primary); }

        /* --- TABLA MODERNIZADA Y COMPACTA --- */
        .table-container {
            background: var(--white);
            border-radius: 10px;
            border: 1px solid var(--gray-200);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow: auto;
            flex: 1;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px; 
            min-width: 1200px; 
            table-layout: fixed;
        }

        thead th {
            background-color: rgb(0,112,192);
            color: #ffffff;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 13px; 
            letter-spacing: 0.5px;
            padding: 8px 6px; 
            text-align: left;
            border-bottom: 1px solid var(--gray-200);
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        tbody td {
            padding: 5px 6px; 
            border-bottom: 1px solid var(--gray-100);
            vertical-align: middle;
            color: var(--gray-800);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2; 
        }

        /* --- ESTILOS DE FILAS AGRUPADAS --- */
        tr.group-a { background-color: var(--row-group-a); }
        tr.group-b { background-color: var(--row-group-b); }
        
        /* Fila con P = 1: rojo muy claro y transparente */
        tr.priority-1 { background-color: rgba(255, 200, 200, 0.4); }

        /* HOVER: Sombreado oscuro (aprox 30% visual) */
        tr.group-a:hover, tr.group-b:hover { 
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.15) !important; 
        }

        tbody tr:last-child td { border-bottom: none; }

        /* --- ESTILOS DE CELDA --- */
        .op-cell { font-weight: 600; color: var(--gray-800); }
        .kg-cell { font-family: 'Calibri', 'Inter', sans-serif; font-weight: 600; font-size: 11px; }
        .date-cell { color: var(--gray-800); font-size: 11px; text-align: center; }

        /* --- SELECTS COMPACTOS --- */
        select.table-select {
            appearance: none;
            padding: 3px 6px; 
            padding-right: 18px; 
            border-radius: 4px;
            border: 1px solid var(--gray-300);
            background-color: var(--white);
            font-size: 11px; 
            font-weight: 500;
            cursor: pointer;
            width: 100%;
            min-width: 80px; 
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' fill='%2364748b' viewBox='0 0 16 16'%3E%3Cpath d='M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 4px center;
            transition: all 0.2s;
            height: 24px; 
            font-family: 'Calibri', sans-serif;
        }

        /* Celda e input específicos para la columna P (prioridad) - sin padding lateral */
        td.p-cell { padding-left: 1px; padding-right: 3px; }
        input.prioridad-input {
            padding: 2px 4px;
            width: 25px !important;
            min-width: 20px !important;
            text-align: center;
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            background-color: var(--white);
            height: 20px;
            font-size: 11px;
            font-family: 'Calibri', sans-serif;
            box-sizing: border-box;
        }
        input.prioridad-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        select.table-select:disabled {
            background-color: var(--gray-100); color: var(--gray-400); border-color: var(--gray-200);
            cursor: not-allowed; background-image: none;
        }

        select.table-select:focus { outline: none; border-color: var(--primary); }

        .sel-PROG { border-color: var(--warning) !important; color: #b45309; background-color: var(--warning-light); }
        .sel-OK { border-color: var(--success) !important; color: #047857; font-weight: 600; background-color: var(--success-light); }
        .sel-ENLAV { border-color: #6366f1 !important; color: #4338ca; background-color: #e0e7ff; }

        /* Estilos para el selector de fecha con formato corto */
        input.short-year {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            width: 0;
            height: 0;
        }
        
        .date-yy {
            cursor: pointer;
            display: inline-block;
            padding: 3px 8px;
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            background-color: var(--white);
            font-size: 11px;
            transition: all 0.2s;
            min-width: 70px;
            text-align: center;
        }
        
        .date-yy:hover {
            border-color: var(--primary);
            background-color: var(--primary-light);
        }

        /* Tags de estado */
        .status-tag {
            display: inline-flex; align-items: center; gap: 4px; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 600;
        }
        .tag-success { background-color: var(--success-light); color: var(--success); }
        .tag-neutral { background-color: var(--gray-100); color: var(--gray-600); }

        /* Loader & Error */
        #loader, #error-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000;
        }
        #error-screen { display: none; z-index: 1001; }
        .spinner {
            width: 30px; height: 30px; border: 3px solid var(--gray-200);
            border-top: 3px solid var(--primary); border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .error-box {
            background: #fff; padding: 20px; border-radius: 10px; 
            border: 1px solid #fee2e2; box-shadow: 0 5px 10px -3px rgba(0,0,0,0.1);
            max-width: 400px; text-align: center;
        }
        .btn-retry {
            background-color: var(--gray-800); color: white; border: none; padding: 8px 16px;
            border-radius: 5px; cursor: pointer; font-weight: 600; margin-top: 10px; font-size: 12px;
        }
        /* Agrega esto al final de tu CSS */
        .wrap-text {
        white-space: normal !important; /* Permite que el texto baje de linea */
        overflow: visible !important;   /* Muestra todo el contenido */
        text-overflow: clip !important; /* Quita los puntos suspensivos (...) */
        line-height: 1.1 !important;    /* Ajusta la altura de linea para que no ocupe tanto */
        font-size: 10px !important;     /* Reduce un poco la letra para que quepa mejor */
    }
    /* RIB highlight: verde transparente para 'SI LLEVA' */
    .rib-si-lleva {
        background-color: rgba(16,185,129,0.12);
        color: #065f46;
        padding: 3px 8px;
        border-radius: 6px;
        display: inline-block;
        font-weight: 700;
        font-size: 11px;
        line-height: 1;
    }
    .rib-text { display: inline-block; padding: 2px 6px; border-radius: 4px; }
    .rib-danger {
        background-color: rgba(239,68,68,0.10);
        color: #7f1d1d;
        padding: 3px 8px;
        border-radius: 6px;
        display: inline-block;
        font-weight: 700;
        font-size: 11px;
        line-height: 1;
    }
    </style>
    <style>
        /* RUTA badges: small rounded squares with translucent backgrounds */
        .route-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 700;
            font-size: 11px;
            line-height: 1;
            white-space: nowrap;
            vertical-align: middle;
        }
        .route-ac {
            color: #2563eb; /* primary */
            background: rgba(37,99,235,0.08);
            border: 1px solid rgba(37,99,235,0.12);
        }
        .route-lv {
            color: #0ea5a0; /* teal/green-ish */
            background: rgba(16,185,129,0.08);
            border: 1px solid rgba(16,185,129,0.12);
        }
        .route-bloq {
            color: #92400e; /* amber/dark */
            background: rgba(245,158,11,0.08);
            border: 1px solid rgba(245,158,11,0.12);
        }
        .route-xlav {
            color: #6d28d9; /* violet */
            background: rgba(124,58,237,0.06);
            border: 1px solid rgba(124,58,237,0.10);
        }
        /* Pill / Chip styles used specifically for TRSF column */
        .pill {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 14px;
            font-weight: 700;
            font-size: 12px;
            line-height: 1;
            white-space: nowrap;
            vertical-align: middle;
        }
        /* X -> fondo rojo oscuro y texto rojo */
        .pill-x {
            color: #7f1d1d;
            background: rgba(127,29,29,0.18);
            border: 1px solid rgba(127,29,29,0.20);
        }
        /* RIB specific alert pills: dark red background with white text */
        .pill-rib-alert {
            color: #ffffff;
            background: rgba(127,29,29,0.9);
            border: 1px solid rgba(127,29,29,0.95);
        }
        /* Pza -> fondo azul claro */
        .pill-pza {
            color: #075985;
            background: rgba(37,99,235,0.08);
            border: 1px solid rgba(37,99,235,0.12);
        }
        /* PDA -> fondo verde claro */
        .pill-pda {
            color: #065f46;
            background: rgba(16,185,129,0.08);
            border: 1px solid rgba(16,185,129,0.12);
        }
        /* OK (fondo azul oscuro) for BLOQUES OK state */
        .pill-ok-dark {
            color: #ffffff;
            background: rgba(13,60,120,0.9);
            border: 1px solid rgba(13,60,120,0.95);
        }

        /* --- MODAL TENDIDO --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-overlay.active {
            display: flex;
        }
        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            /* Reduce modal width to ~60% of previous default */
            width: 60%;
            min-width: 260px;
            max-width: 500px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            animation: modalSlideIn 0.3s ease;
        }
        .modal-content { box-sizing: border-box; }
        @keyframes modalSlideIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--gray-200);
        }
        .modal-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--gray-800);
        }
        .modal-subtitle {
            font-size: 13px;
            color: var(--gray-500);
            margin-top: 4px;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--gray-500);
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .modal-close:hover {
            background: var(--gray-100);
            color: var(--gray-800);
        }
        /* Ensure modal tables don't inherit the global min-width
           and make the table 80% of the modal width, centered.
           Add border so the right edge is visible even if table is centered. */
        .modal-table {
            width: 90%;
            border-collapse: collapse;
            margin: 0 auto 20px auto;
            min-width: 0 !important;
            table-layout: fixed;
            word-break: break-word;
            border: 1px solid var(--gray-200);
            border-radius: 6px;
            overflow: hidden;
            background: white;
        }
        .modal-table th {
            background: var(--gray-100);
            padding: 10px 12px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: var(--gray-600);
            border-bottom: 1px solid var(--gray-200);
        }
        .modal-table td {
            padding: 10px 12px;
            border-bottom: 1px solid var(--gray-100);
            font-size: 13px;
        }

        /* Vertical separators so the right border is visible when table is centered */
        .modal-table th:not(:last-child),
        .modal-table td:not(:last-child) {
            border-right: 1px solid var(--gray-100);
        }
        .modal-table input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }
        .modal-table input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }
        .modal-table input:disabled {
            background: var(--gray-50);
            color: var(--gray-600);
        }
        .oc-link { cursor: pointer; color: var(--primary); font-weight:700; }
        .oc-link:hover { text-decoration: underline; }
        /* In Corte Pzas view OC should not look clickable */
        #view-corte .oc-link {
            color: inherit !important;
            cursor: default !important;
            text-decoration: none !important;
            font-weight: 600 !important;
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .btn-modal {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }
        .btn-limpiar {
            background: var(--gray-100);
            color: var(--gray-700);
        }
        .btn-limpiar:hover {
            background: var(--gray-200);
        }
        .btn-guardar {
            background: var(--primary);
            color: white;
        }
        .btn-guardar:hover {
            background: #1d4ed8;
        }

        /* Botón de más para tendido */
        .btn-tendido {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background: var(--primary-light);
            color: var(--primary);
            border: 1px solid var(--primary);
            border-radius: 3px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            margin-right: 6px;
            transition: all 0.2s;
            line-height: 1;
        }
        .btn-tendido:hover {
            background: var(--primary);
            color: white;
        }
        
        /* --- MENÚ CONTEXTUAL DE FILTRO --- */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid var(--gray-200);
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            z-index: 5000;
            min-width: 200px;
            display: none;
            flex-direction: column;
        }
        
        .context-menu.active {
            display: flex;
        }
        
        .context-menu-item {
            padding: 12px 16px;
            font-size: 13px;
            cursor: pointer;
            color: var(--gray-800);
            transition: all 0.2s;
            border-bottom: 1px solid var(--gray-100);
        }
        
        .context-menu-item:last-child {
            border-bottom: none;
        }
        
        .context-menu-item:hover {
            background: var(--primary-light);
            color: var(--primary);
            font-weight: 500;
        }
        
        .context-menu-input {
            padding: 8px 12px;
            border-bottom: 1px solid var(--gray-100);
        }
        
        .context-menu-input input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            font-size: 12px;
            box-sizing: border-box;
        }
        
        .context-menu-input input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }
        
        .context-menu-buttons {
            padding: 8px 12px;
            display: flex;
            gap: 6px;
            justify-content: flex-end;
            border-top: 1px solid var(--gray-100);
        }
        
        .context-menu-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .context-menu-btn.apply {
            background: var(--primary);
            color: white;
        }
        
        .context-menu-btn.apply:hover {
            background: #1d4ed8;
        }
        
        .context-menu-btn.cancel {
            background: var(--gray-100);
            color: var(--gray-700);
        }
        
        .context-menu-btn.cancel:hover {
            background: var(--gray-200);
        }
    </style>
    <style>
        /* Estilos para botón flotante del embudo */
        #stock-funnel-button {
            position: fixed;
            top: 38px;
            right: 12px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--white);
            border: 2px solid var(--primary);
            color: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 18px rgba(16,24,40,0.12);
            z-index: 2200;
            cursor: pointer;
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }
        #stock-funnel-button:hover { transform: translateY(-2px); box-shadow: 0 10px 24px rgba(16,24,40,0.16); }

        /* Contenedor del gráfico (ahora barras horizontales) */
        #funnel-chart { min-height: 220px; display: flex; flex-direction: column; gap: 10px; align-items: stretch; }
        .funnel-block {
            display: flex;
            gap: 4px; /* reducido para acercar label/bar/valor */
            align-items: center;
            padding: 1px 2px; /* menos padding vertical/horizontal */
            border-radius: 6px;
            background: transparent;
            box-shadow: 0 4px 12px rgba(2,6,23,0.04);
        }
        .funnel-label { width: 120px; font-size: 13px; font-weight: 700; color: #374151; padding-left:6px; }
        .funnel-bar {
            height: 28px;
            flex: 1;
            background: rgba(15,23,42,0.06);
            border-radius: 999px;
            overflow: hidden;
            display: flex;
            align-items: center;
        }
        .bar-fill {
            height: 100%;
            border-radius: 999px;
            display: block;
            transition: width 350ms ease;
        }
        .funnel-value {
            width: 90px;
            text-align: right;
            font-weight: 800;
            color: #374151;
            padding-left: 12px;
            font-size: 13px;
        }
        /* Adjust label/value contrast for specific color classes (use on .bar-fill) */
        .c-bloqueo { background: #f59e0b; }
        .c-lavanderia { background: #10b981; }
        .c-corte-pzas { background: #2563eb; }
        .c-corte-bloques { background: #f97316; }
        .c-enumerado { background: #fb923c; }
        .c-transfer { background: #f59e0b; }
        .c-bordado { background: #fbbf24; }
        .c-estampado { background: #059669; }
        .c-habilitado { background: #6b7280; }

        /* Colores aproximados a los de la imagen referencial */
        .c-bloqueo { background: #fef3c7; color: #92400e; }
        .c-lavanderia { background: #dcfce7; color: #064e3b; }
        .c-corte-pzas { background: #dbeafe; color: #1e3a8a; }
        .c-corte-bloques { background: #fef3e2; color: #92400e; }
        .c-enumerado { background: #fff7ed; color: #92400e; }
        .c-transfer { background: #fff4e6; color: #92400e; }
        .c-bordado { background: #fff7cc; color: #92400e; }
        .c-estampado { background: #ecfdf5; color: #065f46; }
        .c-habilitado { background: #f3f4f6; color: #111827; }

        /* --- BOTÓN FLOTANTE CON MENÚ DESPLEGABLE --- */
        .floating-menu-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 50;
        }

        .floating-menu-toggle {
            width: 35px;
            height: 35px;
            background: var(--primary);
            color: var(--white);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.2s ease;
            border: none;
            padding: 0;
        }

        .floating-menu-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        .floating-menu-items {
            position: absolute;
            bottom: 50px;
            right: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .floating-menu-items.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            pointer-events: auto;
        }

        .floating-menu-item {
            width: 35px;
            height: 35px;
            background: var(--primary);
            color: var(--white);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.2s ease;
            border: none;
            padding: 0;
        }

        .floating-menu-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        /* --- MODAL CARGA ASIGNAR ARTES --- */
        .modal-content-loading {
            background: white;
            border-radius: 12px;
            padding: 40px 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: modalSlideIn 0.3s ease;
            min-width: 300px;
            max-width: 400px;
        }

        #modal-loading-artes {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            pointer-events: auto;
        }

        #modal-loading-artes.active {
            display: flex;
        }

        #modal-loading-artes.active ~ * {
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- LOADER -->
    <div id="loader">
        <div class="spinner"></div>
        <p style="margin-top: 10px; font-weight: 500; color: var(--gray-500); font-size: 12px;">Cargando tabla...</p>
    </div>

    <!-- ERROR SCREEN -->
    <div id="error-screen">
        <div class="error-box">
            <div style="color: var(--danger); font-size: 16px; font-weight: 700; margin-bottom: 8px;"><i class="ph ph-warning-circle"></i> Error</div>
            <div id="error-details" style="color: var(--gray-500); font-size: 12px; line-height: 1.4;"></div>
            <button class="btn-retry" onclick="location.reload()">Reintentar</button>
        </div>
    </div>

    <!-- MODAL TENDIDO -->
    <div id="modal-tendido" class="modal-overlay" onclick="if(event.target === this) cerrarModalTendido()">
        <div class="modal-content">
            <div class="modal-header">
                <div>
                    <div class="modal-title" id="modal-tendido-title">OC: ---</div>
                    <div class="modal-subtitle" id="modal-tendido-subtitle">COLOR: --- | PDS: ---</div>
            </html>
                </div>
                <button class="modal-close" onclick="cerrarModalTendido()">&times;</button>
            </div>
            <table class="modal-table">
                <thead>
                    <tr>
                        <th style="width: 50%;">TENDIDO</th>
                        <th style="width: 50%;">PDS</th>
                    </tr>
                </thead>
                <tbody id="modal-tendido-tbody">
                    <!-- Filas dinámicas -->
                </tbody>
            </table>
            <div class="modal-buttons">
                <button class="btn-modal btn-limpiar" onclick="limpiarModalTendido()">Limpiar</button>
                <button class="btn-modal btn-guardar" onclick="guardarModalTendido()">Guardar</button>
            </div>
        </div>
    </div>

    <!-- MODAL EQ_CORTE -->
    <div id="modal-eq-corte" class="modal-overlay" onclick="if(event.target === this) cerrarModalEQCorte()">
        <div class="modal-content" style="width: 70%; max-width: 600px;">
            <div class="modal-header">
                <div>
                    <div class="modal-title">Equipos de Corte</div>
                    <div class="modal-subtitle">Gestionar lista de equipos</div>
                </div>
                <button class="modal-close" onclick="cerrarModalEQCorte()">&times;</button>
            </div>
            <table class="modal-table">
                <thead>
                    <tr>
                        <th style="width: 30%;">EQ_Corte</th>
                        <th style="width: 70%;">Nombre</th>
                    </tr>
                </thead>
                <tbody id="modal-eq-corte-tbody">
                    <!-- Filas dinámicas -->
                </tbody>
            </table>
            <div class="modal-buttons">
                <button class="btn-modal btn-limpiar" onclick="cerrarModalEQCorte()">Cancelar</button>
                <button class="btn-modal btn-guardar" onclick="guardarModalEQCorte()">Guardar</button>
            </div>
        </div>
    </div>

    <!-- MODAL OC INFO -->
    <div id="modal-oc" class="modal-overlay" onclick="if(event.target === this) cerrarModalOC()">
        <div class="modal-content" style="max-width:420px; width:50%">
            <div class="modal-header">
                <div>
                    <div class="modal-title" id="modal-oc-title">OC COLOR</div>
                    <div class="modal-subtitle" id="modal-oc-subtitle"></div>
                </div>
                <button class="modal-close" onclick="cerrarModalOC()">&times;</button>
            </div>
            <table class="modal-table">
                <tbody id="modal-oc-tbody">
                </tbody>
            </table>
            <div class="modal-buttons">
                <button class="btn-modal btn-limpiar" onclick="cerrarModalOC()">Cerrar</button>
            </div>
        </div>
    </div>

    <!-- MODAL LAVADORA (Abrir desde Corte PROG 1T/2T/3T) -->
    <div id="modal-lavadora" class="modal-overlay" onclick="if(event.target === this) cerrarModalLavado()">
        <div class="modal-content" style="max-width:420px; width:46%;">
            <div class="modal-header">
                <div>
                    <div class="modal-title" id="modal-lavadora-title">OP-PTDA: --</div>
                    <div class="modal-subtitle" id="modal-lavadora-sub" style="font-size:12px; color:var(--gray-500); margin-top:4px;">Estado actual: (vacío)</div>
                </div>
                <button class="modal-close" onclick="cerrarModalLavado()">&times;</button>
            </div>
            <div style="padding:8px 6px; font-size:13px; color:var(--gray-700);">
                <div style="margin-bottom:10px;"><strong>RUTA TELA:</strong> <span id="modal-lavadora-ruta">-</span></div>
                <div style="margin-bottom:12px;">Seleccione acción:</div>
                <div style="display:flex; gap:10px; align-items:center;">
                    <select id="modal-lavadora-select" class="table-select" style="width:100%; padding:8px; font-size:13px;">
                        <option value="">-- Seleccione --</option>
                        <option value="EN LAV (devolucion)">EN LAV (devolucion)</option>
                    </select>
                </div>
            </div>
            <div style="display:flex; justify-content:flex-end; gap:8px; padding-top:8px;">
                <button class="btn-modal btn-limpiar" onclick="cerrarModalLavado()">Cancelar</button>
                <button class="btn-modal btn-guardar" onclick="onModalLavadoraApply()">Aplicar</button>
            </div>
        </div>
    </div>

    <!-- MODAL CONFIRMACIÓN LAVADORA -->
    <div id="modal-confirm-washer" class="modal-overlay" onclick="if(event.target === this) cerrarModalConfirmWasher()">
        <div class="modal-content" style="max-width:360px; width:40%;">
            <div class="modal-header">
                <div class="modal-title">Confirmar cambio</div>
                <button class="modal-close" onclick="cerrarModalConfirmWasher()">&times;</button>
            </div>
            <p id="modal-confirm-washer-text" style="margin: 16px 0; font-size:13px; color:var(--gray-600); line-height:1.5;">
                ¿Está seguro que desea actualizar el estado de lavado?
            </p>
            <div class="modal-buttons">
                <button class="btn-modal btn-limpiar" onclick="handleConfirmWasher(false)">No</button>
                <button class="btn-modal btn-guardar" onclick="handleConfirmWasher(true)">Si</button>
            </div>
        </div>
    </div>

    <!-- MODAL INGRESO A COSTURA -->
    <div id="modal-ingreso-costura" class="modal-overlay" onclick="if(event.target === this) cerrarModalIngresoCostura()">
        <div class="modal-content" style="max-width:420px; width:46%;">
            <div class="modal-header">
                <div>
                    <div class="modal-title">INGRESO A COSTURA</div>
                    <div class="modal-subtitle" id="modal-ingreso-costura-sub" style="font-size:12px; color:var(--gray-500); margin-top:4px;">CLIENTE OP-CORTE COLOR PDS</div>
                </div>
                <button class="modal-close" onclick="cerrarModalIngresoCostura()">&times;</button>
            </div>
            <div style="padding:12px 6px; font-size:13px; color:var(--gray-700);">
                <div style="margin-bottom:14px;">
                    <label style="display:block; font-weight:600; margin-bottom:4px; color:var(--gray-800);">PLANTA</label>
                    <select id="modal-ingreso-planta" style="width:100%; padding:8px; border:1px solid var(--gray-300); border-radius:4px; font-size:12px;">
                        <option value="">-- Seleccione --</option>
                        <option value="COFACO">COFACO</option>
                        <option value="CITI-1">CITI-1</option>
                        <option value="CITI-2">CITI-2</option>
                        <option value="CITI-3">CITI-3</option>
                        <option value="CITI-4">CITI-4</option>
                    </select>
                </div>
                <div style="margin-bottom:14px;">
                    <label style="display:block; font-weight:600; margin-bottom:4px; color:var(--gray-800);">LINEA</label>
                    <input type="text" id="modal-ingreso-linea" placeholder="Ingrese la línea" style="width:100%; padding:8px; border:1px solid var(--gray-300); border-radius:4px; font-size:12px;" onkeydown="if(event.key==='Enter') guardarModalIngresoCostura()">
                </div>
            </div>
            <div style="display:flex; justify-content:flex-end; gap:8px; padding-top:8px;">
                <button class="btn-modal btn-limpiar" onclick="cerrarModalIngresoCostura()">Cancelar</button>
                <button class="btn-modal btn-guardar" style="background-color: var(--primary);" onclick="guardarModalIngresoCostura()">INGRESAR</button>
            </div>
        </div>
    </div>

    <!-- MODAL CONFIRMACIÓN INGRESO A COSTURA -->
    <div id="modal-confirm-ingreso-costura" class="modal-overlay" onclick="if(event.target === this) cerrarModalConfirmIngresoCostura()">
        <div class="modal-content" style="max-width:360px; width:40%;">
            <div class="modal-header">
                <div class="modal-title">Confirmar</div>
                <button class="modal-close" onclick="cerrarModalConfirmIngresoCostura()">&times;</button>
            </div>
            <p style="margin: 16px 0; font-size:13px; color:var(--gray-600); line-height:1.5;">
                ¿Está seguro que desea registrar el ingreso a costura?
            </p>
            <div class="modal-buttons">
                <button class="btn-modal btn-limpiar" onclick="cerrarModalConfirmIngresoCostura()">No</button>
                <button class="btn-modal btn-guardar" onclick="confirmarIngresoCostura()">Si</button>
            </div>
        </div>
    </div>

    <!-- MENÚ FLOTANTE CON DESPLEGABLE -->
    <div class="floating-menu-container">
        <button class="floating-menu-toggle" id="floating-menu-toggle" title="Menú" aria-label="Menú">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M7 15l5-5 5 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
            </svg>
        </button>
        <div class="floating-menu-items" id="floating-menu-items">
            <button class="floating-menu-item" title="Ver stock" onclick="window.location.href='stock.html'" aria-label="Ver stock">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M3 4h18v2H3V4zM6 10h12v2H6v-2zM10 16h4v2h-4v-2z" fill="currentColor"/>
                </svg>
            </button>
            <button class="floating-menu-item" title="Ver costura" onclick="window.location.href='costura.html'" aria-label="Ver costura">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z" fill="currentColor"/>
                </svg>
            </button>
            <button class="floating-menu-item" title="Buscar OP/COLOR" onclick="window.location.href='busqueda.html'" aria-label="Buscar OP/COLOR">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="10" cy="10" r="6" stroke="currentColor" stroke-width="2" fill="none"/>
                    <path d="M14.5 14.5l5 5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button>
        </div>
    </div>

    <!-- MODAL STOCK FUNNEL -->
    <div id="modal-stock-funnel" class="modal-overlay" onclick="if(event.target === this) closeStockFunnelModal()">
        <div class="modal-content" style="max-width:480px; width:56%;">
            <div class="modal-header">
                <div>
                    <div class="modal-title">Stock por Estado</div>
                    <div class="modal-subtitle">Visualización tipo embudo - tamaños proporcionales a PDS</div>
                </div>
                <button class="modal-close" onclick="closeStockFunnelModal()">&times;</button>
            </div>
            <div id="funnel-chart" style="padding:8px 6px 16px 6px;">Cargando...</div>
            <div style="display:flex; justify-content:flex-end; gap:8px;">
                <button class="btn-modal btn-limpiar" onclick="closeStockFunnelModal()">Cerrar</button>
            </div>
        </div>
    </div>

    <!-- MODAL CARGA ASIGNAR ARTES -->
    <div id="modal-loading-artes" class="modal-overlay" style="background: rgba(0,0,0,0.7); pointer-events: auto;">
        <div class="modal-content-loading" style="pointer-events: none;">
            <div style="text-align: center;">
                <div class="spinner" style="margin: 0 auto 20px auto;"></div>
                <div style="font-size: 16px; font-weight: 600; color: var(--gray-800); margin-bottom: 8px;">Cargando cambios...</div>
                <div style="font-size: 12px; color: var(--gray-500);">Por favor, espere mientras se actualizan los datos en el servidor</div>
            </div>
        </div>
    </div>

    <!-- HEADER -->
    <header>
        <div class="brand"><i class="ph ph-table"></i> Prog Corte/Habilitado</div>
        <nav class="nav-tabs">
            <button class="nav-tab active" onclick="switchView('bloqueo', this)">
                <i class="ph ph-lock-key"></i> Bloqueo <span class="badge" id="count-bloqueo">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('lavado', this)">
                <i class="ph ph-drop"></i> Lavanderia <span class="badge" id="count-lavado">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('corte', this)">
                <i class="ph ph-scissors"></i> Corte Pzas <span class="badge" id="count-corte">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('corte-bloques', this)">
                <i class="ph ph-stack"></i> Corte Bloques <span class="badge" id="count-corte-bloques">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('enumerado', this)">
                <i class="ph ph-list-numbers"></i> Enumerado <span class="badge" id="count-enumerado">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('transfer', this)">
                <i class="ph ph-stamp"></i> Transfer <span class="badge" id="count-transfer">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('artes', this)">
                <i class="ph ph-feather"></i> Artes (Pza) <span class="badge" id="count-artes">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('habilitado', this)">
                <i class="ph ph-check-square"></i> Habilitado <span class="badge" id="count-habilitado">0</span>
            </button>
        </nav>
    </header>

    <main>
        
        <!-- VISTA BLOQUEO (TABLA) -->
        <section id="view-bloqueo" class="view-section active">
            <div class="sub-nav">
                <button id="btn-xprog" class="sub-tab active" onclick="filterBloqueo('X PROG', this)">
                    Por Programar <span class="kg-badge" id="kg-xprog">[-]</span>
                </button>
                <button id="btn-prog" class="sub-tab" onclick="filterBloqueo('PROG', this)">
                    Programado <span class="kg-badge" id="kg-prog">[-]</span>
                </button>
            </div>
            
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th id="th-bloqueo-p" style="width: 30px; display:none;">P</th>
                            <th style="width: 70px;">F. GIRADO</th>
                            <th style="width: 65px; text-align: center;">HOD</th>
                            <th style="width: 65px; text-align: center;">F.ING.COST</th>
                            <th style="width: 30px;">CLIENTE</th>
                            <th style="width: 60px;">RUTA</th>
                            
                            <!-- AUMENTADO A 80px PARA VER DATOS LARGOS -->
                            <th style="width: 80px;">OP-PTDA</th>
                            
                            <th style="width: 40px;">OC</th>
                            <th style="width: 65px;">COLOR</th> 
                            <th style="width: 65px; text-align:right;">KG GIRADOS</th>
                            <th style="width: 70px;">ART.</th>
                            <th style="width: 45px;">#MOLDE</th>
                            <th style="width: 65px;">TIPO CERT.</th>
                            <th style="width: 50px;">Bloqueo</th>
                            <th style="width: 50px;">RIB</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-bloqueo"></tbody>
                </table>
            </div>
        </section>

        <!-- VISTA ENUMERADO (FILAS CON STATUS = OK) -->
        <section id="view-enumerado" class="view-section">
            <div class="sub-nav" style="margin-bottom:10px;">
                <button id="enumerado-btn-por" class="sub-tab active">
                    Por enumerar <span class="kg-badge" id="enumerado-pds-por">[-]</span>
                </button>
            </div>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th id="th-enumerado-p" style="width: 30px;">P</th>
                            <th style="width: 65px; text-align: center;">HOD</th>
                            <th style="width: 75px; text-align: center;">F.ING.COST</th>
                            <th style="width: 40px;">CLIENTE</th>
                            <th style="width: 50px;">RUTA</th>
                            <th style="width: 45px;">OC</th>
                            <th style="width: 80px;">COLOR</th>
                            <th style="width: 80px;">OP-PTDA</th>
                            <th style="width: 45px; text-align:center;">PDS</th>
                            <th style="width: 60px;">PRENDA</th>
                            <th style="width: 70px;">ART.</th>
                            <th style="width: 70px;">TIPO CERT.</th>
                            <th style="width: 85px;">RIB</th>
                            <th style="width: 80px;">equipo_corte</th>
                            <th style="width: 80px;">STATUS_CORTE</th>
                            <th style="width: 80px;">BLOQUES?</th>
                            <th style="width: 80px;">COLL o TAP?</th>
                            <th style="width: 80px;">estado_enumerado</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-enumerado"></tbody>
                </table>
            </div>
        </section>

        <!-- VISTA TRANSFER -->
        <section id="view-transfer" class="view-section">
            <div class="sub-nav">
                <button id="btn-transfer-xprog" class="sub-tab active" onclick="filterTransfer('X PROG', this)">
                    Por Programar <span class="kg-badge" id="transfer-pds-xprog">[-]</span>
                </button>
                <button id="btn-transfer-prog" class="sub-tab" onclick="filterTransfer('PROG', this)">
                    Programado <span class="kg-badge" id="transfer-pds-prog">[-]</span>
                </button>
                <button id="btn-transfer-asignar" class="sub-tab" onclick="filterTransfer('ASIGNAR', this)">
                    Asignar #Trf
                </button>
            </div>
            
            <!-- Filtros para Asignar #Trf -->
            <div id="transfer-asignar-filters" style="display:none; margin-bottom:15px; gap:10px; align-items:center;">
                <label style="font-weight:600; font-size:12px; color:var(--gray-600);">Filtrar por:</label>
                <!-- Nuevo filtro: Todos / Con dato / Sin dato -->
                <select id="filter-transfer-haydato" style="padding:6px 10px; border-radius:4px; border:1px solid var(--gray-300); font-size:12px;" onchange="renderTransferAsignar()">
                    <option value="">Todos</option>
                    <option value="CON">Con dato</option>
                    <option value="SIN">Sin dato</option>
                </select>
                <select id="filter-transfer-cliente" style="padding:6px 10px; border-radius:4px; border:1px solid var(--gray-300); font-size:12px;" onchange="renderTransferAsignar()">
                    <option value="">Todos los clientes</option>
                </select>
                <select id="filter-transfer-estilo" style="padding:6px 10px; border-radius:4px; border:1px solid var(--gray-300); font-size:12px;" onchange="renderTransferAsignar()">
                    <option value="">Todos los estilos</option>
                </select>
                <button onclick="guardarCambiosAsignarTransfer()" style="padding:6px 16px; background:var(--primary); color:white; border:none; border-radius:4px; font-weight:600; cursor:pointer; font-size:12px;">Guardar</button>
                <label class="filter-item" style="margin-left:8px; font-weight:600; font-size:12px; display:inline-flex; align-items:center; gap:6px;">
                    <input type="checkbox" id="chk-transfer-para-todo" style="width:18px;height:18px;vertical-align:middle;"> Para todo
                </label>
            </div>
            
            <div id="table-container-transfer-normal" class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th id="th-transfer-p" style="width: 30px; display:none;">P</th>
                            <th style="width: 65px; text-align: center;">HOD</th>
                            <th style="width: 75px; text-align: center;">F.ING.COST</th>
                            <th style="width: 40px;">CLIENTE</th>
                            <th style="width: 50px;">RUTA</th>
                            <th style="width: 45px;">OC</th>
                            <th style="width: 80px;">COLOR</th>
                            <th style="width: 45px; text-align:center;">PDS</th>
                            <th style="width: 60px;">PRENDA</th>
                            <th style="width: 70px;">TIPO CERT.</th>
                            <th style="width: 90px;">n.transfxpda</th>
                                        <th style="width: 90px;">tipo-transfer</th>
                                        <th style="width: 90px;">estado_transfer</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-transfer"></tbody>
                </table>
            </div>
            
            <!-- Tabla para Asignar #Trf -->
            <div id="table-container-transfer-asignar" class="table-container" style="display:none;">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 150px;">CLIENTE</th>
                            <th style="width: 200px;">ESTILO</th>
                            <th style="width: 80px;">OP</th>
                            <th style="width: 120px;">tipo-transfer</th>
                            <th style="width: 150px;">n.transfxpda</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-transfer-asignar"></tbody>
                </table>
            </div>
        </section>
        
        <!-- VISTA ARTES (Pza) -->
        <section id="view-artes" class="view-section">
            <div class="sub-nav">
                <button id="btn-artes-bordado" class="sub-tab active" onclick="filterArtes('BORDADO', this)">
                    Bordado <span class="kg-badge" id="artes-pds-bordado">[-]</span>
                </button>
                <button id="btn-artes-estampado" class="sub-tab" onclick="filterArtes('ESTAMPADO', this)">
                    Estampado <span class="kg-badge" id="artes-pds-estampado">[-]</span>
                </button>
                <button id="btn-artes-asignar" class="sub-tab" onclick="filterArtes('ASIGNAR', this)">
                    Asignar Artes
                </button>
            </div>

            <!-- Sub-tabs específicos para Bordado: X PROG / PROG -->
            <div id="bordado-subtabs" style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
                <button id="btn-bordado-xprog" class="sub-tab active" onclick="filterBordado('X PROG', this)">X PROG <span class="kg-badge" id="artes-bordado-xprog-count">[-]</span></button>
                <button id="btn-bordado-prog" class="sub-tab" onclick="filterBordado('PROG', this)">PROG <span class="kg-badge" id="artes-bordado-prog-count">[-]</span></button>
            </div>

            <!-- Sub-tabs específicos para Estampado: X PROG / PROG (oculto hasta activar Estampado) -->
            <div id="estampado-subtabs" style="display:none; gap:8px; align-items:center; margin-bottom:10px;">
                <button id="btn-estampado-xprog" class="sub-tab active" onclick="filterEstampado('X PROG', this)">X PROG <span class="kg-badge" id="artes-estampado-xprog-count">[-]</span></button>
                <button id="btn-estampado-prog" class="sub-tab" onclick="filterEstampado('PROG', this)">PROG <span class="kg-badge" id="artes-estampado-prog-count">[-]</span></button>
            </div>

            <!-- Filtros para Asignar Artes -->
            <div id="artes-asignar-filters" style="display:none; margin-bottom:15px; gap:10px; align-items:center;">
                <label style="font-weight:600; font-size:12px; color:var(--gray-600);">Filtrar por:</label>
                <select id="filter-artes-haydato" style="padding:6px 10px; border-radius:4px; border:1px solid var(--gray-300); font-size:12px;" onchange="renderArtesAsignar()">
                    <option value="">Todos</option>
                    <option value="CON">Con dato</option>
                    <option value="SIN">Sin dato</option>
                </select>
                <select id="filter-artes-cliente" style="padding:6px 10px; border-radius:4px; border:1px solid var(--gray-300); font-size:12px;" onchange="renderArtesAsignar()">
                    <option value="">Todos los clientes</option>
                </select>
                <select id="filter-artes-estilo" style="padding:6px 10px; border-radius:4px; border:1px solid var(--gray-300); font-size:12px;" onchange="renderArtesAsignar()">
                    <option value="">Todos los estilos</option>
                </select>
                <button onclick="guardarCambiosAsignarArtes()" style="padding:6px 16px; background:var(--primary); color:white; border:none; border-radius:4px; font-weight:600; cursor:pointer; font-size:12px;">Guardar</button>
                <label class="filter-item" style="margin-left:8px; font-weight:600; font-size:12px; display:inline-flex; align-items:center; gap:6px;">
                    <input type="checkbox" id="chk-artes-para-todo" style="width:18px;height:18px;vertical-align:middle;"> Para todo
                </label>
            </div>

            <!-- Tabla Bordado -->
            <div id="table-container-artes-bordado" class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 65px; text-align: center;">HOD</th>
                            <th style="width: 75px; text-align: center;">F.ING.COST</th>
                            <th style="width: 40px;">CLIENTE</th>
                            <th style="width: 45px;">OC</th>
                            <th style="width: 80px;">COLOR</th>
                            <th style="width: 45px; text-align:center;">PDS</th>
                            <th style="width: 60px;">PRENDA</th>
                            <th style="width: 70px;">TIPO CERT.</th>
                            <th style="width: 80px;">n.BDxpda</th>
                            <th style="width: 100px;">estado_bordado</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-artes-bordado"></tbody>
                </table>
            </div>

            <!-- Tabla Estampado -->
            <div id="table-container-artes-estampado" class="table-container" style="display:none;">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 65px; text-align: center;">HOD</th>
                            <th style="width: 75px; text-align: center;">F.ING.COST</th>
                            <th style="width: 40px;">CLIENTE</th>
                            <th style="width: 45px;">OC</th>
                            <th style="width: 80px;">COLOR</th>
                            <th style="width: 45px; text-align:center;">PDS</th>
                            <th style="width: 60px;">PRENDA</th>
                            <th style="width: 70px;">TIPO CERT.</th>
                            <th style="width: 80px;">n.ESTAMPxpda</th>
                            <th style="width: 100px;">estado_estampado</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-artes-estampado"></tbody>
                </table>
            </div>

            <!-- Tabla para Asignar Artes -->
            <div id="table-container-artes-asignar" class="table-container" style="display:none;">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 150px;">CLIENTE</th>
                            <th style="width: 200px;">ESTILO</th>
                            <th style="width: 80px;">OP</th>
                            <th style="width: 140px;">n.BDxpda</th>
                            <th style="width: 140px;">n.ESTAMPxpda</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-artes-asignar"></tbody>
                </table>
            </div>
        </section>

                <!-- VISTA HABILITADO (Filtrado de Enumerado con estado_enumerado = OK ENM / OK S/ENM) -->
                <section id="view-habilitado" class="view-section">
                    <div class="sub-nav" style="margin-bottom:10px;">
                        <button id="habilitado-btn-xprog" class="sub-tab active" onclick="filterHabilitado('X PROG', this)">
                            Por Programar <span class="kg-badge" id="habilitado-pds-xprog">[-]</span>
                        </button>
                        <button id="habilitado-btn-1t" class="sub-tab" onclick="filterHabilitado('PROG 1T', this)">
                            PROG 1T <span class="kg-badge" id="habilitado-pds-1t">[-]</span>
                        </button>
                        <button id="habilitado-btn-2t" class="sub-tab" onclick="filterHabilitado('PROG 2T', this)">
                            PROG 2T <span class="kg-badge" id="habilitado-pds-2t">[-]</span>
                        </button>
                        <button id="habilitado-btn-3t" class="sub-tab" onclick="filterHabilitado('PROG 3T', this)">
                            PROG 3T <span class="kg-badge" id="habilitado-pds-3t">[-]</span>
                        </button>
                    </div>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th id="th-habilitado-p" style="width: 30px;">P</th>
                                    <th style="width: 65px; text-align: center;">HOD</th>
                                    <th style="width: 80px; text-align: center;">F.ING.COST</th>
                                    <th style="width: 80px; text-align:center;">STATUS</th>
                                    <th style="width: 55px; text-align:center;">CLIENTE</th>
                                    <th style="width: 75px;">OC</th>
                                    <th style="width: 100px;">COLOR</th>
                                    <th style="width: 60px; text-align:center;">PDS</th>
                                    <th style="width: 60px;">PRENDA</th>
                                    <th style="width: 100px;">CERTIFICADO</th>
                                    <th style="width: 70px; text-align:center;">RIB</th>
                                    <th style="width: 70px; text-align:center;">BLOQUES?</th>
                                    <th style="width: 80px; text-align:center;">COLL o TAP?</th>
                                    <th style="width: 85px; white-space:nowrap; text-align:center;">TRSF</th>
                                    <th style="width: 60px; white-space:nowrap; text-align:center;">BORD</th>
                                    <th style="width: 60px; text-align:center;">ESTMP</th>
                                    <th style="width: auto; white-space: nowrap;">HABILITADO</th>
                                </tr>
                            </thead>
                            <tbody id="tbody-habilitado"></tbody>
                        </table>
                    </div>
                </section>

        <!-- VISTA LAVADO (TABLA DETALLADA) -->
        <section id="view-lavado" class="view-section">
            <div class="sub-nav">
                <!-- Solo un botón "Por Lavar" -->
                <button id="btn-enlav" class="sub-tab active" onclick="filterLavado('EN LAV', this)">
                    Por Lavar <span class="kg-badge" id="kg-enlav">[-]</span>
                </button>
            </div>

            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th id="th-lavado-p" style="width: 30px;">P</th>
                            <th style="width: 65px; text-align: center;">HOD</th>
                            <th style="width: 65px; text-align: center;">F.ING.COST</th>
                            <th style="width: 30px;">CLIENTE</th>
                            
                            <!-- AUMENTADO A 80px -->
                            <th style="width: 80px;">OP-PTDA</th>
                            
                            <th style="width: 40px;">OC</th>
                            <th style="width: 65px;">COLOR</th> 
                            <th style="width: 65px; text-align:right;">KG GIRADOS</th>
                            <th style="width: 70px;">ART.</th>
                            <th style="width: 65px;">TIPO CERT.</th>
                            <th style="width: 100px;">Lavado</th>
                            <th style="width: 85px;">RIB</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-lavado"></tbody>
                </table>
            </div>
        </section>

        <!-- VISTA CORTE (TABLA) -->
        <section id="view-corte" class="view-section">
            <div class="sub-nav" style="margin-bottom:10px;">
                <button id="corte-btn-xprog" class="sub-tab active" onclick="filterCorte('X PROG', this)">
                    Por Programar <span class="kg-badge" id="corte-pds-xprog">[-]</span>
                </button>
                <button id="corte-btn-1t" class="sub-tab" onclick="filterCorte('PROG 1T', this)">
                    PROG 1T <span class="kg-badge" id="corte-pds-1t">[-]</span>
                </button>
                <button id="corte-btn-2t" class="sub-tab" onclick="filterCorte('PROG 2T', this)">
                    PROG 2T <span class="kg-badge" id="corte-pds-2t">[-]</span>
                </button>
                <button id="corte-btn-3t" class="sub-tab" onclick="filterCorte('PROG 3T', this)">
                    PROG 3T <span class="kg-badge" id="corte-pds-3t">[-]</span>
                </button>
                <button id="eqcorte-btn" class="sub-tab" onclick="abrirModalEQCorte()" style="background: var(--primary-light); color: var(--primary); border: 1px solid var(--primary);">
                    <i class="ph ph-gear"></i> EQ_Corte
                </button>
                    <!-- Filtros por RUTA a la derecha -->
                    <div class="sub-filters" id="corte-route-filters" style="display:flex;">
                        <label class="filter-item"><input type="checkbox" id="flt-lv" onchange="onRouteFilterChange('LV-ok', this.checked)"><span>LV-ok</span></label>
                        <label class="filter-item"><input type="checkbox" id="flt-ac" onchange="onRouteFilterChange('AC', this.checked)"><span>AC</span></label>
                        <label class="filter-item"><input type="checkbox" id="flt-xl" onchange="onRouteFilterChange('x lavar', this.checked)"><span>x lavar</span></label>
                        <label class="filter-item"><input type="checkbox" id="flt-xb" onchange="onRouteFilterChange('x bloq', this.checked)"><span>x bloq</span></label>
                        <label class="filter-item"><input type="checkbox" id="flt-normal" onchange="onRouteFilterChange('NORMAL', this.checked)"><span>Normal</span></label>
                    </div>
            </div>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th id="th-corte-p" style="width: 30px; display:none;">P</th>
                            <th style="width: 70px;">F. GIRADO</th>
                            <th style="width: 65px; text-align: center;">HOD</th>
                            <th style="width: 75px; text-align: center;">F.ING.COST</th>
                            <th style="width: 40px;">CLIENTE</th>
                            <th style="width: 50px;">RUTA</th>
                            <th style="width: 60px;">OC</th>
                            <th style="width: 80px;">COLOR</th>
                            <th style="width: 80px;">OP-PTDA</th>
                            <th style="width: 45px; text-align:center;">PDS</th>
                            <th style="width: 60px;">PRENDA</th>
                            <th style="width: 70px;">ART.</th>
                            <th style="width: 70px;">TIPO CERT.</th>
                            <th style="width: 72px;">RIB</th>
                            <th style="width: 80px;">equipo_corte</th>
                            <th style="width: 80px;">STATUS_CORTE</th>
                            <th style="width: 72px;">estado_bloques</th>
                            <th style="width: 72px;">estado_coll_tap</th>
                    </thead>
                    <tbody id="tbody-corte"></tbody>
                </table>
            </div>
        </section>

        <!-- VISTA CORTE BLOQUES -->
        <section id="view-corte-bloques" class="view-section">
            <div class="sub-nav" style="margin-bottom:10px;">
                <button id="corte-bloques-btn-xprog" class="sub-tab active" onclick="filterCorteBloques('X PROG', this)">
                    Por Programar <span class="kg-badge" id="corte-bloques-pds-xprog">[-]</span>
                </button>
                <button id="corte-bloques-btn-prog" class="sub-tab" onclick="filterCorteBloques('PROG', this)">
                    Programado <span class="kg-badge" id="corte-bloques-pds-prog">[-]</span>
                </button>
            </div>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th id="th-corte-bloques-p" style="width: 30px; display:none;">P</th>
                            <th style="width: 65px; text-align: center;">HOD</th>
                            <th style="width: 75px; text-align: center;">F.ING.COST</th>
                            <th style="width: 40px;">CLIENTE</th>
                            <th style="width: 50px;">RUTA</th>
                            <th style="width: 60px;">OC</th>
                            <th style="width: 80px;">COLOR</th>
                            <th style="width: 80px;">OP-PTDA</th>
                            <th style="width: 45px; text-align:center;">PDS</th>
                            <th style="width: 60px;">PRENDA</th>
                            <th style="width: 70px;">ART.</th>
                            <th style="width: 70px;">TIPO CERT.</th>
                            <!-- RIB removed -->
                            <th style="width: 85px;">equipo_corte</th>
                            <th style="width: 80px;">STATUS_CORTE</th>
                            <th style="width: 80px;">BLOQUES?</th>
                            <!-- COLL/TAP removed -->
                            <th style="width: 120px;">ESTADO_BLOQS</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-corte-bloques"></tbody>
                </table>
            </div>
        </section>

    </main>

    <script>
        // --- CONFIGURACIÓN ---
        const WEB_APP_URL = "https://script.google.com/macros/s/AKfycbykoMk9xn1degxUPr1CN2XvBm5tRvlDNY0ox-k3EdI0xIoxEXsQ9FN7SsSqrPN1fQGyRw/exec"; 
        const SHEET_ID = "18cQuwqerdMggAeJ8TCUKA7-gujXsA91-CRMUTNpr8aQ";

        let rawData = [];
        let colMap = {};
        let currentBloqueoFilter = 'X PROG';
        // Filtro aplicado desde el encabezado de Bloqueo (campo + valor)
        let bloqueoHeaderFilter = null; // { field: 'CLIENTE', value: 'ABC' }
        // Filtro aplicado desde el encabezado de Corte (campo + valor)
        let corteHeaderFilter = null; // { field: 'CLIENTE', value: 'ABC' }
        // Filtro aplicado desde el encabezado de Enumerado (campo + valor)
        let enumeradoHeaderFilter = null; // { field: 'CLIENTE', value: 'ABC' }
        // Filtro aplicado desde el encabezado de Habilitado (campo + valor)
        let habilitadoHeaderFilter = null; // { field: 'CLIENTE', value: 'ABC' }
        let currentLavadoFilter = 'EN LAV';
        let currentCorteFilter = 'X PROG';
        let currentCorteBloquesFilter = 'X PROG';
        let currentTransferFilter = 'X PROG';
        let currentHabilitadoFilter = 'X PROG';

        // Bases de tendidos creadas en esta sesión / previamente: persistidas en localStorage
        try {
            const saved = localStorage.getItem('createdTendidoBases');
            window._createdTendidoBases = new Set(saved ? JSON.parse(saved) : []);
        } catch (e) { window._createdTendidoBases = new Set(); }

        function addCreatedTendidoBase(base) {
            if (!base) return;
            try {
                window._createdTendidoBases.add(base);
                localStorage.setItem('createdTendidoBases', JSON.stringify(Array.from(window._createdTendidoBases)));
            } catch (e) { console.error('Error saving created tendido base', e); }
        }

        // Variables para el modal de tendido
        let modalTendidoData = {
            rowIndex: null,
            oc: '',
            op: '',
            corte: '',
            color: '',
            pdsTotal: 0
        };

        // Maneja cambios en el select de n.transfxpda; si está marcado 'Para todo'
        // aplica el mismo valor a todos los grupos visibles y dispara el guardado.
        window.handleNTransfChange = function(selectElement) {
            const chk = document.getElementById('chk-transfer-para-todo');
            const val = selectElement.value;
            if (chk && chk.checked) {
                // Mostrar modal de carga
                const modal = document.getElementById('modal-loading-artes');
                if (modal) modal.classList.add('active');
                
                const all = Array.from(document.querySelectorAll('#tbody-transfer-asignar select.sel-ntransf-transfer'));
                
                // Buscar índice de la columna
                let idx = findHeaderIndexCaseInsensitive('n.transfxpda');
                if (idx === -1) idx = colMap['n.transfxpda'];
                if (idx === -1 || idx === undefined) idx = colMap['N.TRANSFXPDA'];
                if (idx === -1 || idx === undefined) idx = getColIndex('n.transfxpda');
                
                // Recolectar TODAS las filas a actualizar de TODOS los grupos
                const allRowsToUpdate = [];
                all.forEach(s => {
                    const cliente = s.dataset.cliente;
                    const estilo = s.dataset.estilo;
                    s.disabled = true;
                    s.value = val;
                    for (let i = 1; i < rawData.length; i++) {
                        const row = rawData[i];
                        const rowClienteRaw = getVal(row, 'CLIENTE') || '';
                        const rowCliente = normalizeClientForTransfer(rowClienteRaw);
                        const rowEstilo = getVal(row, 'ESTILO');
                        if (rowCliente === cliente && rowEstilo === estilo) {
                            if (idx !== -1 && idx !== undefined) rawData[i][idx] = val;
                            allRowsToUpdate.push(i);
                        }
                    }
                });
                
                // Enviar peticiones secuencialmente con delay suficiente
                let completedCount = 0;
                const totalCount = allRowsToUpdate.length;
                
                if (totalCount === 0) {
                    if (modal) modal.classList.remove('active');
                    all.forEach(s => s.disabled = false);
                    chk.checked = false;
                    return;
                }
                
                allRowsToUpdate.forEach((rowIndex, i) => {
                    setTimeout(() => {
                        fetch(WEB_APP_URL, {
                            method: 'POST',
                            mode: 'no-cors',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'update', row: rowIndex, colName: 'n.transfxpda', value: val })
                        }).then(() => {
                            completedCount++;
                            if (completedCount === totalCount) {
                                all.forEach(s => s.disabled = false);
                                updateCounters();
                                renderTransfer();
                                try { renderTransferAsignar(); } catch(e) {}
                                if (modal) modal.classList.remove('active');
                            }
                        }).catch(err => {
                            console.error('Error al guardar n.transfxpda fila', rowIndex, err);
                            completedCount++;
                            if (completedCount === totalCount) {
                                all.forEach(s => s.disabled = false);
                                if (modal) modal.classList.remove('active');
                            }
                        });
                    }, i * 200); // 200ms entre cada petición
                });
                
                chk.checked = false;
            } else {
                updateClienteEstiloTransfer(selectElement.dataset.cliente, selectElement.dataset.estilo, selectElement.value, selectElement);
            }
        };

        // Maneja cambios en el select de tipo-transfer; si está marcado 'Para todo'
        // aplica el mismo valor a todos los grupos visibles y dispara el guardado.
        window.handleTipoTransferChange = function(selectElement) {
            const chk = document.getElementById('chk-transfer-para-todo');
            const val = selectElement.value;
            if (chk && chk.checked) {
                // Mostrar modal de carga
                const modal = document.getElementById('modal-loading-artes');
                if (modal) modal.classList.add('active');
                
                const all = Array.from(document.querySelectorAll('#tbody-transfer-asignar select.sel-tipo-transfer'));
                
                // Buscar índice de la columna
                let idx = findHeaderIndexCaseInsensitive('tipo-transfer');
                if (idx === -1) idx = findHeaderIndexCaseInsensitive('tipo_transfer');
                if (idx === -1) idx = findHeaderIndexCaseInsensitive('tipotransfer');
                if (idx === -1) idx = colMap['tipo-transfer'] || colMap['tipo_transfer'] || -1;
                if (idx === -1) idx = getColIndex('tipo-transfer');
                
                // Determinar nombre exacto de encabezado para enviar al backend
                let sendColName = (idx !== -1 && rawData[0] && rawData[0][idx]) ? rawData[0][idx] : 'tipo-transfer';
                
                // Recolectar TODAS las filas a actualizar de TODOS los grupos
                const allRowsToUpdate = [];
                all.forEach(s => {
                    const cliente = s.dataset.cliente;
                    const estilo = s.dataset.estilo;
                    s.disabled = true;
                    s.value = val;
                    for (let i = 1; i < rawData.length; i++) {
                        const row = rawData[i];
                        const rowClienteRaw = getVal(row, 'CLIENTE') || '';
                        const rowCliente = normalizeClientForTransfer(rowClienteRaw);
                        const rowEstilo = getVal(row, 'ESTILO');
                        if (rowCliente === cliente && rowEstilo === estilo) {
                            if (idx !== -1 && idx !== undefined) rawData[i][idx] = val;
                            allRowsToUpdate.push(i);
                        }
                    }
                });
                
                // Enviar peticiones secuencialmente con delay suficiente
                let completedCount = 0;
                const totalCount = allRowsToUpdate.length;
                
                if (totalCount === 0) {
                    if (modal) modal.classList.remove('active');
                    all.forEach(s => s.disabled = false);
                    chk.checked = false;
                    return;
                }
                
                allRowsToUpdate.forEach((rowIndex, i) => {
                    setTimeout(() => {
                        fetch(WEB_APP_URL, {
                            method: 'POST',
                            mode: 'no-cors',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'update', row: rowIndex, colName: sendColName, value: val })
                        }).then(() => {
                            completedCount++;
                            if (completedCount === totalCount) {
                                all.forEach(s => s.disabled = false);
                                updateCounters();
                                renderTransferAsignar();
                                renderTransfer();
                                if (modal) modal.classList.remove('active');
                            }
                        }).catch(err => {
                            console.error('Error al guardar tipo-transfer fila', rowIndex, err);
                            completedCount++;
                            if (completedCount === totalCount) {
                                all.forEach(s => s.disabled = false);
                                if (modal) modal.classList.remove('active');
                            }
                        });
                    }, i * 200); // 200ms entre cada petición
                });
                
                chk.checked = false;
            } else {
                updateClienteEstiloTipoTransfer(selectElement.dataset.cliente, selectElement.dataset.estilo, selectElement.value, selectElement);
            }
        };

        // Maneja cambios en n.BDxpda para Asignar Artes. Si 'Para todo' está marcado,
        // aplica el mismo valor a todos los selects visibles en '#tbody-artes-asignar'.
        window.handleNBDChange = function(selectElement) {
            const chk = document.getElementById('chk-artes-para-todo');
            const val = selectElement.value;
            if (chk && chk.checked) {
                // Mostrar modal de carga
                const modal = document.getElementById('modal-loading-artes');
                if (modal) modal.classList.add('active');
                
                const all = Array.from(document.querySelectorAll('#tbody-artes-asignar select.sel-nbd-artes'));
                
                // Buscar índice de la columna
                let idx = getColIndex('n.BDxpda');
                if (idx === -1) {
                    for (const k in colMap) { if (k.toString().toUpperCase().indexOf('N.BDXPDA') !== -1) { idx = colMap[k]; break; } }
                }
                
                // Recolectar TODAS las filas a actualizar de TODOS los grupos
                const allRowsToUpdate = [];
                const clienteNorm = normalizeClientForTransfer;
                
                all.forEach(s => {
                    const cliente = s.dataset.cliente;
                    const estilo = s.dataset.estilo;
                    s.disabled = true;
                    s.value = val;
                    for (let i = 1; i < rawData.length; i++) {
                        const rCliente = normalizeClientForTransfer(getVal(rawData[i], 'CLIENTE') || '');
                        const rEstilo = (getVal(rawData[i], 'ESTILO') || '').toString().trim();
                        if (rCliente === cliente && rEstilo === estilo) {
                            if (idx !== -1 && idx !== undefined) rawData[i][idx] = val;
                            allRowsToUpdate.push(i);
                        }
                    }
                });
                
                // Enviar peticiones secuencialmente con delay suficiente
                let completedCount = 0;
                const totalCount = allRowsToUpdate.length;
                
                if (totalCount === 0) {
                    if (modal) modal.classList.remove('active');
                    all.forEach(s => s.disabled = false);
                    chk.checked = false;
                    return;
                }
                
                allRowsToUpdate.forEach((rowIndex, i) => {
                    setTimeout(() => {
                        fetch(WEB_APP_URL, {
                            method: 'POST',
                            mode: 'no-cors',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'update', row: rowIndex, colName: 'n.BDxpda', value: val })
                        }).then(() => {
                            completedCount++;
                            if (completedCount === totalCount) {
                                all.forEach(s => s.disabled = false);
                                updateCounters();
                                renderArtes();
                                if (modal) modal.classList.remove('active');
                            }
                        }).catch(err => {
                            console.error('Error al guardar n.BDxpda fila', rowIndex, err);
                            completedCount++;
                            if (completedCount === totalCount) {
                                all.forEach(s => s.disabled = false);
                                if (modal) modal.classList.remove('active');
                            }
                        });
                    }, i * 200); // 200ms entre cada petición
                });
                
                chk.checked = false;
            } else {
                updateClienteEstiloArtes(selectElement.getAttribute('data-cliente'), selectElement.getAttribute('data-estilo'), selectElement.value, 'n.BDxpda', selectElement);
            }
        };

        // Maneja cambios en n.ESTAMPxpda para Asignar Artes. Si 'Para todo' está marcado,
        // aplica el mismo valor a todos los selects visibles en '#tbody-artes-asignar'.
        window.handleNESTChange = function(selectElement) {
            const chk = document.getElementById('chk-artes-para-todo');
            const val = selectElement.value;
            if (chk && chk.checked) {
                // Mostrar modal de carga
                const modal = document.getElementById('modal-loading-artes');
                if (modal) modal.classList.add('active');
                
                const all = Array.from(document.querySelectorAll('#tbody-artes-asignar select.sel-nest-artes'));
                
                // Buscar índice de la columna
                let idx = getColIndex('n.ESTAMPxpda');
                if (idx === -1) {
                    for (const k in colMap) { if (k.toString().toUpperCase().indexOf('N.ESTAMPXPDA') !== -1) { idx = colMap[k]; break; } }
                }
                
                // Recolectar TODAS las filas a actualizar de TODOS los grupos
                const allRowsToUpdate = [];
                
                all.forEach(s => {
                    const cliente = s.dataset.cliente;
                    const estilo = s.dataset.estilo;
                    s.disabled = true;
                    s.value = val;
                    for (let i = 1; i < rawData.length; i++) {
                        const rCliente = normalizeClientForTransfer(getVal(rawData[i], 'CLIENTE') || '');
                        const rEstilo = (getVal(rawData[i], 'ESTILO') || '').toString().trim();
                        if (rCliente === cliente && rEstilo === estilo) {
                            if (idx !== -1 && idx !== undefined) rawData[i][idx] = val;
                            allRowsToUpdate.push(i);
                        }
                    }
                });
                
                // Enviar peticiones secuencialmente con delay suficiente
                let completedCount = 0;
                const totalCount = allRowsToUpdate.length;
                
                if (totalCount === 0) {
                    if (modal) modal.classList.remove('active');
                    all.forEach(s => s.disabled = false);
                    chk.checked = false;
                    return;
                }
                
                allRowsToUpdate.forEach((rowIndex, i) => {
                    setTimeout(() => {
                        fetch(WEB_APP_URL, {
                            method: 'POST',
                            mode: 'no-cors',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'update', row: rowIndex, colName: 'n.ESTAMPxpda', value: val })
                        }).then(() => {
                            completedCount++;
                            if (completedCount === totalCount) {
                                all.forEach(s => s.disabled = false);
                                updateCounters();
                                renderArtes();
                                if (modal) modal.classList.remove('active');
                            }
                        }).catch(err => {
                            console.error('Error al guardar n.ESTAMPxpda fila', rowIndex, err);
                            completedCount++;
                            if (completedCount === totalCount) {
                                all.forEach(s => s.disabled = false);
                                if (modal) modal.classList.remove('active');
                            }
                        });
                    }, i * 200); // 200ms entre cada petición
                });
                
                chk.checked = false;
            } else {
                updateClienteEstiloArtes(selectElement.getAttribute('data-cliente'), selectElement.getAttribute('data-estilo'), selectElement.value, 'n.ESTAMPxpda', selectElement);
            }
        };

        // Función para actualizar la columna 'tipo-transfer' en todas las filas de un CLIENTE + ESTILO
        window.updateClienteEstiloTipoTransfer = function(cliente, estilo, value, selectElement) {
            if (!cliente || !estilo) return;

            // Mostrar modal de carga al inicio
            const modal = document.getElementById('modal-loading-artes');
            if (modal) modal.classList.add('active');

            // Buscar índice de tipo-transfer de forma flexible
            let idx = findHeaderIndexCaseInsensitive('tipo-transfer');
            if (idx === -1) idx = findHeaderIndexCaseInsensitive('tipo_transfer');
            if (idx === -1) idx = findHeaderIndexCaseInsensitive('tipotransfer');
            if (idx === -1) idx = colMap['tipo-transfer'] || colMap['tipo_transfer'] || -1;
            if (idx === -1) idx = getColIndex('tipo-transfer');

            if (idx === -1 || idx === undefined) {
                alert('Error: No se encontró la columna tipo-transfer');
                if (modal) modal.classList.remove('active');
                return;
            }

            // Recopilar filas a actualizar
            const rowsToUpdate = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const rowClienteRaw = getVal(row, 'CLIENTE') || '';
                const rowCliente = normalizeClientForTransfer(rowClienteRaw);
                const rowEstilo = getVal(row, 'ESTILO');
                if (rowCliente === cliente && rowEstilo === estilo) {
                    rowsToUpdate.push(i);
                    rawData[i][idx] = value;
                }
            }

            if (rowsToUpdate.length === 0) {
                alert('No se encontraron filas para actualizar');
                if (modal) modal.classList.remove('active');
                return;
            }

            if (selectElement) selectElement.disabled = true;

            let completedCount = 0;
            const totalCount = rowsToUpdate.length;

            rowsToUpdate.forEach((rowIndex, i) => {
                setTimeout(() => {
                    // Determinar nombre exacto de encabezado para enviar al backend
                    let sendColName = (rawData[0] && rawData[0][idx]) ? rawData[0][idx] : 'tipo-transfer';
                    fetch(WEB_APP_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'update', row: rowIndex, colName: sendColName, value: value })
                    }).then(() => {
                        completedCount++;
                        if (completedCount === totalCount) {
                            if (selectElement) selectElement.disabled = false;
                            updateCounters();
                            renderTransferAsignar();
                            renderTransfer();
                            // Cerrar modal de carga cuando todos los datos se hayan actualizado
                            const modal = document.getElementById('modal-loading-artes');
                            if (modal) modal.classList.remove('active');
                        }
                    }).catch(err => {
                        console.error('Error al guardar tipo-transfer fila', rowIndex, err);
                        completedCount++;
                        if (completedCount === totalCount) {
                            if (selectElement) selectElement.disabled = false;
                            // Cerrar modal de carga incluso si hay error
                            const modal = document.getElementById('modal-loading-artes');
                            if (modal) modal.classList.remove('active');
                        }
                    });
                }, i * 100);
            });
        };

        // Filtros por RUTA (por defecto todos desactivados -> sin filtrado)
        const routeFilters = {
            'LV-ok': false,
            'AC': false,
            'x lavar': false,
            'x bloq': false,
            'NORMAL': false
        };

        function onRouteFilterChange(key, checked) {
            if (routeFilters.hasOwnProperty(key)) routeFilters[key] = !!checked;
            // Si estamos en Corte y en el sub-tab X PROG, re-renderizar para aplicar filtros
            try { if (document.getElementById('view-corte').classList.contains('active') && currentCorteFilter === 'X PROG') renderCorte(); } catch(e){}
        }

        // Determina la clave simple de RUTA para una fila (debe coincidir con las keys de routeFilters)
        function getRouteKeyForRow(row) {
            const rutaVal = getVal(row, "RUTA TELA") || getVal(row, "RUTA") || "";
            const rutaKey = String(rutaVal || "").toUpperCase().trim();
            if (rutaKey.indexOf('NORMAL') !== -1) return 'NORMAL';
            if (rutaKey === 'ACABADA') return 'AC';
            if (rutaKey === 'LAVADA') {
                const estadoBloqRaw = getVal(row, "estado_bloqueo");
                const estadoBloq = (!estadoBloqRaw || estadoBloqRaw === "") ? "X PROG" : String(estadoBloqRaw).toUpperCase().trim();
                const estadoLavRaw = getVal(row, "estado_lavada");
                const estadoLav = (!estadoLavRaw || estadoLavRaw === "") ? "" : String(estadoLavRaw).toUpperCase().trim();

                if (estadoBloq.includes('PROG')) return 'x bloq';
                if (estadoBloq === 'OK' && (estadoLav === '' || estadoLav === 'EN LAV')) return 'x lavar';
                if (estadoLav === 'OK') return 'LV-ok';
                return 'LV-ok';
            }
            return String(rutaVal || '').trim();
        }

        document.addEventListener('DOMContentLoaded', initApp);

        function initApp() {
            const script = document.createElement('script');
            script.src = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=responseHandler:loadDataCallback`;
            script.onerror = () => showError("Error de conexión con Google Sheets.");
            document.body.appendChild(script);
            
            // Cargar equipos de corte en segundo plano
            cargarEquiposCorteBackground();
            // Configurar menú contextual del encabezado de Bloqueo, Corte y Enumerado
            try { setupBloqueoHeaderFilterMenu(); } catch(e) { console.error('setupBloqueoHeaderFilterMenu error', e); }
            try { setupCorteHeaderFilterMenu(); } catch(e) { console.error('setupCorteHeaderFilterMenu error', e); }
            try { setupEnumeradoHeaderFilterMenu(); } catch(e) { console.error('setupEnumeradoHeaderFilterMenu error', e); }
            
            // Inicializar menú flotante desplegable
            initFloatingMenu();
        }

        function initFloatingMenu() {
            const toggleBtn = document.getElementById('floating-menu-toggle');
            const menuItems = document.getElementById('floating-menu-items');
            
            if (!toggleBtn || !menuItems) return;
            
            // Toggle del menú al hacer click en el botón
            toggleBtn.addEventListener('click', function() {
                menuItems.classList.toggle('active');
            });
            
            // Cerrar menú al hacer click fuera
            document.addEventListener('click', function(e) {
                if (!toggleBtn.contains(e.target) && !menuItems.contains(e.target)) {
                    menuItems.classList.remove('active');
                }
            });
            
            // Cerrar menú cuando se hace click en un item (después de navegar)
            const menuButtons = menuItems.querySelectorAll('.floating-menu-item');
            menuButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    menuItems.classList.remove('active');
                });
            });
        }

        window.loadDataCallback = function(jsonResponse) {
            try {
                if (!jsonResponse || !jsonResponse.table) throw new Error("Datos inválidos.");
                
                let headerRowIndex = -1;
                const rowsRaw = jsonResponse.table.rows.map(r => r.c.map(cell => (cell && cell.v !== null) ? cell.v : ""));
                
                const gvizHeaders = jsonResponse.table.cols.map(col => col.label || col.id);
                
                // DEBUG: Ver los headers que vienen del gviz
                console.log('=== DEBUG GVIZ DATA ===');
                console.log('gvizHeaders:', gvizHeaders);
                console.log('Total columnas:', gvizHeaders.length);
                console.log('Columna 20 (n.transfxpda):', gvizHeaders[20]);
                
                // DEBUG: Ver primera fila de ATHLETA
                rowsRaw.forEach((row, idx) => {
                    if (row[3] && row[3].toString().toUpperCase().includes('ATHLETA')) {
                        console.log('ATHLETA Fila', idx, '| Col 20 (n.transfxpda):', row[20]);
                    }
                });
                console.log('========================');
                
                if (gvizHeaders.includes("OP TELA")) {
                    rawData = [gvizHeaders, ...rowsRaw];
                } else {
                    for(let i=0; i<rowsRaw.length; i++) {
                        if (rowsRaw[i].includes("OP TELA")) {
                            headerRowIndex = i;
                            break;
                        }
                    }
                    if (headerRowIndex !== -1) {
                        rawData = rowsRaw.slice(headerRowIndex);
                    } else {
                        rawData = [gvizHeaders, ...rowsRaw];
                    }
                }
                
                // Limpieza de nombres de cabecera (trim)
                if (rawData.length > 0) {
                    rawData[0] = rawData[0].map(h => h ? h.toString().trim() : "");
                }

                mapColumns();
                renderAllViews();
                try {
                    const eqBtn = document.getElementById('eqcorte-btn');
                    if (eqBtn) eqBtn.style.display = (currentCorteFilter === 'X PROG') ? 'inline-flex' : 'none';
                } catch (e) {}
                document.getElementById('loader').style.display = 'none';
                // Forzar un re-render breve después de ocultar el loader
                try { setTimeout(function(){ try { renderArtes(); } catch(e) {} }, 200); } catch(e) {}
            } catch (error) {
                console.error(error);
                showError("Error procesando datos: " + error.message);
            }
        };

        function showError(msg) {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('error-screen').style.display = 'flex';
            document.getElementById('error-details').innerText = msg;
        }

        // Búsqueda de columnas insensible a mayúsculas/minúsculas
        function getColIndex(name) {
            if (!rawData || rawData.length === 0) return -1;
            const headers = rawData[0];
            const target = name.toLowerCase().trim();
            return headers.findIndex(h => h.toLowerCase().trim() === target);
        }

        function mapColumns() {
            if (!rawData || rawData.length === 0) return;
            // Reconstruimos colMap usando búsqueda flexible
            colMap = {};
            const knownColumns = [
                "HOD", "F.ING.COST", "CLIENTE", "OP TELA", "PARTIDA", 
                "OP", "CORTE", "COLOR", "KG GIRADOS", "PDS GIRADAS", "ARTÍCULO", 
                "NRO. MOLDE", "TIPO CERTIFICADO", "estado_bloqueo", "estado_rib", 
                "estado_lavada", "RUTA TELA", "ESTILO", "PRENDA", "F. GIRADO", "RIB",
                /* Posibles columnas adicionales para Corte */
                "EQUIPO CORTE", "EQUIPO_CORTE", "EQUIPO_CORTE", "equipo_corte",
                /* Nuevo nombre solicitado: STATUS_CORTE. Mantener variantes antiguas por compatibilidad */
                "STATUS_CORTE", "STATUS", "status", "ESTADO CORTE", "ESTADO_CORTE", "estado_corte",
                "ESTADO BLOQUES", "ESTADO_BLOQUES", "ESTADO_BLOQUES", "estado_bloques",
                "ESTADO COLL TAP", "ESTADO_COLL_TAP", "ESTADO_COLL_TAP", "estado_coll_tap",
                /* Columnas para Transfer */
                    "n.transfxpda", "N.TRANSFXPDA", "estado_transfer", "ESTADO_TRANSFER",
                    /* Columnas nuevas para Artes asignar */
                        "n.BDxpda", "n.BDxpda", "n.ESTAMPxpda", "n.ESTAMPxpda",
                    /* Estado de artes */
                        "estado_bordado", "ESTADO_BORDADO", "estado_estampado", "ESTADO_ESTAMPADO"
                , "tipo-transfer", "TIPO-TRANSFER", "tipo_transfer"
            ];
            
            knownColumns.forEach(col => {
                const idx = getColIndex(col);
                if (idx !== -1) colMap[col] = idx;
            });

            // Mapear "F. DESPACHO" de la hoja a "HOD" en el código
            try {
                const idxFDesp = findHeaderIndexCaseInsensitive('F. DESPACHO');
                if (idxFDesp !== -1) {
                    colMap['HOD'] = idxFDesp;  // Mapear HOD al índice de "F. DESPACHO"
                    colMap['F. DESPACHO'] = idxFDesp;  // Mantener también el nombre original por compatibilidad
                }
            } catch(e) { /* ignore if helper not yet available */ }

            // Asegurar mapeo robusto para la columna 'estado_corte_bloques' y variantes
            try {
                const idxEcb = findHeaderIndexCaseInsensitive('estado_corte_bloques');
                if (idxEcb !== -1) colMap['estado_corte_bloques'] = idxEcb;
                const idxEcb2 = findHeaderIndexCaseInsensitive('ESTADO_CORTE_BLOQUES');
                if (idxEcb2 !== -1) colMap['ESTADO_CORTE_BLOQUES'] = idxEcb2;
                const idxEcb3 = findHeaderIndexCaseInsensitive('ESTADO CORTE BLOQUES');
                if (idxEcb3 !== -1) colMap['ESTADO CORTE BLOQUES'] = idxEcb3;
            } catch(e) { /* ignore if helper not yet available */ }
            // Asegurar mapeo robusto para la columna 'n.ESTAMPxpda' y variantes
            try {
                const idxNest = findHeaderIndexCaseInsensitive('n.ESTAMPxpda');
                if (idxNest !== -1) colMap['n.ESTAMPxpda'] = idxNest;
                const idxNest2 = findHeaderIndexCaseInsensitive('N.ESTAMPXPDA');
                if (idxNest2 !== -1) colMap['N.ESTAMPXPDA'] = idxNest2;
                const idxNest3 = findHeaderIndexCaseInsensitive('n.ESTAMP xpda');
                if (idxNest3 !== -1) colMap['n.ESTAMP xpda'] = idxNest3;
            } catch(e) { /* ignore if helper not yet available */ }
        }

        function renderAllViews() {
            renderBloqueo();
            renderLavado();
            renderCorte();
            renderCorteBloques();
            renderEnumerado();
            renderTransfer();
            // Inicializar vistas y badges de Artes (Bordado/Estampado/Asignar)
            try { renderArtes(); } catch(e) {}
            try { if (typeof updateArtesBadges === 'function') updateArtesBadges(); } catch(e) {}
            renderHabilitado();
            updateCounters();
        }

        // Calcula y actualiza los badges (subtabs y padre) para Bordado y Estampado
        window.updateArtesBadges = function() {
            if (!rawData || rawData.length <= 1) return;
            let b_pdsX = 0, b_pdsProg = 0;
            let e_pdsX = 0, e_pdsProg = 0;
            const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');

            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                let ev = '';
                try {
                    if (idxEv !== -1 && row && row[idxEv] !== undefined) ev = row[idxEv];
                    else ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO ENUMERADO') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || ''; }
                const evNorm = (ev || '').toString().toUpperCase().trim();
                if (!(evNorm === 'OK PAQUETEO' || evNorm === 'OK ENM' || evNorm === 'OK S/ENM')) continue;

                // Bordado
                try {
                    const rawNbd = getVal(row, 'n.BDxpda') || getVal(row, 'N.BDXPDA') || getVal(row, 'n.BDxpda ') || '';
                    const nbdNorm = (rawNbd || '').toString().toUpperCase().trim();
                    if (nbdNorm.indexOf('NO LLEVA') === -1) {
                        if (nbdNorm === '' || ['1','2','3','4'].indexOf(nbdNorm) !== -1) {
                            let rawEstadoB = getVal(row, 'estado_bordado') || '';
                            let estadoBNorm = (rawEstadoB || '').toString().trim();
                            if (estadoBNorm === '') estadoBNorm = 'X PROG';
                            const pdsVal = parseFloat(getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || 0) || 0;
                            if (estadoBNorm.toUpperCase().indexOf('PROG') !== -1 && estadoBNorm.toUpperCase() !== 'X PROG') b_pdsProg += pdsVal;
                            else b_pdsX += pdsVal;
                        }
                    }
                } catch(e) {}

                // Estampado
                try {
                    const rawNest = getVal(row, 'n.ESTAMPxpda') || getVal(row, 'N.ESTAMPXPDA') || getVal(row, 'n.ESTAMP xpda') || '';
                    const nestNorm = (rawNest || '').toString().toUpperCase().trim();
                    if (nestNorm.indexOf('NO LLEVA') === -1) {
                        if (nestNorm === '' || ['1','2','3','4'].indexOf(nestNorm) !== -1) {
                            let rawEstadoE = getVal(row, 'estado_estampado') || '';
                            let estadoENorm = (rawEstadoE || '').toString().trim();
                            if (estadoENorm === '') estadoENorm = 'X PROG';
                            const pdsVal2 = parseFloat(getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || 0) || 0;
                            if (estadoENorm.toUpperCase().indexOf('PROG') !== -1 && estadoENorm.toUpperCase() !== 'X PROG') e_pdsProg += pdsVal2;
                            else e_pdsX += pdsVal2;
                        }
                    }
                } catch(e) {}
            }

            try { document.getElementById('artes-bordado-xprog-count').innerText = `[${formatThousands(b_pdsX||0,0)}pds]`; } catch(e){}
            try { document.getElementById('artes-bordado-prog-count').innerText = `[${formatThousands(b_pdsProg||0,0)}pds]`; } catch(e){}
            try { document.getElementById('artes-pds-bordado').innerText = `[${formatThousands((b_pdsX||0)+(b_pdsProg||0),0)}pds]`; } catch(e){}

            try { document.getElementById('artes-estampado-xprog-count').innerText = `[${formatThousands(e_pdsX||0,0)}pds]`; } catch(e){}
            try { document.getElementById('artes-estampado-prog-count').innerText = `[${formatThousands(e_pdsProg||0,0)}pds]`; } catch(e){}
            try { document.getElementById('artes-pds-estampado').innerText = `[${formatThousands((e_pdsX||0)+(e_pdsProg||0),0)}pds]`; } catch(e){}
        };
        
        function updateCounters() {
            let b_kgX = 0, b_pdsX = 0; 
            let b_kgP = 0, b_pdsP = 0; 
            let l_kgEnLav = 0, l_pdsEnLav = 0; 
            // Corte sub-tabs pds counters
            let corte_pds = {
                'X PROG': 0,
                'PROG 1T': 0,
                'PROG 2T': 0,
                'PROG 3T': 0
            };
            let corte_bloques_count = 0;
            
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const ruta = row[colMap["RUTA TELA"]];

                const kgVal = parseFloat(row[colMap["KG GIRADOS"]]) || 0;
                const pdsVal = parseFloat(row[colMap["PDS GIRADAS"]]) || 0;

                // Contadores de Bloqueo: solo se cuentan para filas cuya ruta sea LAVADA
                if (ruta === "LAVADA") {
                    const estBloq = row[colMap["estado_bloqueo"]] || "X PROG";
                    const estBloqNorm = (estBloq === "" || estBloq === undefined) ? "X PROG" : estBloq;

                    if (estBloqNorm === "X PROG") { b_kgX += kgVal; b_pdsX += pdsVal; }
                    else if (estBloqNorm === "PROG") { b_kgP += kgVal; b_pdsP += pdsVal; }
                }

                // Contador de Lavandería: incluir todas las filas cuyo estado_bloqueo sea OK,
                // independientemente de la columna RUTA TELA
                const estBloqAll = row[colMap["estado_bloqueo"]];
                const estBloqAllNorm = (!estBloqAll || estBloqAll === "") ? "X PROG" : estBloqAll;
                if (estBloqAllNorm === "OK") {
                    const estLav = row[colMap["estado_lavada"]];
                    const estLavNorm = (!estLav || estLav === "" || estLav === "EN LAV") ? "EN LAV" : estLav;
                    if (estLavNorm === "EN LAV") { l_kgEnLav += kgVal; l_pdsEnLav += pdsVal; }
                }

                // Contadores para sub-tabs de Corte: tomar STATUS / estado_corte (normalizar vacíos a 'X PROG')
                    const estadoCorteRaw = row[colMap["STATUS_CORTE"]] || row[colMap["STATUS"]] || row[colMap["status"]] || row[colMap["estado_corte"]] || row[colMap["ESTADO CORTE"]] || row[colMap["ESTADO_CORTE"]];
                    const estadoCorteNorm = (!estadoCorteRaw || estadoCorteRaw === "") ? 'X PROG' : String(estadoCorteRaw);
                    const isCorteOk = String(estadoCorteRaw).toUpperCase() === 'OK';
                    if (corte_pds.hasOwnProperty(estadoCorteNorm)) {
                        corte_pds[estadoCorteNorm] += pdsVal;
                    }
                    // contador específico para Corte Bloques: filas cuyo estado_bloques == 'OK CORTE'
                    try {
                        const estadoBloquesRaw = row[colMap["ESTADO BLOQUES"]] || row[colMap["ESTADO_BLOQUES"]] || row[colMap["estado_bloques"]] || '';
                        const estadoBloquesNorm = (estadoBloquesRaw || '').toString().toUpperCase().trim();
                        if (estadoBloquesNorm === 'OK CORTE') {
                            corte_bloques_count = (corte_bloques_count || 0) + 1;
                        }
                    } catch (e) { }
            }
            
            // Formatea números en miles para las prendas (pds)
            document.getElementById('kg-xprog').innerText = `[${b_kgX.toFixed(1)}kg - ${formatThousands(b_pdsX, 0)}pds]`;
            document.getElementById('kg-prog').innerText = `[${b_kgP.toFixed(1)}kg - ${formatThousands(b_pdsP, 0)}pds]`;
            const lblEnLav = document.getElementById('kg-enlav');
            if(lblEnLav) lblEnLav.innerText = `[${l_kgEnLav.toFixed(1)}kg - ${formatThousands(l_pdsEnLav, 0)}pds]`;

            // Actualizar badges de Corte
            const elX = document.getElementById('corte-pds-xprog');
            if (elX) elX.innerText = `[${formatThousands(corte_pds['X PROG'],0)}pds]`;
            const el1 = document.getElementById('corte-pds-1t');
            if (el1) el1.innerText = `[${formatThousands(corte_pds['PROG 1T'],0)}pds]`;
            const el2 = document.getElementById('corte-pds-2t');
            if (el2) el2.innerText = `[${formatThousands(corte_pds['PROG 2T'],0)}pds]`;
            const el3 = document.getElementById('corte-pds-3t');
            if (el3) el3.innerText = `[${formatThousands(corte_pds['PROG 3T'],0)}pds]`;

            // Contador para Transfer: sumar pds según estado_transfer
            let transfer_pds = {
                'X PROG': 0,
                'PROG': 0
            };
            let transferCount = 0;
            
            // Contador para Habilitado: filas con estado_enumerado = 'OK ENM' o 'OK S/ENM'
            let habilitadoCount = 0;
            // Mostrar contador para Corte Bloques (PROG 1T)
            try {
                const elCb = document.getElementById('count-corte-bloques');
                if (elCb) elCb.innerText = (typeof corte_bloques_count !== 'undefined') ? corte_bloques_count : 0;
            } catch (e) {}
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const ev = (row && (row[ findHeaderIndexCaseInsensitive('estado_enumerado') ])) || '';
                const evNorm = (ev || '').toString().toUpperCase().trim();

                // Contar Habilitado y Transfer: ambos usan el mismo criterio base
                if (evNorm === 'OK ENM' || evNorm === 'OK S/ENM' || evNorm === 'OK PAQUETEO') {
                    habilitadoCount++;

                    // Si n.transfxpda indica NO LLEVA no considerar la fila en el contador/badges de Transfer
                    const rawNTrans = getVal(row, 'n.transfxpda');
                    let nTransfValCheck = '';
                    if (rawNTrans !== undefined && rawNTrans !== null && rawNTrans.toString().trim() !== '') {
                        nTransfValCheck = rawNTrans.toString();
                    } else {
                        const clienteChk = (getVal(row, 'CLIENTE') || '').toString().trim();
                        const estiloChk = (getVal(row, 'ESTILO') || '').toString().trim();
                        const avgChk = avgTransfByClienteEstilo(clienteChk, estiloChk);
                        nTransfValCheck = (avgChk !== null) ? avgChk : '';
                    }
                    nTransfValCheck = nTransfValCheck.toUpperCase().trim();
                    if (nTransfValCheck === 'NO LLEVA') {
                        // skip counting for Transfer
                        continue;
                    }

                    transferCount++;

                    // Sumar pds para Transfer según estado_transfer
                    const estadoTransfer = (row && (row[ findHeaderIndexCaseInsensitive('estado_transfer') ])) || 'X PROG';
                    const estadoTransferNorm = (!estadoTransfer || estadoTransfer === '') ? 'X PROG' : estadoTransfer;
                    if (transfer_pds.hasOwnProperty(estadoTransferNorm)) {
                        const pds = parseFloat(row[colMap["PDS GIRADAS"]]) || 0;
                        transfer_pds[estadoTransferNorm] += pds;
                    }
                }
            }
            const elH = document.getElementById('count-habilitado');
            if (elH) elH.innerText = habilitadoCount;
            
            // Actualizar contador y badges de Transfer
            const elT = document.getElementById('count-transfer');
            if (elT) elT.innerText = transferCount;
            const elTX = document.getElementById('transfer-pds-xprog');
            if (elTX) elTX.innerText = `[${formatThousands(transfer_pds['X PROG'],0)}pds]`;
            const elTP = document.getElementById('transfer-pds-prog');
            if (elTP) elTP.innerText = `[${formatThousands(transfer_pds['PROG'],0)}pds]`;
        }

        // helper para buscar índice de encabezado de forma case-insensitive y sin símbolos
        function findHeaderIndexCaseInsensitive(name) {
            if (!rawData || rawData.length === 0) return -1;
            const headers = rawData[0];
            const norm = s => String(s || '').toLowerCase().replace(/[^a-z0-9]/g, '');
            const target = norm(name);
            for (let i = 0; i < headers.length; i++) {
                if (norm(headers[i]) === target) return i;
            }
                    return -1;
                }

                // Calcula promedio de n.transfxpda para un par CLIENTE+ESTILO
                function avgTransfByClienteEstilo(cliente, estilo) {
                    if (!cliente && !estilo) return null;
                    const vals = [];
                    let hasNoLleva = false;
                    
                    for (let i = 1; i < rawData.length; i++) {
                        const r = rawData[i];
                        const c = normalizeClientForTransfer(getVal(r, 'CLIENTE') || '');
                        const e = (getVal(r, 'ESTILO') || '').toString().trim();
                        if (c === cliente && e === estilo) {
                            // Obtener valor usando getVal (igual que tipo-transfer)
                            const v = (getVal(r, 'n.transfxpda') || getVal(r, 'N.TRANSFXPDA') || getVal(r, 'ntransfxpda') || '').toString().trim();
                            
                            if (!v) continue;
                            const sUpper = v.toUpperCase();
                            // Detectar "NO LLEVA" con variaciones
                            if (sUpper === 'NO LLEVA' || sUpper.includes('NO LLEVA')) { 
                                hasNoLleva = true; 
                                continue; 
                            }
                            if (sUpper === 'LLEVA?' || sUpper === 'LLEVA') continue;
                            const n = parseFloat(v);
                            if (!isNaN(n)) vals.push(n);
                        }
                    }
                    
                    // Prioridad: si hay "NO LLEVA", retornarlo (indica que el estilo no necesita transfer)
                    if (hasNoLleva && vals.length === 0) return 'NO LLEVA';
                    if (vals.length > 0) {
                        const sum = vals.reduce((a,b) => a + b, 0);
                        const avg = sum / vals.length;
                        return Math.round(avg).toString();
                    }
                    if (hasNoLleva) return 'NO LLEVA';
                    return null;
                }

        // --- HELPER PARA CONVERTIR FECHA A FORMATO YYYY-MM-DD PARA DATE PICKER ---
        function convertToDateInputFormat(rawValue) {
            if (!rawValue || rawValue === '') return '';
            try {
                // Si es número (Excel serial date)
                if (typeof rawValue === 'number' && rawValue > 30000) {
                    const d = new Date(Math.round((rawValue - 25569) * 86400 * 1000));
                    const year = d.getFullYear();
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const day = String(d.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                }
                // Si es string con formato Date(yyyy,mm,dd)
                if (typeof rawValue === 'string') {
                    const m = rawValue.match(/Date\((\d+),(\d+),(\d+)\)/);
                    if (m) {
                        const year = m[1];
                        const month = String(parseInt(m[2]) + 1).padStart(2, '0');
                        const day = String(m[3]).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    // Intentar parsear como fecha ISO o estándar
                    const parsed = new Date(rawValue);
                    if (!isNaN(parsed.getTime())) {
                        const year = parsed.getFullYear();
                        const month = String(parsed.getMonth() + 1).padStart(2, '0');
                        const day = String(parsed.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                }
            } catch (e) { }
            return '';
        }

        // Formatea valor YYYY-MM-DD a 'DD/Mon/YY' para mostrar al lado del picker
        function formatDateShortFromInput(val) {
            if (!val) return '';
            try {
                const mesesEs = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'];
                const parts = val.split('-');
                if (parts.length !== 3) return '';
                const year = parts[0];
                const month = parseInt(parts[1],10) - 1;
                const day = parts[2];
                const yearShort = year.slice(-2);
                const mon = mesesEs[month] || '';
                return `${day}/${mon}/${yearShort}`;
            } catch (e) { return ''; }
        }

        function updateShortYearDisplay(inputEl) {
            if (!inputEl) return;
            // buscar span junto al input
            let span = inputEl.nextSibling;
            // skip text nodes
            while (span && span.nodeType !== 1) span = span.nextSibling;
            if (!span || !span.classList || !span.classList.contains('date-yy')) {
                // crear span
                span = document.createElement('span');
                span.className = 'date-yy';
                inputEl.parentNode.insertBefore(span, inputEl.nextSibling);
                
                // Hacer que el span abra el selector de fecha al hacer click
                span.onclick = function(e) {
                    e.stopPropagation();
                    inputEl.showPicker ? inputEl.showPicker() : inputEl.click();
                };
            }
            const formatted = formatDateShortFromInput(inputEl.value || '');
            span.innerText = formatted || 'mm/dd/aaaa';
        }

        // Función auxiliar para inicializar todos los eventos de fecha en la tabla
        function initializeDateInputs() {
            setTimeout(() => {
                document.querySelectorAll('input.short-year').forEach(inputEl => {
                    const spanEl = inputEl.nextElementSibling;
                    if (spanEl && spanEl.classList.contains('date-yy')) {
                        spanEl.onclick = function(e) {
                            e.stopPropagation();
                            inputEl.showPicker ? inputEl.showPicker() : inputEl.click();
                        };
                    }
                });
            }, 0);
        }

        function handleDateChange(inputEl, rowIndex, colName) {
            try { updateShortYearDisplay(inputEl); } catch(e){}
            // Convertir fecha ISO (YYYY-MM-DD) a formato dd/mmm/yy para enviar al Sheet
            let valueToSend = inputEl.value;
            if (valueToSend && valueToSend.includes('-')) {
                try {
                    const mesesEs = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'];
                    const parts = valueToSend.split('-');
                    if (parts.length === 3) {
                        const year = parts[0];
                        const month = parseInt(parts[1],10) - 1; // 0-11
                        const day = parts[2];
                        const yearShort = year.slice(-2);
                        const mon = mesesEs[month] || '';
                        // Formato: dd/mmm/yy (ejemplo: 16/Ene/26)
                        valueToSend = `${day}/${mon}/${yearShort}`;
                        
                        // Actualizar inmediatamente rawData con el valor formateado
                        const writeIdx = colMap[colName];
                        if (writeIdx !== undefined && writeIdx !== -1 && rawData[rowIndex]) {
                            rawData[rowIndex][writeIdx] = valueToSend;
                        }
                    }
                } catch(e) { console.error('Error convirtiendo fecha:', e); }
            }
            updateRow(rowIndex, colName, valueToSend, inputEl);
        }

        // --- HELPER PARA CREAR CELDA "P" CON CUADRO DE TEXTO ---
        function createPrioridadCell(rowIndex, row) {
            // Obtener valor actual de la columna P
            let pValue = '';
            try {
                const idxP = findHeaderIndexCaseInsensitive('P');
                if (idxP !== -1 && row[idxP] !== undefined && row[idxP] !== null) {
                    pValue = String(row[idxP]).trim();
                }
            } catch (e) {}
            
            return `<td class="p-cell">
                <input type="text" class="prioridad-input" value="${pValue}" 
                       onchange="updatePrioridad(${rowIndex}, this.value, this)" 
                       onblur="updatePrioridad(${rowIndex}, this.value, this)">
            </td>`;
        }

        // --- FUNCIÓN PARA ACTUALIZAR PRIORIDAD Y PROPAGAR A MISMO OP-PTDA ---
        function updatePrioridad(rowIndex, value, selectElement) {
            // Determinar vista actual
            const isBloqueoView = document.getElementById('view-bloqueo') && document.getElementById('view-bloqueo').classList.contains('active');
            const isLavadoView = document.getElementById('view-lavado') && document.getElementById('view-lavado').classList.contains('active');
            const isCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
            
            // Solo propagar en las vistas especificadas
            const shouldPropagate = isBloqueoView || isLavadoView || isCorteView;
            
            if (!shouldPropagate) {
                // Para otras vistas, solo actualizar la fila actual
                updateRow(rowIndex, 'P', value, selectElement);
                return;
            }
            
            // Obtener OP-PTDA de la fila actual
            const row = rawData[rowIndex];
            if (!row) return;
            
            const opTela = String(row[colMap["OP TELA"]] || "").trim().toLowerCase();
            const partida = String(row[colMap["PARTIDA"]] || "").trim().toLowerCase();
            const currentOpPtda = opTela + "-" + partida;
            
            // Encontrar índice de columna P
            const idxP = findHeaderIndexCaseInsensitive('P');
            if (idxP === -1) return;
            
            // 1. PRIMERO: Actualizar INMEDIATAMENTE todas las filas en rawData (UI local)
            const rowsToUpdate = [];
            for (let i = 1; i < rawData.length; i++) {
                const r = rawData[i];
                const opT = String(r[colMap["OP TELA"]] || "").trim().toLowerCase();
                const part = String(r[colMap["PARTIDA"]] || "").trim().toLowerCase();
                const opPtda = opT + "-" + part;
                
                if (opPtda === currentOpPtda) {
                    rawData[i][idxP] = value;
                    rowsToUpdate.push(i);
                }
            }
            
            // 2. SEGUNDO: Re-renderizar INMEDIATAMENTE para mostrar el cambio visual
            updateCounters();
            if (isBloqueoView) renderBloqueo();
            else if (isLavadoView) renderLavado();
            else if (isCorteView) renderCorte();
            
            // 3. TERCERO: Guardar en el backend de forma ASÍNCRONA (sin bloquear UI)
            // Enviar todas las actualizaciones sin esperar respuesta
            rowsToUpdate.forEach(i => {
                fetch(WEB_APP_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: JSON.stringify({
                        action: "update",
                        row: i,
                        colName: "P",
                        value: value
                    })
                }).catch(e => console.error('Error guardando P fila', i, e));
            });
        }

        // --- LÓGICA DE ORDENAMIENTO ---
        function sortBloqueoData(indices) {
            return indices.sort((a, b) => {
                const rowA = rawData[a];
                const rowB = rawData[b];
                
                // 1. PRIMERO ordenar por OP-PTDA para agrupar filas con mismo OP-PTDA juntas
                const opTelaA = String(rowA[colMap["OP TELA"]] || "").trim();
                const partidaA = String(rowA[colMap["PARTIDA"]] || "").trim();
                const opPtdaA = (opTelaA + "-" + partidaA).toLowerCase();

                const opTelaB = String(rowB[colMap["OP TELA"]] || "").trim();
                const partidaB = String(rowB[colMap["PARTIDA"]] || "").trim();
                const opPtdaB = (opTelaB + "-" + partidaB).toLowerCase();
                
                const opPtdaCmp = opPtdaA.localeCompare(opPtdaB, undefined, { numeric: true, sensitivity: 'base' });
                if (opPtdaCmp !== 0) return opPtdaCmp;
                
                // 2. Dentro del mismo OP-PTDA, ordenar por columna P (valores numéricos primero, luego vacíos)
                const idxP = findHeaderIndexCaseInsensitive('P');
                let pA = '';
                let pB = '';
                if (idxP !== -1) {
                    pA = String(rowA[idxP] || '').trim();
                    pB = String(rowB[idxP] || '').trim();
                }
                
                // Convertir a número para comparación (vacío = Infinity para que vaya al final)
                const pNumA = pA === '' ? Infinity : parseInt(pA) || Infinity;
                const pNumB = pB === '' ? Infinity : parseInt(pB) || Infinity;
                
                if (pNumA !== pNumB) return pNumA - pNumB;
                
                // 3. Finalmente ordenar por fecha de despacho dentro del mismo grupo OP-PTDA+P (más reciente primero)
                const dateA = rowA[colMap["HOD"]] || 0;
                const dateB = rowB[colMap["HOD"]] || 0;
                if (dateA !== dateB) return dateB - dateA;
                
                return 0;
            });
        }

        function sortCorteData(indices) {
            return indices.sort((a, b) => {
                const rowA = rawData[a];
                const rowB = rawData[b];
                
                // 1. PRIMERO ordenar por OP-PTDA para agrupar filas con mismo OP-PTDA juntas
                const opTelaA = String(rowA[colMap["OP TELA"]] || "").trim();
                const partidaA = String(rowA[colMap["PARTIDA"]] || "").trim();
                const opPtdaA = (opTelaA + "-" + partidaA).toLowerCase();

                const opTelaB = String(rowB[colMap["OP TELA"]] || "").trim();
                const partidaB = String(rowB[colMap["PARTIDA"]] || "").trim();
                const opPtdaB = (opTelaB + "-" + partidaB).toLowerCase();
                
                const opPtdaCmp = opPtdaA.localeCompare(opPtdaB, undefined, { numeric: true, sensitivity: 'base' });
                if (opPtdaCmp !== 0) return opPtdaCmp;
                
                // 2. Dentro del mismo OP-PTDA, ordenar por columna P (valores numéricos primero, luego vacíos)
                const idxP = findHeaderIndexCaseInsensitive('P');
                let pA = '';
                let pB = '';
                if (idxP !== -1) {
                    pA = String(rowA[idxP] || '').trim();
                    pB = String(rowB[idxP] || '').trim();
                }
                
                // Convertir a número para comparación (vacío = Infinity para que vaya al final)
                const pNumA = pA === '' ? Infinity : parseInt(pA) || Infinity;
                const pNumB = pB === '' ? Infinity : parseInt(pB) || Infinity;
                
                if (pNumA !== pNumB) return pNumA - pNumB;
                
                // 3. Finalmente ordenar por fecha de despacho dentro del mismo grupo OP-PTDA+P (más reciente primero)
                const dateA = rowA[colMap["HOD"]] || 0;
                const dateB = rowB[colMap["HOD"]] || 0;
                if (dateA !== dateB) return dateB - dateA;
                
                return 0;
            });
        }

        function renderBloqueo() {
            const tbody = document.getElementById('tbody-bloqueo');
            tbody.innerHTML = "";
            let count = 0;
            
            // Mostrar/ocultar columna P según el sub-tab activo
            const showPColumn = (currentBloqueoFilter === 'PROG');
            try {
                const thP = document.getElementById('th-bloqueo-p');
                if (thP) thP.style.display = showPColumn ? '' : 'none';
            } catch (e) {}
            
            let validIndices = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const ruta = row[colMap["RUTA TELA"]];
                if (ruta !== "LAVADA") continue;

                const estadoBloq = row[colMap["estado_bloqueo"]] || "X PROG";
                const estadoBloqNorm = (estadoBloq === "" || estadoBloq === undefined) ? "X PROG" : estadoBloq;

                if (estadoBloqNorm === currentBloqueoFilter) {
                    // Si estamos en 'Por Programar' (X PROG), excluir filas cuyo CORTE (parte entera antes de '-')
                    // sea numérico y mayor o igual a 9000
                    try {
                        if (currentBloqueoFilter === 'X PROG') {
                            const corteRaw = String(row[colMap["CORTE"]] || '').trim();
                            const corteBase = parseInt((corteRaw.split('-')[0] || '').trim());
                            if (!isNaN(corteBase) && corteBase >= 9000) {
                                continue; // omitir esta fila en X PROG
                            }
                        }
                    } catch (e) { /* ignore parsing issues */ }
                    validIndices.push(i);
                }
            }

            validIndices = sortBloqueoData(validIndices);

            // Aplicar filtro de encabezado si existe
            try {
                if (bloqueoHeaderFilter && bloqueoHeaderFilter.field && bloqueoHeaderFilter.value !== undefined && bloqueoHeaderFilter.value !== null && String(bloqueoHeaderFilter.value).trim() !== '') {
                    const f = bloqueoHeaderFilter.field;
                    const v = String(bloqueoHeaderFilter.value).toUpperCase().trim();
                    validIndices = validIndices.filter(idx => {
                        const r = rawData[idx] || [];
                        try {
                            if (f === 'HOD') {
                                const cell = formatValue(getVal(r, 'HOD'), 'date') || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'F.ING.COST') {
                                const cell = formatValue(getVal(r, 'F.ING.COST'), 'date') || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'CLIENTE') {
                                const cell = normalizeClientName(getVal(r, 'CLIENTE')) || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'OP-PTDA') {
                                const opTela = String(getVal(r, 'OP TELA') || '').trim();
                                const partida = String(getVal(r, 'PARTIDA') || '').trim();
                                const cell = (opTela + '-' + partida) || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'OC') {
                                const op = String(getVal(r, 'OP') || '').trim();
                                const corte = String(getVal(r, 'CORTE') || '').trim();
                                const cell = (op + '-' + corte) || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'COLOR') {
                                const cell = String(getVal(r, 'COLOR') || '') || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                        } catch (e) { return false; }
                        return false;
                    });
                }
            } catch (e) { console.error('Error applying bloqueoHeaderFilter', e); }

            let lastOpPtda = null;
            let currentGroup = 'a'; 

            validIndices.forEach(i => {
                count++;
                const row = rawData[i];
                
                // --- AGRUPAMIENTO SIN LIMPIEZA ---
                const opTela = String(row[colMap["OP TELA"]] || "").trim();
                const partida = String(row[colMap["PARTIDA"]] || "").trim();
                const currentOpPtda = opTela + "-" + partida;
                
                if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                    currentGroup = (currentGroup === 'a') ? 'b' : 'a';
                }
                lastOpPtda = currentOpPtda;

                const tr = createRow(row, i, "bloqueo", currentGroup);
                
                // Si estamos en sub-tab PROG, agregar celda P al inicio
                if (showPColumn) {
                    const pCell = document.createElement('td');
                    pCell.innerHTML = createPrioridadCell(i, row).replace(/<td.*?>|<\/td>/g, '');
                    tr.insertBefore(pCell, tr.firstChild);
                }
                
                // Si P = 1, aplicar color rojo claro
                const idxP = findHeaderIndexCaseInsensitive('P');
                if (idxP !== -1) {
                    const pValue = String(row[idxP] || '').trim();
                    if (pValue === '1') {
                        tr.classList.add('priority-1');
                    }
                }
                
                tbody.appendChild(tr);
            });
            
            document.getElementById('count-bloqueo').innerText = count;
            
            // Inicializar eventos de los selectores de fecha
            initializeDateInputs();
            
            // Inicializar menú contextual de filtro en encabezados (solo X PROG)
            if (currentBloqueoFilter === 'X PROG') {
                initializeBloqueoHeaderContextMenus();
            }
        }

        // Configura menú contextual en el encabezado de la vista Bloqueo
        function setupBloqueoHeaderFilterMenu() {
            const view = document.getElementById('view-bloqueo');
            if (!view) return;
            const thead = view.querySelector('thead');
            if (!thead) return;

            // Crear contenedor de menú si no existe
            let menu = document.getElementById('bloq-header-filter-menu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'bloq-header-filter-menu';
                menu.style.position = 'absolute';
                menu.style.zIndex = 9999;
                menu.style.background = '#fff';
                menu.style.border = '1px solid #ccc';
                menu.style.padding = '6px';
                menu.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
                menu.style.display = 'none';
                document.body.appendChild(menu);
            }

            const fields = ['HOD','F.ING.COST','CLIENTE','OP-PTDA','OC','COLOR'];

            const buildMenu = () => {
                menu.innerHTML = '';
                const title = document.createElement('div');
                title.style.fontWeight = '600';
                title.style.marginBottom = '6px';
                title.innerText = 'Filtrar por (Bloqueo)';
                menu.appendChild(title);

                // helper: obtener valores únicos de una columna (formateados para fechas)
                const getUniqueValues = (colName, formatAsDate) => {
                    const map = new Map(); // display -> timestamp
                    const mesesEs = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'];

                    const parseToTimestamp = (raw) => {
                        if (raw === undefined || raw === null || raw === '') return NaN;
                        // number (Excel serial)
                        if (typeof raw === 'number' && raw > 30000) {
                            const d = new Date(Math.round((raw - 25569) * 86400 * 1000));
                            return d.getTime();
                        }
                        if (typeof raw === 'string') {
                            const s = raw.trim();
                            // Date(yyyy,mm,dd)
                            const m = s.match(/Date\((\d+),(\d+),(\d+)\)/);
                            if (m) {
                                const y = parseInt(m[1],10);
                                const mo = parseInt(m[2],10);
                                const day = parseInt(m[3],10);
                                return new Date(y, mo, day).getTime();
                            }
                            // Formato dd/Mon/yy o dd/Mon/yyyy (Mon en español abreviado como Ene,Feb,...)
                            const m2 = s.match(/(\d{1,2})\/([A-Za-z]{3})\/(\d{2,4})/);
                            if (m2) {
                                const day = parseInt(m2[1],10);
                                const monAbbr = m2[2].slice(0,3);
                                const yearRaw = m2[3];
                                const monthIdx = mesesEs.findIndex(x => x.toLowerCase() === monAbbr.toLowerCase());
                                let year = parseInt(yearRaw,10);
                                if (yearRaw.length === 2) {
                                    year = 2000 + year;
                                }
                                if (monthIdx !== -1) return new Date(year, monthIdx, day).getTime();
                            }
                            // Try ISO parse
                            const tryIso = Date.parse(s);
                            if (!isNaN(tryIso)) return tryIso;
                        }
                        return NaN;
                    };

                    try {
                        for (let i = 1; i < rawData.length; i++) {
                            const row = rawData[i];
                            if (!row) continue;
                            const rawVal = getVal(row, colName);
                            const display = formatAsDate ? String(formatValue(rawVal, 'date')) : String(rawVal);
                            if (display === 'undefined' || display === 'null' || String(display).trim() === '') continue;
                            if (!map.has(display)) {
                                const ts = parseToTimestamp(rawVal);
                                map.set(display, isNaN(ts) ? null : ts);
                            }
                        }
                    } catch (e) { /* ignore */ }

                    // Convert map to array and sort by timestamp (nulls last), then by display
                    const arr = Array.from(map.entries()).map(([display, ts]) => ({ display, ts }));
                    arr.sort((a,b) => {
                        if (a.ts === null && b.ts === null) return a.display.localeCompare(b.display);
                        if (a.ts === null) return 1;
                        if (b.ts === null) return -1;
                        return a.ts - b.ts;
                    });
                    return arr.map(x => x.display);
                };

                fields.forEach(f => {
                    const btn = document.createElement('div');
                    btn.style.cursor = 'pointer';
                    btn.style.padding = '4px 6px';
                    btn.innerText = f;
                    btn.onclick = () => {
                        // Si es campo fecha, mostrar lista de fechas únicas en lugar de prompt
                        if (f === 'HOD' || f === 'F.ING.COST') {
                            const colName = (f === 'HOD') ? 'HOD' : 'F.ING.COST';
                            const vals = getUniqueValues(colName, true);
                            // construir sub-lista
                            if (vals.length === 0) {
                                alert('No hay valores de fecha disponibles en la columna.');
                                hideMenu();
                                return;
                            }
                            menu.innerHTML = '';
                            const back = document.createElement('div');
                            back.style.cursor = 'pointer';
                            back.style.padding = '4px 6px';
                            back.style.fontWeight = '600';
                            back.innerText = '< Volver';
                            back.onclick = () => { buildMenu(); };
                            menu.appendChild(back);

                            const list = document.createElement('div');
                            list.style.maxHeight = '220px';
                            list.style.overflow = 'auto';
                            list.style.marginTop = '6px';
                            vals.forEach(v => {
                                const item = document.createElement('div');
                                item.style.cursor = 'pointer';
                                item.style.padding = '4px 6px';
                                item.innerText = v;
                                item.onclick = () => {
                                    bloqueoHeaderFilter = { field: f, value: v };
                                    renderBloqueo();
                                    hideMenu();
                                };
                                list.appendChild(item);
                            });
                            menu.appendChild(list);
                            return;
                        }

                        // campos no fecha: usar prompt simple
                        const val = prompt(`Valor para filtrar ${f}:`, '');
                        if (val !== null) {
                            bloqueoHeaderFilter = { field: f, value: val };
                            renderBloqueo();
                        }
                        hideMenu();
                    };
                    menu.appendChild(btn);
                });

                const clear = document.createElement('div');
                clear.style.cursor = 'pointer';
                clear.style.padding = '6px 4px';
                clear.style.borderTop = '1px solid #eee';
                clear.style.marginTop = '6px';
                clear.innerText = 'Limpiar filtro';
                clear.onclick = () => {
                    bloqueoHeaderFilter = null;
                    renderBloqueo();
                    hideMenu();
                };
                menu.appendChild(clear);
            };

            const hideMenu = () => { menu.style.display = 'none'; };

            buildMenu();

            // Mostrar menú al hacer click derecho en la fila de encabezado
            thead.addEventListener('contextmenu', function(e) {
                // Solo en sub-tab 'Por Programar'
                const btnX = document.getElementById('btn-xprog');
                const isXProgActive = btnX && btnX.classList.contains('active');
                if (!isXProgActive) return; // no mostrar menú si no está en Por Programar

                e.preventDefault();
                menu.style.left = (e.pageX + 2) + 'px';
                menu.style.top = (e.pageY + 2) + 'px';
                menu.style.display = 'block';
            });

            // Ocultar al click fuera
            document.addEventListener('click', function(e) {
                if (!menu) return;
                if (e.target && menu.contains(e.target)) return;
                hideMenu();
            });
        }

        // Configura menú contextual en el encabezado de la vista Corte (solo X PROG)
        function setupCorteHeaderFilterMenu() {
            const view = document.getElementById('view-corte');
            if (!view) return;
            const thead = view.querySelector('thead');
            if (!thead) return;

            let menu = document.getElementById('corte-header-filter-menu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'corte-header-filter-menu';
                menu.style.position = 'absolute';
                menu.style.zIndex = 9999;
                menu.style.background = '#fff';
                menu.style.border = '1px solid #ccc';
                menu.style.padding = '6px';
                menu.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
                menu.style.display = 'none';
                document.body.appendChild(menu);
            }

            const fields = ['HOD','F.ING.COST','CLIENTE','OP-PTDA','OC','COLOR'];

            const buildMenu = () => {
                menu.innerHTML = '';
                const title = document.createElement('div');
                title.style.fontWeight = '600';
                title.style.marginBottom = '6px';
                title.innerText = 'Filtrar por (Corte)';
                menu.appendChild(title);

                const getUniqueValues = (colName, formatAsDate) => {
                    const map = new Map();
                    const mesesEs = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'];

                    const parseToTimestamp = (raw) => {
                        if (raw === undefined || raw === null || raw === '') return NaN;
                        if (typeof raw === 'number' && raw > 30000) {
                            const d = new Date(Math.round((raw - 25569) * 86400 * 1000));
                            return d.getTime();
                        }
                        if (typeof raw === 'string') {
                            const s = raw.trim();
                            const m = s.match(/Date\((\d+),(\d+),(\d+)\)/);
                            if (m) {
                                const y = parseInt(m[1],10);
                                const mo = parseInt(m[2],10);
                                const day = parseInt(m[3],10);
                                return new Date(y, mo, day).getTime();
                            }
                            const m2 = s.match(/(\d{1,2})\/([A-Za-z]{3})\/(\d{2,4})/);
                            if (m2) {
                                const day = parseInt(m2[1],10);
                                const monAbbr = m2[2].slice(0,3);
                                const yearRaw = m2[3];
                                const monthIdx = mesesEs.findIndex(x => x.toLowerCase() === monAbbr.toLowerCase());
                                let year = parseInt(yearRaw,10);
                                if (yearRaw.length === 2) year = 2000 + year;
                                if (monthIdx !== -1) return new Date(year, monthIdx, day).getTime();
                            }
                            const tryIso = Date.parse(s);
                            if (!isNaN(tryIso)) return tryIso;
                        }
                        return NaN;
                    };

                    try {
                        for (let i = 1; i < rawData.length; i++) {
                            const row = rawData[i];
                            if (!row) continue;
                            const rawVal = getVal(row, colName);
                            const display = formatAsDate ? String(formatValue(rawVal, 'date')) : String(rawVal);
                            if (display === 'undefined' || display === 'null' || String(display).trim() === '') continue;
                            if (!map.has(display)) {
                                const ts = parseToTimestamp(rawVal);
                                map.set(display, isNaN(ts) ? null : ts);
                            }
                        }
                    } catch (e) { }

                    const arr = Array.from(map.entries()).map(([display, ts]) => ({ display, ts }));
                    arr.sort((a,b) => {
                        if (a.ts === null && b.ts === null) return a.display.localeCompare(b.display);
                        if (a.ts === null) return 1;
                        if (b.ts === null) return -1;
                        return a.ts - b.ts;
                    });
                    return arr.map(x => x.display);
                };

                fields.forEach(f => {
                    const btn = document.createElement('div');
                    btn.style.cursor = 'pointer';
                    btn.style.padding = '4px 6px';
                    btn.innerText = f;
                    btn.onclick = () => {
                        if (f === 'HOD' || f === 'F.ING.COST') {
                            const colName = (f === 'HOD') ? 'HOD' : 'F.ING.COST';
                            const vals = getUniqueValues(colName, true);
                            if (vals.length === 0) { alert('No hay valores de fecha disponibles en la columna.'); hideMenu(); return; }
                            menu.innerHTML = '';
                            const back = document.createElement('div');
                            back.style.cursor = 'pointer'; back.style.padding = '4px 6px'; back.style.fontWeight = '600'; back.innerText = '< Volver';
                            back.onclick = () => { buildMenu(); };
                            menu.appendChild(back);

                            const list = document.createElement('div');
                            list.style.maxHeight = '220px'; list.style.overflow = 'auto'; list.style.marginTop = '6px';
                            vals.forEach(v => {
                                const item = document.createElement('div');
                                item.style.cursor = 'pointer'; item.style.padding = '4px 6px'; item.innerText = v;
                                item.onclick = () => { corteHeaderFilter = { field: f, value: v }; renderCorte(); hideMenu(); };
                                list.appendChild(item);
                            });
                            menu.appendChild(list);
                            return;
                        }

                        const val = prompt(`Valor para filtrar ${f}:`, '');
                        if (val !== null) { corteHeaderFilter = { field: f, value: val }; renderCorte(); }
                        hideMenu();
                    };
                    menu.appendChild(btn);
                });

                const clear = document.createElement('div');
                clear.style.cursor = 'pointer'; clear.style.padding = '6px 4px'; clear.style.borderTop = '1px solid #eee'; clear.style.marginTop = '6px';
                clear.innerText = 'Limpiar filtro';
                clear.onclick = () => { corteHeaderFilter = null; renderCorte(); hideMenu(); };
                menu.appendChild(clear);
            };

            const hideMenu = () => { menu.style.display = 'none'; };

            buildMenu();

            thead.addEventListener('contextmenu', function(e) {
                const btnX = document.getElementById('corte-btn-xprog');
                const isXProgActive = btnX && btnX.classList.contains('active');
                if (!isXProgActive) return;
                e.preventDefault();
                menu.style.left = (e.pageX + 2) + 'px';
                menu.style.top = (e.pageY + 2) + 'px';
                menu.style.display = 'block';
            });

            document.addEventListener('click', function(e) {
                if (!menu) return;
                if (e.target && menu.contains(e.target)) return;
                hideMenu();
            });
        }

        // Configura menú contextual en el encabezado de la vista Enumerado (solo Por enumerar)
        function setupEnumeradoHeaderFilterMenu() {
            const view = document.getElementById('view-enumerado');
            if (!view) return;
            const thead = view.querySelector('thead');
            if (!thead) return;

            let menu = document.getElementById('enumerado-header-filter-menu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'enumerado-header-filter-menu';
                menu.style.position = 'absolute';
                menu.style.zIndex = 9999;
                menu.style.background = '#fff';
                menu.style.border = '1px solid #ccc';
                menu.style.padding = '6px';
                menu.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
                menu.style.display = 'none';
                document.body.appendChild(menu);
            }

            const fields = ['HOD','F.ING.COST','CLIENTE','OP-PTDA','OC','COLOR'];

            const buildMenu = () => {
                menu.innerHTML = '';
                const title = document.createElement('div');
                title.style.fontWeight = '600';
                title.style.marginBottom = '6px';
                title.innerText = 'Filtrar por (Enumerado)';
                menu.appendChild(title);

                const getUniqueValues = (colName, formatAsDate) => {
                    const map = new Map();
                    const mesesEs = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'];

                    const parseToTimestamp = (raw) => {
                        if (raw === undefined || raw === null || raw === '') return NaN;
                        if (typeof raw === 'number' && raw > 30000) {
                            const d = new Date(Math.round((raw - 25569) * 86400 * 1000));
                            return d.getTime();
                        }
                        if (typeof raw === 'string') {
                            const s = raw.trim();
                            const m = s.match(/Date\((\d+),(\d+),(\d+)\)/);
                            if (m) return new Date(parseInt(m[1],10), parseInt(m[2],10), parseInt(m[3],10)).getTime();
                            const m2 = s.match(/(\d{1,2})\/([A-Za-z]{3})\/(\d{2,4})/);
                            if (m2) {
                                const day = parseInt(m2[1],10);
                                const monAbbr = m2[2].slice(0,3);
                                const yearRaw = m2[3];
                                const monthIdx = mesesEs.findIndex(x => x.toLowerCase() === monAbbr.toLowerCase());
                                let year = parseInt(yearRaw,10);
                                if (yearRaw.length === 2) year = 2000 + year;
                                if (monthIdx !== -1) return new Date(year, monthIdx, day).getTime();
                            }
                            const tryIso = Date.parse(s);
                            if (!isNaN(tryIso)) return tryIso;
                        }
                        return NaN;
                    };

                    try {
                        for (let i = 1; i < rawData.length; i++) {
                            const row = rawData[i];
                            if (!row) continue;
                            const rawVal = getVal(row, colName);
                            const display = formatAsDate ? String(formatValue(rawVal, 'date')) : String(rawVal);
                            if (display === 'undefined' || display === 'null' || String(display).trim() === '') continue;
                            if (!map.has(display)) {
                                const ts = parseToTimestamp(rawVal);
                                map.set(display, isNaN(ts) ? null : ts);
                            }
                        }
                    } catch (e) { }

                    const arr = Array.from(map.entries()).map(([display, ts]) => ({ display, ts }));
                    arr.sort((a,b) => {
                        if (a.ts === null && b.ts === null) return a.display.localeCompare(b.display);
                        if (a.ts === null) return 1;
                        if (b.ts === null) return -1;
                        return a.ts - b.ts;
                    });
                    return arr.map(x => x.display);
                };

                fields.forEach(f => {
                    const btn = document.createElement('div');
                    btn.style.cursor = 'pointer';
                    btn.style.padding = '4px 6px';
                    btn.innerText = f;
                    btn.onclick = () => {
                        if (f === 'HOD' || f === 'F.ING.COST') {
                            const colName = (f === 'HOD') ? 'HOD' : 'F.ING.COST';
                            const vals = getUniqueValues(colName, true);
                            if (vals.length === 0) { alert('No hay valores de fecha disponibles en la columna.'); hideMenu(); return; }
                            menu.innerHTML = '';
                            const back = document.createElement('div');
                            back.style.cursor = 'pointer'; back.style.padding = '4px 6px'; back.style.fontWeight = '600'; back.innerText = '< Volver';
                            back.onclick = () => { buildMenu(); };
                            menu.appendChild(back);

                            const list = document.createElement('div');
                            list.style.maxHeight = '220px'; list.style.overflow = 'auto'; list.style.marginTop = '6px';
                            vals.forEach(v => {
                                const item = document.createElement('div');
                                item.style.cursor = 'pointer'; item.style.padding = '4px 6px'; item.innerText = v;
                                item.onclick = () => { enumeradoHeaderFilter = { field: f, value: v }; renderEnumerado(); hideMenu(); };
                                list.appendChild(item);
                            });
                            menu.appendChild(list);
                            return;
                        }

                        const val = prompt(`Valor para filtrar ${f}:`, '');
                        if (val !== null) { enumeradoHeaderFilter = { field: f, value: val }; renderEnumerado(); }
                        hideMenu();
                    };
                    menu.appendChild(btn);
                });

                const clear = document.createElement('div');
                clear.style.cursor = 'pointer'; clear.style.padding = '6px 4px'; clear.style.borderTop = '1px solid #eee'; clear.style.marginTop = '6px';
                clear.innerText = 'Limpiar filtro';
                clear.onclick = () => { enumeradoHeaderFilter = null; renderEnumerado(); hideMenu(); };
                menu.appendChild(clear);
            };

            const hideMenu = () => { menu.style.display = 'none'; };

            buildMenu();

            thead.addEventListener('contextmenu', function(e) {
                const btnPor = document.getElementById('enumerado-btn-por');
                const isPorActive = btnPor && btnPor.classList.contains('active');
                if (!isPorActive) return;
                e.preventDefault();
                menu.style.left = (e.pageX + 2) + 'px';
                menu.style.top = (e.pageY + 2) + 'px';
                menu.style.display = 'block';
            });

            document.addEventListener('click', function(e) {
                if (!menu) return;
                if (e.target && menu.contains(e.target)) return;
                hideMenu();
            });
        }

        function renderLavado() {
            const tbody = document.getElementById('tbody-lavado');
            tbody.innerHTML = "";
            let count = 0;
            // Recolectar índices válidos y ordenarlos por OP-PTDA (y fecha)
            let validIndices = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const estadoBloq = row[colMap["estado_bloqueo"]];
                const estadoBloqNorm = (!estadoBloq || estadoBloq === "") ? "X PROG" : estadoBloq;

                // Mostrar solo filas cuyo estado_bloqueo sea OK
                if (estadoBloqNorm !== 'OK') continue;

                const estadoLav = row[colMap["estado_lavada"]];
                const estadoLavNorm = (!estadoLav || estadoLav === "" ) ? "EN LAV" : String(estadoLav);
                const estUpper = String(estadoLavNorm).toUpperCase();
                // Mostrar solo filas cuyo estado_lavada sea diferente de OK
                if (estUpper === 'OK') continue;

                validIndices.push(i);
            }

            validIndices = sortBloqueoData(validIndices);

            // Agrupar por OP-PTDA alternando clases para sombreado
            let lastOpPtda = null;
            let currentGroup = 'a';

            validIndices.forEach(i => {
                count++;
                const row = rawData[i];
                const opTela = String(row[colMap["OP TELA"]] || "").trim();
                const partida = String(row[colMap["PARTIDA"]] || "").trim();
                const currentOpPtda = opTela + "-" + partida;

                if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                    currentGroup = (currentGroup === 'a') ? 'b' : 'a';
                }
                lastOpPtda = currentOpPtda;

                const tr = createRow(row, i, "lavado", currentGroup);
                
                // Agregar celda P al inicio (Lavanderia siempre muestra P en "Por Lavar")
                const pCell = document.createElement('td');
                pCell.className = 'p-cell';
                try {
                    const idxP = findHeaderIndexCaseInsensitive('P');
                    const onLavView = document.getElementById('view-lavado') && document.getElementById('view-lavado').classList.contains('active');
                    const isPorLavar = onLavView && String(currentLavadoFilter).toUpperCase() === 'EN LAV';
                    if (idxP !== -1) {
                        const pVal = String(row[idxP] || '').trim();
                        if (isPorLavar) {
                            // Mostrar como texto no editable
                            pCell.textContent = pVal;
                        } else {
                            // Mantener input en otros casos
                            pCell.innerHTML = createPrioridadCell(i, row).replace(/<td.*?>|<\/td>/g, '');
                        }
                    } else {
                        pCell.innerHTML = createPrioridadCell(i, row).replace(/<td.*?>|<\/td>/g, '');
                    }
                } catch (e) {
                    pCell.innerHTML = createPrioridadCell(i, row).replace(/<td.*?>|<\/td>/g, '');
                }
                tr.insertBefore(pCell, tr.firstChild);
                
                // Si P = 1, aplicar color rojo claro
                const idxP = findHeaderIndexCaseInsensitive('P');
                if (idxP !== -1) {
                    const pValue = String(row[idxP] || '').trim();
                    if (pValue === '1') {
                        tr.classList.add('priority-1');
                    }
                }
                
                tbody.appendChild(tr);
            });
            document.getElementById('count-lavado').innerText = count;
            
            // Inicializar eventos de los selectores de fecha
            initializeDateInputs();
        }

        function renderCorte() {
            const tbody = document.getElementById('tbody-corte');
            tbody.innerHTML = "";
            let count = 0;
            // Control de columnas finales (estado_bloques, estado_coll_tap)
            // - Si estamos en X PROG, ocultarlas.
            // - Si estamos en un sub-tab PROG (1T/2T/3T), mostrarlas y renombrarlas.
            const hideExtra = (currentCorteFilter === 'X PROG');
            const showAsProg = (currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG');
            
            // Mostrar/ocultar columna P según el sub-tab activo (solo en PROG 1T/2T/3T)
            const showPColumn = showAsProg;
            try {
                const thP = document.getElementById('th-corte-p');
                if (thP) thP.style.display = showPColumn ? '' : 'none';
            } catch (e) {}
            
            const ths = document.querySelectorAll('#view-corte thead th');
            if (ths && ths.length >= 2) {
                // Últimas dos columnas de la tabla de Corte
                const thBloques = ths[ths.length - 2];
                const thCollTap = ths[ths.length - 1];
                thBloques.style.display = hideExtra ? 'none' : '';
                thCollTap.style.display = hideExtra ? 'none' : '';
                if (!hideExtra && showAsProg) {
                    thBloques.innerText = 'BLOQUES?';
                    thCollTap.innerText = 'COLL o TAP?';
                } else if (!hideExtra) {
                    thBloques.innerText = 'estado_bloques';
                    thCollTap.innerText = 'estado_coll_tap';
                }

                // Ajustar anchos de columnas OC y OP-PTDA cuando estamos en sub-tabs PROG
                // y ocultar columna EQUIPO_CORTE en PROG
                try {
                    let ocTh = null;
                    let opPtdaTh = null;
                    let equipoCorteTh = null;
                    ths.forEach(th => {
                        const txt = (th.textContent || '').toString().trim().toUpperCase();
                        if (txt === 'OC') ocTh = th;
                        if (txt === 'OP-PTDA' || txt === 'OP-PTDA') opPtdaTh = th;
                        if (txt === 'EQUIPO_CORTE') equipoCorteTh = th;
                    });

                    if (showAsProg) {
                        if (ocTh) ocTh.style.width = '120px';
                        if (opPtdaTh) opPtdaTh.style.width = '60px';
                        if (equipoCorteTh) equipoCorteTh.style.display = 'none';
                    } else {
                        // valores por defecto cuando no es PROG (X PROG u otras vistas)
                        if (ocTh) ocTh.style.width = '60px';
                        if (opPtdaTh) opPtdaTh.style.width = '80px';
                        if (equipoCorteTh) equipoCorteTh.style.display = '';
                    }
                } catch (e) { /* ignore */ }
            }

            // Recolectar índices válidos según filtro de Corte (excluir OK)
            let validIndices = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const estadoCorteVal = (row[colMap["STATUS_CORTE"]] || row[colMap["STATUS"]] || row[colMap["status"]] || row[colMap["estado_corte"]] || row[colMap["ESTADO CORTE"]] || row[colMap["ESTADO_CORTE"]]) || "";
                const isCorteOk = String(estadoCorteVal).toUpperCase() === 'OK';
                const estadoCorteNorm = (!estadoCorteVal || estadoCorteVal === '') ? 'X PROG' : String(estadoCorteVal);

                if (!isCorteOk && estadoCorteNorm === currentCorteFilter) {
                    // Si estamos en el sub-tab 'X PROG' y hay filtros por RUTA activos,
                    // aplicar filtrado: incluir la fila solo si su clave RUTA coincide
                    try {
                        if (currentCorteFilter === 'X PROG') {
                            const anyChecked = Object.values(routeFilters).some(v => v);
                            if (anyChecked) {
                                const routeKey = getRouteKeyForRow(row);
                                if (!routeFilters.hasOwnProperty(routeKey) || !routeFilters[routeKey]) {
                                    continue; // no coincide con filtros activos
                                }
                            }
                            // Además: excluir filas cuyo CORTE (parte base antes de '-')
                            // sea numérico y mayor o igual a 9000 cuando estamos en X PROG
                            try {
                                const corteRaw = String(row[colMap["CORTE"]] || '').trim();
                                const corteBase = parseInt((corteRaw.split('-')[0] || '').trim());
                                if (!isNaN(corteBase) && corteBase >= 9000) {
                                    continue; // omitir esta fila en X PROG
                                }
                            } catch(e) { /* ignore parsing issues */ }
                        }
                    } catch (e) { /* silent */ }

                    validIndices.push(i);
                }
            }

            // Para 'X PROG' en Corte, ordenar por OP-PTDA (consistentemente con bloqueo/lavado)
            if (currentCorteFilter === 'X PROG') {
                try { validIndices = sortBloqueoData(validIndices); } catch(e) { /* ignore */ }
            }

            // Aplicar filtro de encabezado en Corte si existe (solo X PROG)
            try {
                if (currentCorteFilter === 'X PROG' && corteHeaderFilter && corteHeaderFilter.field && corteHeaderFilter.value !== undefined && corteHeaderFilter.value !== null && String(corteHeaderFilter.value).trim() !== '') {
                    const f = corteHeaderFilter.field;
                    const v = String(corteHeaderFilter.value).toUpperCase().trim();
                    validIndices = validIndices.filter(idx => {
                        const r = rawData[idx] || [];
                        try {
                            if (f === 'HOD') {
                                const cell = formatValue(getVal(r, 'HOD'), 'date') || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'F.ING.COST') {
                                const cell = formatValue(getVal(r, 'F.ING.COST'), 'date') || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'CLIENTE') {
                                const cell = normalizeClientName(getVal(r, 'CLIENTE')) || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'OP-PTDA') {
                                const opTela = String(getVal(r, 'OP TELA') || '').trim();
                                const partida = String(getVal(r, 'PARTIDA') || '').trim();
                                const cell = (opTela + '-' + partida) || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'OC') {
                                const op = String(getVal(r, 'OP') || '').trim();
                                const corte = String(getVal(r, 'CORTE') || '').trim();
                                const cell = (op + '-' + corte) || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'COLOR') {
                                const cell = String(getVal(r, 'COLOR') || '') || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'RUTA') {
                                const rutaTela = (getVal(r, 'RUTA TELA') || '').toString().toUpperCase().trim();
                                const estadoBloqueo = (getVal(r, 'estado_bloqueo') || '').toString().toUpperCase().trim();
                                const estadoLavada = (getVal(r, 'estado_lavada') || '').toString().toUpperCase().trim();
                                let cell = '';
                                if (rutaTela === 'LAVADA') {
                                    if (estadoBloqueo === 'OK' && estadoLavada === 'OK') cell = 'LV-OK';
                                    else if (estadoBloqueo !== 'OK') cell = 'X BLOQ';
                                    else if (estadoLavada !== 'OK') cell = 'X LAVAR';
                                } else if (rutaTela === 'ACABADA') {
                                    cell = 'AC';
                                }
                                return cell.indexOf(v) !== -1;
                            }
                        } catch (e) { return false; }
                        return false;
                    });
                }
            } catch (e) { console.error('Error applying corteHeaderFilter', e); }

            // Si estamos en PROG 1T/2T/3T, agrupar por EQUIPO_CORTE
            const isProgSubtab = showAsProg && (currentCorteFilter === 'PROG 1T' || currentCorteFilter === 'PROG 2T' || currentCorteFilter === 'PROG 3T');
            
            if (isProgSubtab) {
                // Ordenar validIndices por equipo_corte (según orden EQ de equiposCorteData)
                // Antes de ordenar, detectar si alguna base de CORTE tiene tendidos creados
                // Use localStorage-backed set of created bases to prioritize them
                const corteIdxForMap = colMap["CORTE"];
                const baseHasInserted = {};
                try {
                    validIndices.forEach(idx => {
                        const val = String(rawData[idx][corteIdxForMap] || '').trim();
                        const base = (/\d{2}$/.test(val.slice(-2)) ? val.slice(0, -2) : val) || '';
                        if (base) {
                            baseHasInserted[base] = baseHasInserted[base] || (window._createdTendidoBases && window._createdTendidoBases.has(base));
                        }
                    });

                    // Reordenar globalmente poniendo primero los índices cuyas bases están registradas
                    // en la lista de bases creadas. Esto hace que esas OC/bases aparezcan en primer lugar
                    // en todo el tbody, antes de agrupar por equipo.
                    const top = [];
                    const rest = [];
                    validIndices.forEach(idx => {
                        try {
                            const val = String(rawData[idx][corteIdxForMap] || '').trim();
                            const base = (/\d{2}$/.test(val.slice(-2)) ? val.slice(0, -2) : val) || '';
                            if (base && window._createdTendidoBases && window._createdTendidoBases.has(base)) top.push(idx);
                            else rest.push(idx);
                        } catch (e) { rest.push(idx); }
                    });
                    validIndices = top.concat(rest);
                } catch (e) { /* ignore */ }

                validIndices.sort((a, b) => {
                    // 1. Primero ordenar por columna P (valores numéricos primero, luego vacíos)
                    const idxP = findHeaderIndexCaseInsensitive('P');
                    let pA = '';
                    let pB = '';
                    if (idxP !== -1) {
                        pA = String(rawData[a][idxP] || '').trim();
                        pB = String(rawData[b][idxP] || '').trim();
                    }
                    
                    const pNumA = pA === '' ? Infinity : parseInt(pA) || Infinity;
                    const pNumB = pB === '' ? Infinity : parseInt(pB) || Infinity;
                    
                    if (pNumA !== pNumB) return pNumA - pNumB;
                    
                    // 2. Luego por equipo_corte
                    const equipoA = String(rawData[a][colMap["EQUIPO CORTE"]] || rawData[a][colMap["EQUIPO_CORTE"]] || rawData[a][colMap["equipo_corte"]] || "").trim();
                    const equipoB = String(rawData[b][colMap["EQUIPO CORTE"]] || rawData[b][colMap["EQUIPO_CORTE"]] || rawData[b][colMap["equipo_corte"]] || "").trim();

                    // Encontrar el orden EQ de cada equipo
                    const findEqOrder = (nombre) => {
                        const equipo = equiposCorteData.find(eq => eq.nombre === nombre);
                        return equipo ? (parseInt(equipo.eq) || 999) : 999;
                    };

                    const orderA = findEqOrder(equipoA);
                    const orderB = findEqOrder(equipoB);
                    if (orderA !== orderB) return orderA - orderB;

                    // Si pertenecen al mismo equipo, ordenar por base de CORTE y sufijo (tendido)
                    const corteIdx = colMap["CORTE"];
                    const rawA = String(rawData[a][corteIdx] || '').trim();
                    const rawB = String(rawData[b][corteIdx] || '').trim();

                    const parseCorte = (s) => {
                        if (!s) return { base: '', suf: 0 };
                        const last2 = s.slice(-2);
                        if (/^\d{2}$/.test(last2)) {
                            return { base: s.slice(0, -2), suf: parseInt(last2, 10) };
                        }
                        return { base: s, suf: 0 };
                    };

                    const pa = parseCorte(rawA);
                    const pb = parseCorte(rawB);

                    // Priorizar bases que tengan tendidos creados: aparecerán primero dentro del mismo equipo
                    const baseA = pa.base || '';
                    const baseB = pb.base || '';
                    const aHas = baseHasInserted[baseA] || false;
                    const bHas = baseHasInserted[baseB] || false;
                    if (aHas !== bHas) return aHas ? -1 : 1;

                    // Comparar base (numérico si posible)
                    const numA = parseInt(pa.base.replace(/[^0-9]/g, ''), 10);
                    const numB = parseInt(pb.base.replace(/[^0-9]/g, ''), 10);
                    if (!isNaN(numA) && !isNaN(numB)) {
                        if (numA !== numB) return numA - numB;
                    } else {
                        const cmp = (pa.base || '').localeCompare(pb.base || '');
                        if (cmp !== 0) return cmp;
                    }

                    // Finalmente ordenar por sufijo (tendido)
                    return (pa.suf || 0) - (pb.suf || 0);
                });
                
                // Agrupar por equipo y renderizar con headers
                let lastEquipo = null;
                let lastOpPtda = null;
                let currentGroup = 'a';
                
                validIndices.forEach(i => {
                    const row = rawData[i];
                    const equipoCorte = String(row[colMap["EQUIPO CORTE"]] || row[colMap["EQUIPO_CORTE"]] || row[colMap["equipo_corte"]] || "").trim();
                    
                    // Si cambia el equipo, insertar fila de encabezado
                    if (equipoCorte !== lastEquipo) {
                        const headerRow = document.createElement('tr');
                        headerRow.style.backgroundColor = '#FFE699';
                        headerRow.style.color = '#1e40af';
                        headerRow.style.fontWeight = '700';
                        headerRow.style.fontSize = '13px';
                        
                        // Calcular colspan: en PROG son 15 columnas (sin equipo_corte ni las 2 finales que ya están)
                        const colspan = '15';
                        // Calcular suma de PDS para este equipo dentro del conjunto filtrado (validIndices)
                        let pdsEquipo = 0;
                        try {
                            pdsEquipo = validIndices.reduce((acc, idx2) => {
                                try {
                                    const r = rawData[idx2];
                                    const eq = String(r[colMap["EQUIPO CORTE"]] || r[colMap["EQUIPO_CORTE"]] || r[colMap["equipo_corte"]] || "").trim();
                                    if (eq === equipoCorte) {
                                        const pv = parseFloat(getVal(r, "PDS GIRADAS") || getVal(r, "PDS") || 0) || 0;
                                        return acc + pv;
                                    }
                                } catch(e) { /* ignore row parse errors */ }
                                return acc;
                            }, 0);
                        } catch (e) { pdsEquipo = 0; }

                        headerRow.innerHTML = `<td colspan="${colspan}" style="padding: 8px 12px; text-align: left;">
                            <i class="ph ph-package" style="margin-right: 8px;"></i>${equipoCorte || 'SIN EQUIPO ASIGNADO'} [${formatThousands(pdsEquipo,0)}pds]
                        </td>`;
                        tbody.appendChild(headerRow);
                        
                        lastEquipo = equipoCorte;
                        lastOpPtda = null; // Reiniciar al cambiar de equipo
                    }
                    
                    // Pintar por OP-PTDA dentro de cada equipo
                    const opTela = String(row[colMap["OP TELA"]] || "").trim();
                    const partida = String(row[colMap["PARTIDA"]] || "").trim();
                    const currentOpPtda = `${opTela}-${partida}`;
                    
                    if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                        currentGroup = (currentGroup === 'a') ? 'b' : 'a';
                    }
                    lastOpPtda = currentOpPtda;
                    
                    count++;
                    const tr = createRow(row, i, "corte", currentGroup);
                    // En sub-tabs PROG, eliminar celda de equipo_corte (posición 12) y las 2 últimas
                    const tds = tr.querySelectorAll('td');
                    if (tds && tds.length >= 13) {
                        // Eliminar celda equipo_corte (índice 12, antes de STATUS_CORTE)
                        tds[12].remove();
                    }
                    
                    // Agregar celda P al inicio en sub-tabs PROG
                    if (showPColumn) {
                        const pCell = document.createElement('td');
                        pCell.innerHTML = createPrioridadCell(i, row).replace(/<td.*?>|<\/td>/g, '');
                        tr.insertBefore(pCell, tr.firstChild);
                    }
                    
                    // Si P = 1, aplicar color rojo claro
                    const idxP = findHeaderIndexCaseInsensitive('P');
                    if (idxP !== -1) {
                        const pValue = String(row[idxP] || '').trim();
                        if (pValue === '1') {
                            tr.classList.add('priority-1');
                        }
                    }
                    
                    tbody.appendChild(tr);
                });
            } else {
                // Comportamiento original para X PROG: agrupar por OP-PTDA
                validIndices = sortCorteData(validIndices);
                let lastOpPtda = null;
                let currentGroup = 'a';

                validIndices.forEach(i => {
                    count++;
                    const row = rawData[i];
                    const opTela = String(row[colMap["OP TELA"]] || "").trim();
                    const partida = String(row[colMap["PARTIDA"]] || "").trim();
                    const currentOpPtda = `${opTela}-${partida}`;
                    
                    if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                        currentGroup = (currentGroup === 'a') ? 'b' : 'a';
                    }
                    lastOpPtda = currentOpPtda;

                    const tr = createRow(row, i, "corte", currentGroup);
                    if (hideExtra) {
                        for (let k = 0; k < 2; k++) {
                            const tds = tr.querySelectorAll('td');
                            if (tds && tds.length) tds[tds.length - 1].remove();
                        }
                    }
                    
                    // Si P = 1, aplicar color rojo claro
                    const idxP = findHeaderIndexCaseInsensitive('P');
                    if (idxP !== -1) {
                        const pValue = String(row[idxP] || '').trim();
                        if (pValue === '1') {
                            tr.classList.add('priority-1');
                        }
                    }
                    
                    tbody.appendChild(tr);
                });
            }

            document.getElementById('count-corte').innerText = count;
            
            // Inicializar eventos de los selectores de fecha
            initializeDateInputs();
            
            // Inicializar menú contextual de filtro en encabezados (solo X PROG)
            if (currentCorteFilter === 'X PROG') {
                initializeCorteHeaderContextMenus();
            }
        }

        function renderEnumerado() {
            const tbody = document.getElementById('tbody-enumerado');
            if (!tbody) return;
            tbody.innerHTML = "";
            let count = 0;
            let pds_total = 0;
            // Ocultar las columnas OP-PTDA y ART. en el encabezado de Enumerado
            try {
                const thsEnum = document.querySelectorAll('#view-enumerado thead th');
                thsEnum.forEach(th => {
                    const txt = (th.textContent || '').toString().trim().toUpperCase();
                    if (txt === 'OP-PTDA' || txt === 'ART.' || txt === 'ART') th.style.display = 'none';
                    // Ocultar columna COLL/TAP en la vista Enumerado
                    if (txt.indexOf('COLL') !== -1 || txt.indexOf('COLL O TAP') !== -1 || txt.indexOf('ESTADO_COLL_TAP') !== -1 || txt.indexOf('ESTADO COLL TAP') !== -1) th.style.display = 'none';
                });
            } catch (e) {}

            // Enumerado: coleccionar filas cuyo estado_corte = 'OK' y estado_enumerado != 'OK ENM'/'OK S/ENM'
            const items = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const estadoCorteVal = (row[colMap["STATUS_CORTE"]] || row[colMap["STATUS"]] || row[colMap["status"]] || row[colMap["estado_corte"]] || row[colMap["ESTADO CORTE"]] || row[colMap["ESTADO_CORTE"]]) || "";
                const isCorteOk = String(estadoCorteVal).toUpperCase() === 'OK';

                if (!isCorteOk) continue;

                // Intentar localizar la columna estado_enumerado de forma robusta
                let ev = '';
                try {
                    const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
                    if (idxEv !== -1 && rawData[i] && rawData[i][idxEv] !== undefined) ev = rawData[i][idxEv];
                    else ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO_ENumerado') || getVal(row, 'ESTADO ENUMERADO') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO_ENumerado') || getVal(row, 'ESTADO ENUMERADO') || ''; }

                const evNorm = (ev || '').toString().toUpperCase().trim();
                // Excluir filas ya enumeradas
                if (evNorm === 'OK ENM' || evNorm === 'OK S/ENM' || evNorm === 'OK PAQUETEO') continue;

                // sumar prendas (PDS) para el badge
                const pdsVal = parseFloat(getVal(row, "PDS GIRADAS")) || 0;
                pds_total += pdsVal;

                // Obtener valor OC para ordenar y agrupar
                let ocVal = '';
                try {
                    const idxOc = findHeaderIndexCaseInsensitive('OC');
                    if (idxOc !== -1 && rawData[i] && rawData[i][idxOc] !== undefined) ocVal = String(rawData[i][idxOc]);
                    else ocVal = (getVal(row, 'OC') || '').toString();
                } catch (e) { ocVal = (getVal(row, 'OC') || '').toString(); }

                items.push({ row, i, oc: (ocVal || '').toString().trim() });
                count++;
            }

            // Aplicar filtro de encabezado en Enumerado si existe (solo Por enumerar)
            try {
                const btnPor = document.getElementById('enumerado-btn-por');
                const isPorActive = btnPor && btnPor.classList.contains('active');
                if (isPorActive && enumeradoHeaderFilter && enumeradoHeaderFilter.field && enumeradoHeaderFilter.value !== undefined && enumeradoHeaderFilter.value !== null && String(enumeradoHeaderFilter.value).trim() !== '') {
                    const f = enumeradoHeaderFilter.field;
                    const v = String(enumeradoHeaderFilter.value).toUpperCase().trim();
                    for (let idx = items.length - 1; idx >= 0; idx--) {
                        const r = items[idx].row || [];
                        let keep = false;
                        try {
                            if (f === 'HOD') {
                                const cell = formatValue(getVal(r, 'HOD'), 'date') || '';
                                keep = String(cell).toUpperCase().indexOf(v) !== -1;
                            } else if (f === 'F.ING.COST') {
                                const cell = formatValue(getVal(r, 'F.ING.COST'), 'date') || '';
                                keep = String(cell).toUpperCase().indexOf(v) !== -1;
                            } else if (f === 'CLIENTE') {
                                const cell = normalizeClientName(getVal(r, 'CLIENTE')) || '';
                                keep = String(cell).toUpperCase().indexOf(v) !== -1;
                            } else if (f === 'OP-PTDA') {
                                const opTela = String(getVal(r, 'OP TELA') || '').trim();
                                const partida = String(getVal(r, 'PARTIDA') || '').trim();
                                const cell = (opTela + '-' + partida) || '';
                                keep = String(cell).toUpperCase().indexOf(v) !== -1;
                            } else if (f === 'OC') {
                                const op = String(getVal(r, 'OP') || '').trim();
                                const corte = String(getVal(r, 'CORTE') || '').trim();
                                const cell = (op + '-' + corte) || '';
                                keep = String(cell).toUpperCase().indexOf(v) !== -1;
                            } else if (f === 'COLOR') {
                                const cell = String(getVal(r, 'COLOR') || '') || '';
                                keep = String(cell).toUpperCase().indexOf(v) !== -1;
                            } else if (f === 'RUTA') {
                                const rutaTela = (getVal(r, 'RUTA TELA') || '').toString().toUpperCase().trim();
                                let cell = '';
                                if (rutaTela === 'LAVADA') cell = 'LAVADA';
                                else if (rutaTela === 'ACABADA') cell = 'ACABADA';
                                keep = cell.indexOf(v) !== -1;
                            }
                        } catch (e) { keep = false; }
                        if (!keep) items.splice(idx, 1);
                    }
                }
            } catch (e) { console.error('Error applying enumeradoHeaderFilter', e); }

            // Ordenar por OC (comparación natural numérica si aplica)
            items.sort((a, b) => (a.oc || '').localeCompare(b.oc || '', undefined, { numeric: true, sensitivity: 'base' }));

            // Pintar filas alternando por grupos de OC (cada vez que cambia OC se invierte color)
            let lastOc = null;
            let groupToggle = false;
            items.forEach(item => {
                const tr = createRow(item.row, item.i, "corte");
                // Quitar el botón de tendido ('+') en la columna OC para la vista Enumerado
                try {
                    const tendidoBtn = tr.querySelector('button.btn-tendido');
                    if (tendidoBtn) tendidoBtn.remove();
                } catch (e) {}
                try {
                    const tds = tr.querySelectorAll('td');
                    // Eliminar ART primero (índice 9) luego OP-PTDA (índice 6)
                    if (tds.length > 9) tds[9].remove();
                    if (tds.length > 6) tds[6].remove();
                } catch (e) {}

                // Agregar celda P al inicio en Enumerado
                const pCell = document.createElement('td');
                try {
                    const btnPor = document.getElementById('enumerado-btn-por');
                    const isPorActive = btnPor && btnPor.classList.contains('active');
                    const idxP = findHeaderIndexCaseInsensitive('P');
                    const pVal = (idxP !== -1 && item.row && item.row[idxP] !== undefined) ? String(item.row[idxP]).trim() : '';
                    if (isPorActive) {
                        // Mostrar como texto no editable
                        pCell.textContent = pVal;
                    } else {
                        pCell.innerHTML = createPrioridadCell(item.i, item.row).replace(/<td.*?>|<\/td>/g, '');
                    }
                } catch (e) {
                    pCell.innerHTML = createPrioridadCell(item.i, item.row).replace(/<td.*?>|<\/td>/g, '');
                }
                tr.insertBefore(pCell, tr.firstChild);

                const ocNow = (item.oc || '').toString();
                if (ocNow !== lastOc) {
                    groupToggle = !groupToggle;
                    lastOc = ocNow;
                }
                tr.classList.add(groupToggle ? 'group-a' : 'group-b');
                
                // Si P = 1, aplicar color rojo claro
                const idxP = findHeaderIndexCaseInsensitive('P');
                if (idxP !== -1) {
                    const pValue = String(item.row[idxP] || '').trim();
                    if (pValue === '1') {
                        tr.classList.add('priority-1');
                    }
                }
                
                tbody.appendChild(tr);
            });
            document.getElementById('count-enumerado').innerText = count;
            try {
                const el = document.getElementById('enumerado-pds-por');
                if (el) el.innerText = `[${formatThousands(pds_total,0)}pds]`;
            } catch (e) {}
            
            // Inicializar eventos de los selectores de fecha
            initializeDateInputs();
            
            // Inicializar menú contextual de filtro en encabezados
            initializeEnumeradoHeaderContextMenus();
        }

        function renderTransfer() {
            const tbody = document.getElementById('tbody-transfer');
            if (!tbody) return;
            tbody.innerHTML = "";
            let count = 0;
            let lastOpPtda = null;
            let currentGroup = 'a'; // Para alternar sombreado de filas
            
            // Mostrar/ocultar columna P según el sub-tab activo (solo en PROG)
            const showPColumn = (currentTransferFilter === 'PROG');
            try {
                const thP = document.getElementById('th-transfer-p');
                if (thP) thP.style.display = showPColumn ? '' : 'none';
            } catch (e) {}

            // Transfer muestra filas cuyo estado_enumerado = 'OK ENM' o 'OK S/ENM'
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                
                // Obtener estado_enumerado
                let ev = '';
                try {
                    const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
                    if (idxEv !== -1 && rawData[i] && rawData[i][idxEv] !== undefined) ev = rawData[i][idxEv];
                    else ev = getVal(row, 'estado_enumerado') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || ''; }

                const evNorm = (ev || '').toString().toUpperCase().trim();
                
                // Solo mostrar filas con estado_enumerado = 'OK ENM', 'OK S/ENM' o 'OK PAQUETEO'
                if (evNorm === 'OK ENM' || evNorm === 'OK S/ENM' || evNorm === 'OK PAQUETEO') {
                    // Si la fila indica NO LLEVA en n.transfxpda, no mostrarla en Transfer
                    const rawNTrans = getVal(row, 'n.transfxpda');
                    let nTransfValCheck = '';
                    if (rawNTrans !== undefined && rawNTrans !== null && rawNTrans.toString().trim() !== '') {
                        nTransfValCheck = rawNTrans.toString();
                    } else {
                        const clienteChk = (getVal(row, 'CLIENTE') || '').toString().trim();
                        const estiloChk = (getVal(row, 'ESTILO') || '').toString().trim();
                        const avgChk = avgTransfByClienteEstilo(clienteChk, estiloChk);
                        nTransfValCheck = (avgChk !== null) ? avgChk : '';
                    }
                    nTransfValCheck = nTransfValCheck.toUpperCase().trim();
                    if (nTransfValCheck === 'NO LLEVA') continue;
                    // Obtener estado_transfer (por defecto 'X PROG' si está vacío)
                    let estadoTransfer = getVal(row, 'estado_transfer') || 'X PROG';
                    estadoTransfer = (!estadoTransfer || estadoTransfer === '') ? 'X PROG' : estadoTransfer;
                    
                    // Filtrar según el sub-tab activo
                    if (estadoTransfer === currentTransferFilter) {
                        count++;
                        
                        // Crear fila
                        const tr = document.createElement('tr');
                        
                        // HOD
                        const tdFDesp = document.createElement('td');
                        tdFDesp.className = 'date-cell';
                        tdFDesp.innerText = formatValue(getVal(row, 'HOD') || getVal(row, 'F DESPACHO') || '', 'date');
                        tr.appendChild(tdFDesp);
                        
                        // F.ING.COST - mostrar como texto en X PROG (no editable)
                        const tdFCost = document.createElement('td');
                        tdFCost.className = 'date-cell';
                        if (currentTransferFilter === 'X PROG') {
                            // En 'Por Programar' mostramos la fecha como texto (no editable)
                            tdFCost.innerText = formatValue(getVal(row, 'F. ING COST') || getVal(row, 'F ING COST') || getVal(row, 'F.ING.COST') || '', 'date');
                        } else {
                            // En otras vistas mantenemos el date-picker para edición
                            const rawFIngCost = getVal(row, 'F.ING.COST') || getVal(row, 'F. ING COST') || getVal(row, 'F ING COST') || '';
                            const dateValue = convertToDateInputFormat(rawFIngCost);
                            tdFCost.innerHTML = `<input type="date" class="short-year" value="${dateValue}" onchange="handleDateChange(this, ${i}, 'F.ING.COST')"><span class="date-yy">${formatDateShortFromInput(dateValue) || 'mm/dd/aaaa'}</span>`;
                            // Inicializar evento onclick del span
                            setTimeout(() => {
                                const inputEl = tdFCost.querySelector('input.short-year');
                                const spanEl = tdFCost.querySelector('span.date-yy');
                                if (inputEl && spanEl) {
                                    spanEl.onclick = function(e) {
                                        e.stopPropagation();
                                        inputEl.showPicker ? inputEl.showPicker() : inputEl.click();
                                    };
                                }
                            }, 0);
                        }
                        tr.appendChild(tdFCost);
                        
                        // CLIENTE (normalizado para la vista Transfer)
                        const tdCliente = document.createElement('td');
                        tdCliente.innerText = normalizeClientForTransfer(getVal(row, 'CLIENTE') || '');
                        tr.appendChild(tdCliente);
                        
                        // RUTA
                        const tdRuta = document.createElement('td');
                        const rutaVal = getVal(row, 'RUTA TELA') || getVal(row, 'RUTA') || '';
                        tdRuta.innerHTML = renderRutaBadge(rutaVal, row);
                        tr.appendChild(tdRuta);
                        
                        // OC: usar columna OC si existe, sino concatenar OP y CORTE (ej: 39579-29)
                        const tdOC = document.createElement('td');
                        let ocVal = getVal(row, 'OC') || '';
                        if ((!ocVal || String(ocVal).trim() === '')) {
                            const opVal = getVal(row, 'OP') || getVal(row, 'OP TELA') || getVal(row, 'OP-PTDA') || '';
                            const corteVal = getVal(row, 'CORTE') || getVal(row, 'PARTIDA') || '';
                            if (opVal && corteVal) ocVal = `${String(opVal).trim()}-${String(corteVal).trim()}`;
                            else if (opVal) ocVal = String(opVal).trim();
                            else ocVal = '';
                        }
                        tdOC.innerText = ocVal;
                        tr.appendChild(tdOC);
                        
                        // COLOR
                        const tdColor = document.createElement('td');
                        tdColor.innerText = getVal(row, 'COLOR') || '';
                        tr.appendChild(tdColor);
                        
                        // PDS
                        const tdPds = document.createElement('td');
                        tdPds.style.textAlign = 'center';
                        const pdsVal = parseFloat(getVal(row, 'PDS GIRADAS') || getVal(row, 'PDS') || 0);
                        tdPds.innerText = formatThousands(pdsVal, 0);
                        tr.appendChild(tdPds);
                        
                        // PRENDA
                        const tdPrenda = document.createElement('td');
                        tdPrenda.innerText = getVal(row, 'PRENDA') || '';
                        tr.appendChild(tdPrenda);
                        
                        // TIPO CERT.
                        const tdCert = document.createElement('td');
                        tdCert.innerText = getVal(row, 'TIPO CERT') || getVal(row, 'TIPO CERT.') || '';
                        tr.appendChild(tdCert);
                        
                        // n.transfxpda: en sub-tabs 'Por Programar' (X PROG) y 'Programado' (PROG)
                        // mostrar solo el dato (sin desplegable). En otros casos podría seguir siendo editable.
                        const tdTransfxpda = document.createElement('td');
                        const rawNTrans = getVal(row, 'n.transfxpda');
                        let nTransfVal;
                        if (rawNTrans !== undefined && rawNTrans !== null && rawNTrans.toString().trim() !== '') {
                            nTransfVal = rawNTrans.toString().trim();
                        } else {
                            const clienteCur = (getVal(row, 'CLIENTE') || '').toString().trim();
                            const estiloCur = (getVal(row, 'ESTILO') || '').toString().trim();
                            const avgCur = avgTransfByClienteEstilo(clienteCur, estiloCur);
                            nTransfVal = (avgCur !== null) ? avgCur : 'LLEVA?';
                        }
                        // Normalize nTransf and tipo-transfer to detect 'NO LLEVA' values
                        const nTransfNormForCheck = (nTransfVal || '').toString().toUpperCase().trim();
                        const tipoTransferRaw = getVal(row, 'tipo-transfer') || getVal(row, 'tipo_transfer') || getVal(row, 'TIPO-TRANSFER') || '';
                        const tipoTransferNorm = (tipoTransferRaw || '').toString().toUpperCase().trim();

                        // If either n.transfxpda or tipo-transfer indicate NO LLEVA, skip this row
                        if (nTransfNormForCheck.indexOf('NO LLEVA') !== -1 || tipoTransferNorm.indexOf('NO LLEVA') !== -1) {
                            continue;
                        }

                        // Si estamos en los sub-tabs normales de Transfer (X PROG o PROG), mostrar solo texto
                        if (currentTransferFilter === 'X PROG' || currentTransferFilter === 'PROG') {
                            tdTransfxpda.style.textAlign = 'center';
                            tdTransfxpda.innerText = nTransfVal;
                        } else {
                            // Comportamiento por defecto: mostrar select (mantener compatibilidad)
                            const selTransf = document.createElement('select');
                            selTransf.className = 'table-select';
                            selTransf.setAttribute('data-row-index', i);
                            const nSelNorm = (nTransfVal || '').toString().toUpperCase().trim();
                            selTransf.innerHTML = `
                                <option value="LLEVA?" ${(nSelNorm === '' || nSelNorm === 'LLEVA?') ? 'selected' : ''}>LLEVA?</option>
                                <option value="NO LLEVA" ${(nSelNorm.indexOf('NO LLEVA') !== -1) ? 'selected' : ''}>NO LLEVA</option>
                                <option value="1" ${(nSelNorm === '1') ? 'selected' : ''}>1</option>
                                <option value="2" ${(nSelNorm === '2') ? 'selected' : ''}>2</option>
                                <option value="3" ${(nSelNorm === '3') ? 'selected' : ''}>3</option>
                                <option value="4" ${(nSelNorm === '4') ? 'selected' : ''}>4</option>
                                <option value="5" ${(nSelNorm === '5') ? 'selected' : ''}>5</option>
                            `;
                            selTransf.onchange = function() { updateRow(i, 'n.transfxpda', this.value, this); };
                            tdTransfxpda.appendChild(selTransf);
                        }
                        tr.appendChild(tdTransfxpda);

                        // tipo-transfer (columna nueva añadida en la hoja)
                        const tdTipoTransfer = document.createElement('td');
                        tdTipoTransfer.innerText = getVal(row, 'tipo-transfer') || getVal(row, 'tipo_transfer') || '';
                        tr.appendChild(tdTipoTransfer);
                        
                        // estado_transfer: en 'Por Programar' mostrar como texto (no editable)
                        const tdEstadoTransfer = document.createElement('td');
                        if (currentTransferFilter === 'X PROG') {
                            tdEstadoTransfer.innerText = estadoTransfer;
                        } else {
                            const selEstado = document.createElement('select');
                            selEstado.className = 'table-select';
                            selEstado.setAttribute('data-row-index', i);
                            // Mostrar la opción OK sólo en el sub-tab 'PROG' o si el valor actual es 'OK'
                            const showOkOption = (currentTransferFilter === 'PROG') || (estadoTransfer === 'OK');
                            selEstado.innerHTML = `
                                <option value="X PROG" ${estadoTransfer === 'X PROG' ? 'selected' : ''}>X PROG</option>
                                <option value="PROG" ${estadoTransfer === 'PROG' ? 'selected' : ''}>PROG</option>
                                ${showOkOption ? `<option value="OK" ${estadoTransfer === 'OK' ? 'selected' : ''}>OK</option>` : ''}
                            `;
                            // Aplicar clases visuales según el valor actual
                            if (estadoTransfer === 'PROG') { selEstado.classList.add('sel-PROG'); selEstado.classList.remove('sel-OK'); }
                            else if (estadoTransfer === 'OK') { selEstado.classList.add('sel-OK'); selEstado.classList.remove('sel-PROG'); }
                            else { selEstado.classList.remove('sel-PROG'); selEstado.classList.remove('sel-OK'); }
                            selEstado.onchange = function() {
                                // Validar que n.transfxpda no esté vacío o "LLEVA?" antes de cambiar a PROG
                                if (this.value === 'PROG') {
                                    const rawNTransChk = getVal(row, 'n.transfxpda');
                                    const nTransfValChk = ((rawNTransChk !== undefined && rawNTransChk !== null && rawNTransChk.toString().trim() !== '') ? rawNTransChk.toString().trim() : 'LLEVA?');
                                    if (nTransfValChk === '' || nTransfValChk === 'LLEVA?') {
                                        alert('Debe especificar el número de transfer por prenda antes de cambiar a PROG');
                                        this.value = estadoTransfer; // revertir al valor anterior
                                        return;
                                    }
                                }
                                updateRow(i, 'estado_transfer', this.value, this);
                                // Ajustar clases visuales
                                this.classList.remove('sel-PROG');
                                this.classList.remove('sel-OK');
                                if (this.value === 'PROG') this.classList.add('sel-PROG');
                                if (this.value === 'OK') this.classList.add('sel-OK');
                            };
                            tdEstadoTransfer.appendChild(selEstado);
                        }
                        tr.appendChild(tdEstadoTransfer);
                        
                        // Agregar celda P al inicio si estamos en sub-tab PROG
                        if (showPColumn) {
                            const pCell = document.createElement('td');
                            pCell.innerHTML = createPrioridadCell(i, row).replace(/<td.*?>|<\/td>/g, '');
                            tr.insertBefore(pCell, tr.firstChild);
                        }
                        
                        // Alternar sombreado por OP-PTDA
                        const opTela = String(row[colMap["OP TELA"]] || "").trim();
                        const partida = String(row[colMap["PARTIDA"]] || "").trim();
                        const currentOpPtda = `${opTela}-${partida}`;
                        if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                            currentGroup = (currentGroup === 'a') ? 'b' : 'a';
                        }
                        lastOpPtda = currentOpPtda;
                        tr.classList.add(`group-${currentGroup}`);
                        
                        // Si P = 1, aplicar color rojo claro
                        const idxP = findHeaderIndexCaseInsensitive('P');
                        if (idxP !== -1) {
                            const pValue = String(row[idxP] || '').trim();
                            if (pValue === '1') {
                                tr.classList.add('priority-1');
                            }
                        }
                        
                        tbody.appendChild(tr);
                    }
                }
            }
            document.getElementById('count-transfer').innerText = count;
            
            // Inicializar eventos de los selectores de fecha
            initializeDateInputs();
        }

        function renderHabilitado() {
            const tbody = document.getElementById('tbody-habilitado');
            if (!tbody) return;
            tbody.innerHTML = "";
            let count = 0;
            let lastOpPtda = null;
            let currentRowGroup = 'a'; // Para alternar sombreado de filas
            
            // Contadores de PDS por sub-tab
            let pdsXProg = 0, pds1T = 0, pds2T = 0, pds3T = 0;
            
            // Recopilar índices válidos según el sub-tab seleccionado
            // Para "Por Programar" (X PROG): todas las filas con estado_habilitado vacío o X PROG
            // Para PROG 1T/2T/3T: filas con estado_enumerado = OK ENM o OK S/ENM
            const validIndices = [];
            const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
            const idxHabil = findHeaderIndexCaseInsensitive('estado_habilitado');
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                let ev = '';
                try {
                    if (idxEv !== -1 && rawData[i] && rawData[i][idxEv] !== undefined) ev = rawData[i][idxEv];
                    else ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO_ENumerado') || getVal(row, 'ESTADO ENUMERADO') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO_ENumerado') || getVal(row, 'ESTADO ENUMERADO') || ''; }

                const evNorm = (ev || '').toString().toUpperCase().trim();
                
                // Obtener estado_habilitado para determinar inclusión
                let habilVal = '';
                if (idxHabil !== -1 && row[idxHabil] !== undefined) habilVal = row[idxHabil];
                else habilVal = getVal(row, 'estado_habilitado') || getVal(row, 'ESTADO_HABILITADO') || '';
                const habilNorm = (habilVal || '').toString().toUpperCase().trim();
                
                // Calcular PDS por sub-tab para los badges
                const pdsVal = parseFloat(getVal(row, 'PDS GIRADAS')) || 0;
                
                // Para sub-tab "Por Programar" (X PROG): incluir si estado_habilitado vacío o X PROG
                if (currentHabilitadoFilter === 'X PROG') {
                    if (habilNorm === '' || habilNorm === 'X PROG') {
                        validIndices.push(i);
                        pdsXProg += pdsVal;
                    }
                } else {
                    // Para PROG 1T/2T/3T: mantener lógica original (estado_enumerado = OK ENM o OK S/ENM)
                    if (evNorm === 'OK ENM' || evNorm === 'OK S/ENM') {
                        validIndices.push(i);
                        
                        if (habilNorm === 'PROG 1T') pds1T += pdsVal;
                        else if (habilNorm === 'PROG 2T') pds2T += pdsVal;
                        else if (habilNorm === 'PROG 3T') pds3T += pdsVal;
                    }
                }
            }
            
            // Ordenar índices válidos por columna P
            validIndices.sort((a, b) => {
                const rowA = rawData[a];
                const rowB = rawData[b];
                
                // 1. Ordenar por columna P primero (valores numéricos primero, luego vacíos)
                const idxP = findHeaderIndexCaseInsensitive('P');
                let pA = '';
                let pB = '';
                if (idxP !== -1) {
                    pA = String(rowA[idxP] || '').trim();
                    pB = String(rowB[idxP] || '').trim();
                }
                
                // Convertir a número para comparación (vacío = Infinity para que vaya al final)
                const pNumA = pA === '' ? Infinity : parseInt(pA) || Infinity;
                const pNumB = pB === '' ? Infinity : parseInt(pB) || Infinity;
                
                if (pNumA !== pNumB) return pNumA - pNumB;
                
                // 2. Luego ordenar por fecha de despacho (más reciente primero)
                const dateA = rowA[colMap["HOD"]] || 0;
                const dateB = rowB[colMap["HOD"]] || 0;
                if (dateA !== dateB) return dateB - dateA;
                
                // 3. Finalmente por OP-PTDA para mantener agrupación
                const opTelaA = String(rowA[colMap["OP TELA"]] || "").trim();
                const partidaA = String(rowA[colMap["PARTIDA"]] || "").trim();
                const opPtdaA = (opTelaA + "-" + partidaA).toLowerCase();

                const opTelaB = String(rowB[colMap["OP TELA"]] || "").trim();
                const partidaB = String(rowB[colMap["PARTIDA"]] || "").trim();
                const opPtdaB = (opTelaB + "-" + partidaB).toLowerCase();
                
                return opPtdaA.localeCompare(opPtdaB, undefined, { numeric: true, sensitivity: 'base' });
            });
            
            // Función auxiliar para extraer el valor TRSF de una fila (para agrupamiento)
            const getTrsfGroupValue = (row) => {
                const tipoTransfer = getVal(row, 'tipo-transfer') || getVal(row, 'TIPO-TRANSFER') || getVal(row, 'tipo_transfer') || '';
                const rawNTrans = getVal(row, 'n.transfxpda') || getVal(row, 'N.TRANSFXPDA') || getVal(row, 'n_transfxpda') || '';
                const tipoTransNorm = (tipoTransfer || '').toString().toUpperCase().trim();
                const nTransNorm = (rawNTrans !== undefined && rawNTrans !== null) ? String(rawNTrans).trim() : '';
                
                // Retornar 'Pza' si el valor contiene "EN PIEZA", 'Otros' para el resto
                if (tipoTransNorm === 'EN PIEZA' && !isNaN(parseInt(nTransNorm)) && nTransNorm !== '') {
                    return 'Pza';
                }
                return 'Otros';
            };
            
            // Verificar si estamos en un sub-tab PROG (1T/2T/3T)
            const isProgSubtab = (currentHabilitadoFilter === 'PROG 1T' || currentHabilitadoFilter === 'PROG 2T' || currentHabilitadoFilter === 'PROG 3T');
            
            // En PROG 1T/2T/3T, ordenar también por TRSF (Pza primero, luego Otros)
            if (isProgSubtab) {
                validIndices.sort((a, b) => {
                    const rowA = rawData[a];
                    const rowB = rawData[b];
                    
                    // 1. Ordenar por TRSF group (Pza primero)
                    const groupA = getTrsfGroupValue(rowA);
                    const groupB = getTrsfGroupValue(rowB);
                    if (groupA !== groupB) {
                        // "Pza" (0) primero, "Otros" (1) después
                        const orderA = groupA === 'Pza' ? 0 : 1;
                        const orderB = groupB === 'Pza' ? 0 : 1;
                        return orderA - orderB;
                    }
                    
                    // 2. Luego mantener orden por P
                    const idxP = findHeaderIndexCaseInsensitive('P');
                    let pA = '';
                    let pB = '';
                    if (idxP !== -1) {
                        pA = String(rowA[idxP] || '').trim();
                        pB = String(rowB[idxP] || '').trim();
                    }
                    const pNumA = pA === '' ? Infinity : parseInt(pA) || Infinity;
                    const pNumB = pB === '' ? Infinity : parseInt(pB) || Infinity;
                    if (pNumA !== pNumB) return pNumA - pNumB;
                    
                    // 3. Luego por fecha
                    const dateA = rowA[colMap["HOD"]] || 0;
                    const dateB = rowB[colMap["HOD"]] || 0;
                    if (dateA !== dateB) return dateB - dateA;
                    
                    // 4. Finalmente por OP-PTDA
                    const opTelaA = String(rowA[colMap["OP TELA"]] || "").trim();
                    const partidaA = String(rowA[colMap["PARTIDA"]] || "").trim();
                    const opPtdaA = (opTelaA + "-" + partidaA).toLowerCase();
                    const opTelaB = String(rowB[colMap["OP TELA"]] || "").trim();
                    const partidaB = String(rowB[colMap["PARTIDA"]] || "").trim();
                    const opPtdaB = (opTelaB + "-" + partidaB).toLowerCase();
                    return opPtdaA.localeCompare(opPtdaB, undefined, { numeric: true, sensitivity: 'base' });
                });
            }
            
            // Procesar filas ordenadas
            let lastTrsfGroup = null;
            
            validIndices.forEach(i => {
                const row = rawData[i];
                let ev = '';
                try {
                    if (idxEv !== -1 && rawData[i] && rawData[i][idxEv] !== undefined) ev = rawData[i][idxEv];
                    else ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO_ENumerado') || getVal(row, 'ESTADO ENUMERADO') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO_ENumerado') || getVal(row, 'ESTADO ENUMERADO') || ''; }

                const evNorm = (ev || '').toString().toUpperCase().trim();
                
                // Obtener estado_habilitado para filtrar por sub-tab
                const habilValFilter = getVal(row, 'estado_habilitado') || getVal(row, 'ESTADO_HABILITADO') || '';
                const habilValNormFilter = (habilValFilter || '').toString().toUpperCase().trim();
                
                // Para X PROG: ya se filtró en validIndices, no necesita verificar estado_enumerado
                // Para PROG 1T/2T/3T: verificar que estado_enumerado sea OK ENM o OK S/ENM
                if (currentHabilitadoFilter !== 'X PROG') {
                    if (evNorm !== 'OK ENM' && evNorm !== 'OK S/ENM') return;
                }
                
                // Filtrar según el sub-tab seleccionado
                if (currentHabilitadoFilter === 'X PROG') {
                    if (habilValNormFilter !== '' && habilValNormFilter !== 'X PROG') return;
                } else if (currentHabilitadoFilter === 'PROG 1T') {
                    if (habilValNormFilter !== 'PROG 1T') return;
                } else if (currentHabilitadoFilter === 'PROG 2T') {
                    if (habilValNormFilter !== 'PROG 2T') return;
                } else if (currentHabilitadoFilter === 'PROG 3T') {
                    if (habilValNormFilter !== 'PROG 3T') return;
                }
                
                // Aplicar filtro de encabezado si está configurado (solo en X PROG)
                if (habilitadoHeaderFilter && currentHabilitadoFilter === 'X PROG') {
                    let fieldValue = '';
                    
                    switch(habilitadoHeaderFilter.field) {
                        case 'P':
                            fieldValue = (getVal(row, 'P') || '').toString().trim().toUpperCase();
                            break;
                        case 'HOD':
                            fieldValue = (formatValue(getVal(row, 'HOD'), 'date') || '').toString().trim().toUpperCase();
                            break;
                        case 'F.ING.COST':
                            const rawFIng = getVal(row, 'F.ING.COST');
                            const dateValue = convertToDateInputFormat(rawFIng);
                            fieldValue = (formatDateShortFromInput(dateValue) || '').toString().trim().toUpperCase();
                            break;
                        case 'STATUS':
                            // STATUS es un valor CALCULADO basado en RUTA TELA y estados
                            const rutaTela = (getVal(row, 'RUTA TELA') || getVal(row, 'RUTA_TELA') || getVal(row, 'RUTA') || '').toString().toUpperCase().trim();
                            const estadoCorte = (getVal(row, 'estado_corte') || getVal(row, 'ESTADO_CORTE') || '').toString().toUpperCase().trim();
                            const estadoBloqueo = (getVal(row, 'estado_bloqueo') || getVal(row, 'ESTADO_BLOQUEO') || '').toString().toUpperCase().trim();
                            const estadoLavada = (getVal(row, 'estado_lavada') || getVal(row, 'ESTADO_LAVADA') || '').toString().toUpperCase().trim();
                            
                            if (rutaTela === 'ACABADA') {
                                if (estadoCorte === '' || estadoCorte === 'X PROG') {
                                    fieldValue = 'X CORTAR';
                                } else if (estadoCorte === 'PROG') {
                                    fieldValue = 'PROC CORTE';
                                } else if (estadoCorte === 'OK') {
                                    if (evNorm === '' || evNorm === 'X PROG') {
                                        fieldValue = 'X ENM';
                                    } else if (evNorm === 'OK ENM' || evNorm === 'OK PAQUETEO') {
                                        fieldValue = 'X HAB';
                                    } else {
                                        fieldValue = 'X ENM';
                                    }
                                }
                            } else if (rutaTela === 'LAVADA') {
                                if (estadoBloqueo === '' || estadoBloqueo === 'X PROG') {
                                    fieldValue = 'X BLOQ';
                                } else if (estadoBloqueo === 'PROG') {
                                    fieldValue = 'X BLOQ';
                                } else if (estadoBloqueo === 'OK') {
                                    if (estadoLavada !== 'OK') {
                                        fieldValue = 'X LAVAR';
                                    } else {
                                        if (estadoCorte === '' || estadoCorte === 'X PROG') {
                                            fieldValue = 'X CORTAR';
                                        } else if (estadoCorte === 'PROG 1T' || estadoCorte === 'PROG 2T' || estadoCorte === 'PROG 3T') {
                                            fieldValue = 'PROC CORTE';
                                        } else if (estadoCorte === 'OK') {
                                            if (evNorm === 'OK ENM' || evNorm === 'OK PAQUETEO') {
                                                fieldValue = 'X HAB';
                                            } else {
                                                fieldValue = 'X ENM';
                                            }
                                        }
                                    }
                                }
                            }
                            break;
                        case 'CLIENTE':
                            fieldValue = (normalizeClientName(getVal(row, 'CLIENTE')) || '').toString().trim().toUpperCase();
                            break;
                        case 'OP-PTDA':
                            const opTela = getVal(row, 'OP TELA') || getVal(row, 'OP') || '';
                            const partida = getVal(row, 'PARTIDA') || getVal(row, 'CORTE') || '';
                            fieldValue = `${opTela}-${partida}`.toUpperCase();
                            break;
                        case 'OC':
                            const opVal = getVal(row, 'OP') || '';
                            const corteVal = getVal(row, 'CORTE') || '';
                            fieldValue = `${opVal}-${corteVal}`.toUpperCase();
                            break;
                        case 'COLOR':
                            fieldValue = (getVal(row, 'COLOR') || '').toString().trim().toUpperCase();
                            break;
                    }
                    
                    // Si el valor no contiene el filtro, saltarlo
                    if (fieldValue.indexOf(habilitadoHeaderFilter.value) === -1) return;
                }
                    
                // Si estamos en PROG 1T/2T/3T, agrupar por TRSF
                    if (isProgSubtab) {
                        const currentTrsfGroup = getTrsfGroupValue(row);
                        
                        // Si cambia el grupo de TRSF, insertar fila de encabezado
                        if (currentTrsfGroup !== lastTrsfGroup) {
                            const headerRow = document.createElement('tr');
                            headerRow.style.backgroundColor = '#FFE699';
                            headerRow.style.color = '#1e40af';
                            headerRow.style.fontWeight = '700';
                            headerRow.style.fontSize = '13px';
                            
                            // Calcular colspan: 16 columnas en Habilitado
                            const colspan = '16';
                            
                            // Calcular suma de PDS para este grupo de TRSF
                            let pdsTrsf = 0;
                            try {
                                pdsTrsf = validIndices.reduce((acc, idx2) => {
                                    try {
                                        const r = rawData[idx2];
                                        let ev2 = '';
                                        if (idxEv !== -1 && r && r[idxEv] !== undefined) ev2 = r[idxEv];
                                        else ev2 = getVal(r, 'estado_enumerado') || '';
                                        const evNorm2 = (ev2 || '').toString().toUpperCase().trim();
                                        
                                        if ((evNorm2 === 'OK ENM' || evNorm2 === 'OK S/ENM')) {
                                            const habilVal2 = getVal(r, 'estado_habilitado') || '';
                                            const habilNorm2 = (habilVal2 || '').toString().toUpperCase().trim();
                                            
                                            // Filtrar según el sub-tab actual
                                            let matchesFilter = false;
                                            if (currentHabilitadoFilter === 'PROG 1T' && habilNorm2 === 'PROG 1T') matchesFilter = true;
                                            else if (currentHabilitadoFilter === 'PROG 2T' && habilNorm2 === 'PROG 2T') matchesFilter = true;
                                            else if (currentHabilitadoFilter === 'PROG 3T' && habilNorm2 === 'PROG 3T') matchesFilter = true;
                                            
                                            if (matchesFilter && getTrsfGroupValue(r) === currentTrsfGroup) {
                                                const pv = parseFloat(getVal(r, 'PDS GIRADAS') || 0) || 0;
                                                return acc + pv;
                                            }
                                        }
                                    } catch(e) {}
                                    return acc;
                                }, 0);
                            } catch (e) { pdsTrsf = 0; }

                            const groupLabel = currentTrsfGroup === 'Pza' ? 'LLEVA TRANSFER EN PIEZA' : 'No lleva transfer en pieza';
                            headerRow.innerHTML = `<td colspan="${colspan}" style="padding: 8px 12px; text-align: left;">
                                <i class="ph ph-package" style="margin-right: 8px;"></i>${groupLabel} [${formatThousands(pdsTrsf,0)}pds]
                            </td>`;
                            tbody.appendChild(headerRow);
                            
                            lastTrsfGroup = currentTrsfGroup;
                            lastOpPtda = null; // Reiniciar al cambiar de grupo
                            currentRowGroup = 'a'; // Reiniciar alternancia de colores
                        }
                        
                        // Alternar color de filas dentro del mismo grupo de TRSF
                        const opTela = String(row[colMap["OP TELA"]] || "").trim();
                        const partida = String(row[colMap["PARTIDA"]] || "").trim();
                        const currentOpPtda = `${opTela}-${partida}`;
                        
                        if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                            currentRowGroup = (currentRowGroup === 'a') ? 'b' : 'a';
                        }
                        lastOpPtda = currentOpPtda;
                    }
                    
                    count++;
                    const tr = document.createElement('tr');

                    // COLUMNA P - Prioridad (mostrar como texto en X PROG)
                    const pCell = document.createElement('td');
                    if (currentHabilitadoFilter === 'X PROG') {
                        const pVal = (getVal(row, 'P') || '').toString().trim();
                        pCell.innerHTML = pVal;
                    } else {
                        pCell.innerHTML = createPrioridadCell(i, row).replace(/<td.*?>|<\/td>/g, '');
                    }

                    // HOD
                    const fDesp = formatValue(getVal(row, 'HOD'), 'date') || '';

                    // F.ING.COST -> mostrar como texto en X PROG (no editable), sino date-picker
                    const rawFIng = getVal(row, 'F.ING.COST');
                    const dateValue = convertToDateInputFormat(rawFIng);
                    let fIngHtml = '';
                    if (currentHabilitadoFilter === 'X PROG') {
                        fIngHtml = `<td class="date-cell">${formatValue(getVal(row, 'F.ING.COST') || getVal(row, 'F ING COST') || '', 'date')}</td>`;
                    } else {
                        fIngHtml = `<td class="date-cell"><input type="date" class="short-year" value="${dateValue}" onchange="handleDateChange(this, ${i}, 'F.ING.COST')"><span class="date-yy">${formatDateShortFromInput(dateValue) || 'mm/dd/aaaa'}</span></td>`;
                    }

                    // CLIENTE
                    const cliente = normalizeClientName(getVal(row, 'CLIENTE')) || '';

                    // OC (concatenado OP - CORTE) con hipervínculo/abrir modal
                    const op = getVal(row, 'OP') || '';
                    const corte = getVal(row, 'CORTE') || '';
                    const oc = (op || corte) ? `${op}-${corte}` : '';
                    const ocHtml = `<td class="op-cell" title="${oc}"><span class="oc-link" onclick="abrirModalOC(${i});">${oc}</span></td>`;

                    // COLOR
                    const color = abbreviateHeather(getVal(row, 'COLOR')) || '';

                    // PDS (PDS GIRADAS)
                    const pdsRaw = parseFloat(getVal(row, 'PDS GIRADAS')) || 0;
                    const pdsStr = formatThousands(pdsRaw, 0);

                    // PRENDA
                    const prenda = normalizePrenda(getVal(row, 'PRENDA')) || '';

                    // TIPO CERTIFICADO
                    const tipoCert = normalizeTipoCert(getVal(row, 'TIPO CERTIFICADO')) || '';

                    // RIB -> normalizar y mostrar como pill según valor
                    const rawRib = getVal(row, 'RIB') || '';
                    const estadoRib = getVal(row, 'estado_rib') || getVal(row, 'ESTADO_RIB') || '';
                    const ribDisplay = (estadoRib || rawRib || '').toString();
                    const ribNorm = (ribDisplay || '').toUpperCase().trim();
                    let ribHtml = '';
                    if (ribNorm === 'NO LLEVA') {
                        // mostrar X con pill de texto rojo
                        ribHtml = `<td style="text-align:center;" title="NO LLEVA"><span class="pill pill-x">X</span></td>`;
                    } else if (ribNorm === 'NO PASO' || ribNorm === 'EN LAV' || (ribNorm.indexOf('LAV') !== -1 && ribNorm.indexOf('REP') !== -1)) {
                        // mostrar con fondo rojo oscuro y letra blanca
                        ribHtml = `<td style="text-align:center;" title="${ribDisplay}"><span class="pill pill-rib-alert">${ribDisplay}</span></td>`;
                    } else if (ribNorm === 'EN CORTE') {
                        // fondo verde claro
                        ribHtml = `<td style="text-align:center;" title="${ribDisplay}"><span class="pill pill-pda">${ribDisplay}</span></td>`;
                    } else if (ribNorm === 'EN HAB') {
                        // fondo azul claro
                        ribHtml = `<td style="text-align:center;" title="${ribDisplay}"><span class="pill pill-pza">${ribDisplay}</span></td>`;
                    } else {
                        ribHtml = `<td style="text-align:center;" title="${ribDisplay}">${ribDisplay}</td>`;
                    }

                    // BLOQUES? -> normalizar según estado_bloques y estado_corte_bloques
                    const estadoCorteBloques = getVal(row, 'estado_corte_bloques') || getVal(row, 'ESTADO_CORTE_BLOQUES') || getVal(row, 'ESTADO CORTE BLOQUES') || '';
                    const estadoBloques = getVal(row, 'ESTADO BLOQUES') || getVal(row, 'ESTADO_BLOQUES') || getVal(row, 'estado_bloques') || '';
                    const estadoBloquesNorm = (estadoBloques || '').toString().toUpperCase().trim();
                    const estadoCorteBloquesNorm = (estadoCorteBloques || '').toString().toUpperCase().trim();
                    let bloqHtml = '';
                    try {
                        if (estadoBloquesNorm === 'NO LLEVA') {
                            // X con pill rojo (texto rojo)
                            bloqHtml = `<td style="text-align:center;" title="NO LLEVA"><span class="pill pill-x">X</span></td>`;
                        } else if (estadoBloquesNorm.indexOf('OK CORTE') !== -1 || estadoBloquesNorm === 'OK CORTE' || estadoBloquesNorm === 'OK CORTE') {
                            // Evaluar estado_corte_bloques
                            if (!estadoCorteBloquesNorm) {
                                // blank -> X PROG (fondo verde claro)
                                bloqHtml = `<td style="text-align:center;" title="X PROG"><span class="pill pill-pda">X PROG</span></td>`;
                            } else if (estadoCorteBloquesNorm.indexOf('PROG') !== -1) {
                                // PROG -> blue light
                                bloqHtml = `<td style="text-align:center;" title="PROG"><span class="pill pill-pza">PROG</span></td>`;
                            } else if (estadoCorteBloquesNorm.indexOf('OK') !== -1) {
                                // OK -> blue dark
                                bloqHtml = `<td style="text-align:center;" title="OK"><span class="pill pill-ok-dark">OK</span></td>`;
                            } else {
                                bloqHtml = `<td style="text-align:center;" title="${estadoCorteBloques}">${estadoCorteBloques}</td>`;
                            }
                        } else {
                            // fallback: mostrar estadoBloques tal cual
                            bloqHtml = `<td style="text-align:center;" title="${estadoBloques}">${estadoBloques}</td>`;
                        }
                    } catch(e) { bloqHtml = `<td style="text-align:center;" title="${estadoBloques}">${estadoBloques}</td>`; }

                    // COLL o TAP? -> estado_coll_tap (mostrar pill)
                    const collVal = getVal(row, 'estado_coll_tap') || getVal(row, 'ESTADO_COLL_TAP') || getVal(row, 'ESTADO COLL TAP') || '';
                    const collNorm = (collVal || '').toString().toUpperCase().trim();
                    // SI "estado_coll_tap" = "NO LLEVA" -> mostrar 'X' con pill rojo oscuro
                    // cualquier otro dato -> mostrar valor dentro de pill azul claro
                    let collHtml = '';
                    try {
                        if (collNorm === 'NO LLEVA') {
                            collHtml = `<td style="text-align:center;" title="NO LLEVA"><span class="pill pill-x">X</span></td>`;
                        } else if (collVal !== '' && collVal !== null && collVal !== undefined) {
                            collHtml = `<td style="text-align:center;" title="${collVal}"><span class="pill pill-pza">${String(collVal).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span></td>`;
                        } else {
                            collHtml = `<td style="text-align:center;" title=""><span class="pill">-</span></td>`;
                        }
                    } catch(e) { collHtml = `<td style="text-align:center;" title="${collVal}">${collVal}</td>`; }

                    // TRSF -> lógica basada en tipo-transfer, n.transfxpda y estado_transfer
                    const tipoTransfer = getVal(row, 'tipo-transfer') || getVal(row, 'TIPO-TRANSFER') || getVal(row, 'tipo_transfer') || '';
                    const rawNTrans = getVal(row, 'n.transfxpda') || getVal(row, 'N.TRANSFXPDA') || getVal(row, 'n_transfxpda') || '';
                    const estadoTransfer = getVal(row, 'estado_transfer') || getVal(row, 'ESTADO_TRANSFER') || '';
                    const tipoTransNorm = (tipoTransfer || '').toString().toUpperCase().trim();
                    const nTransNorm = (rawNTrans !== undefined && rawNTrans !== null) ? String(rawNTrans).trim() : '';
                    const estadoTransNorm = (estadoTransfer || '').toString().trim();
                    
                    let trsfDisplay = '';
                    // Si tipo-transfer = "NO LLEVA" o n.transfxpda = "NO LLEVA" → X
                    if (tipoTransNorm === 'NO LLEVA' || nTransNorm.toUpperCase() === 'NO LLEVA') {
                        trsfDisplay = 'X';
                    } else if (tipoTransNorm === 'EN PIEZA' && !isNaN(parseInt(nTransNorm)) && nTransNorm !== '') {
                        // tipo-transfer = "En pieza" y n.transfxpda es número → Pza(xN)-estado_transfer
                        const num = parseInt(nTransNorm);
                        const estado = estadoTransNorm !== '' ? estadoTransNorm : 'X PROG';
                        trsfDisplay = `Pza(x${num})-${estado}`;
                    } else if (tipoTransNorm === 'EN PRENDA' && !isNaN(parseInt(nTransNorm)) && nTransNorm !== '') {
                        // tipo-transfer = "En prenda" y n.transfxpda es número → PDA[xN]-estado_transfer
                        const num = parseInt(nTransNorm);
                        const estado = estadoTransNorm !== '' ? estadoTransNorm : 'X PROG';
                        trsfDisplay = `PDA[x${num}]-${estado}`;
                    } else {
                        // Caso por defecto: mostrar el valor original
                        trsfDisplay = nTransNorm;
                    }
                    
                    let trsfHtml = '';
                    const trsfUpper = (trsfDisplay || '').toString().toUpperCase();
                    if (trsfDisplay === 'X') {
                        trsfHtml = `<td style="text-align:center;" title="NO LLEVA"><span class="pill pill-x">X</span></td>`;
                    } else if (trsfUpper.indexOf('PZA') !== -1) {
                        trsfHtml = `<td style="text-align:center;" title="${trsfDisplay}"><span class="pill pill-pza">${trsfDisplay}</span></td>`;
                    } else if (trsfUpper.indexOf('PDA') !== -1) {
                        trsfHtml = `<td style="text-align:center;" title="${trsfDisplay}"><span class="pill pill-pda">${trsfDisplay}</span></td>`;
                    } else {
                        trsfHtml = `<td style="text-align:center;" title="${trsfDisplay}">${trsfDisplay}</td>`;
                    }

                    // estado_bordado / estado_estampado / estado_habilitado (mostrar badge NO LLEVA si corresponde)
                    const bordVal = getVal(row, 'estado_bordado') || getVal(row, 'ESTADO_BORDADO') || '';
                    const estampVal = getVal(row, 'estado_estampado') || getVal(row, 'ESTADO_ESTAMPADO') || '';
                    const habilVal = getVal(row, 'estado_habilitado') || getVal(row, 'ESTADO_HABILITADO') || '';

                    // Normalizar estado_bordado según estado_bordado y n.BDxpda
                    const nbdRaw = getVal(row, 'n.BDxpda') || getVal(row, 'n.bordadoxpda') || getVal(row, 'N.BDXPDA') || '';
                    const nbdNorm = (nbdRaw || '').toString().toUpperCase().trim();
                    const bordValNorm = (bordVal || '').toString().toUpperCase().trim();
                    let bordHtml = '';
                    try {
                        // Si estado_bordado = NO LLEVA o n.BDxpda = NO LLEVA -> X (pill rojo)
                        if (bordValNorm === 'NO LLEVA' || nbdNorm === 'NO LLEVA') {
                            bordHtml = `<td style="text-align:center;" title="NO LLEVA"><span class="pill pill-x">X</span></td>`;
                        // Si estado_bordado = PROG -> PROG (pill verde claro)
                        } else if (bordValNorm === 'PROG') {
                            bordHtml = `<td style="text-align:center;" title="PROG"><span class="pill pill-pda">PROG</span></td>`;
                        // Si estado_bordado está vacío y n.BDxpda tiene número -> X PROG (pill verde claro)
                        } else if ((bordValNorm === '' || bordValNorm === undefined) && nbdNorm !== '' && !isNaN(parseInt(nbdNorm))) {
                            bordHtml = `<td style="text-align:center;" title="X PROG"><span class="pill pill-pda">X PROG</span></td>`;
                        // Si estado_bordado = OK -> OK (pill azul claro)
                        } else if (bordValNorm === 'OK') {
                            bordHtml = `<td style="text-align:center;" title="OK"><span class="pill pill-pza">OK</span></td>`;
                        } else {
                            bordHtml = `<td style="text-align:center;" title="${bordVal}">${bordVal}</td>`;
                        }
                    } catch(e) { bordHtml = `<td style="text-align:center;" title="${bordVal}">${bordVal}</td>`; }

                    // Revisar n.ESTAMPxpda (variantes) y forzar NO LLEVA en estado_estampado si aplica
                    const nestRaw = getVal(row, 'n.ESTAMPxpda') || getVal(row, 'n.ESTAMP xpda') || getVal(row, 'N.ESTAMPXPDA') || getVal(row, 'n.ESTAMPxpda ') || '';
                    const nestNorm = (nestRaw || '').toString().toUpperCase().trim();

                    let estampHtml = '';
                    const estampValNorm = (estampVal || '').toString().toUpperCase().trim();
                    try {
                        // Si estado_estampado = NO LLEVA o n.ESTAMPxpda = NO LLEVA -> X (pill rojo)
                        if (nestNorm.indexOf('NO LLEVA') !== -1 || estampValNorm === 'NO LLEVA') {
                            estampHtml = `<td style="text-align:center;" title="NO LLEVA"><span class="pill pill-x">X</span></td>`;
                        // Si estado_estampado = PROG -> PROG (pill verde claro)
                        } else if (estampValNorm === 'PROG') {
                            estampHtml = `<td style="text-align:center;" title="PROG"><span class="pill pill-pda">PROG</span></td>`;
                        // Si estado_estampado está vacío y n.ESTAMPxpda tiene número -> X PROG (pill verde claro)
                        } else if ((estampValNorm === '' || estampValNorm === undefined) && nestNorm !== '' && !isNaN(parseInt(nestNorm))) {
                            estampHtml = `<td style="text-align:center;" title="X PROG"><span class="pill pill-pda">X PROG</span></td>`;
                        // Si estado_estampado = OK -> OK (pill azul claro)
                        } else if (estampValNorm === 'OK') {
                            estampHtml = `<td style="text-align:center;" title="OK"><span class="pill pill-pza">OK</span></td>`;
                        } else {
                            estampHtml = `<td style="text-align:center;" title="${estampVal}">${estampVal}</td>`;
                        }
                    } catch(e) { estampHtml = `<td style="text-align:center;" title="${estampVal}">${estampVal}</td>`; }
                    // estado_habilitado -> select editable con opciones X PROG, PROG 1T, PROG 2T, PROG 3T (y OK para PROG 1T/2T/3T)
                    const habilValNorm = (habilVal || '').toString().toUpperCase().trim();
                    let habilClass = '';
                    if (habilValNorm === 'PROG 1T' || habilValNorm === 'PROG 2T' || habilValNorm === 'PROG 3T') habilClass = 'sel-PROG';
                    if (habilValNorm === 'OK') habilClass = 'sel-OK';
                    
                    // Mostrar opción OK solo en sub-tabs PROG 1T, PROG 2T, PROG 3T
                    const showOkOption = (currentHabilitadoFilter === 'PROG 1T' || currentHabilitadoFilter === 'PROG 2T' || currentHabilitadoFilter === 'PROG 3T');
                    
                    let habilHtml = '';
                    if (currentHabilitadoFilter === 'X PROG') {
                        habilHtml = `<td style="text-align:center;">${habilValNorm}</td>`;
                    } else {
                        habilHtml = `<td>
                            <select class="table-select ${habilClass}" onchange="if(this.value === 'OK') { abrirModalIngresoCostura(${i}); this.value = '${habilValNorm}'; } else { updateRow(${i}, 'estado_habilitado', this.value, this); setTimeout(renderHabilitado, 300); }">
                                <option value="X PROG" ${habilValNorm === 'X PROG' || habilValNorm === '' ? 'selected' : ''}>X PROG</option>
                                <option value="PROG 1T" ${habilValNorm === 'PROG 1T' ? 'selected' : ''}>PROG 1T</option>
                                <option value="PROG 2T" ${habilValNorm === 'PROG 2T' ? 'selected' : ''}>PROG 2T</option>
                                <option value="PROG 3T" ${habilValNorm === 'PROG 3T' ? 'selected' : ''}>PROG 3T</option>
                                ${showOkOption ? `<option value="OK" ${habilValNorm === 'OK' ? 'selected' : ''}>OK</option>` : ''}
                            </select>
                        </td>`;
                    }

                    // STATUS - Columna calculada según RUTA TELA y estados
                    const rutaTela = (getVal(row, 'RUTA TELA') || getVal(row, 'RUTA_TELA') || getVal(row, 'RUTA') || '').toString().toUpperCase().trim();
                    const estadoCorte = (getVal(row, 'estado_corte') || getVal(row, 'ESTADO_CORTE') || '').toString().toUpperCase().trim();
                    const estadoBloqueo = (getVal(row, 'estado_bloqueo') || getVal(row, 'ESTADO_BLOQUEO') || '').toString().toUpperCase().trim();
                    const estadoLavada = (getVal(row, 'estado_lavada') || getVal(row, 'ESTADO_LAVADA') || '').toString().toUpperCase().trim();
                    
                    let statusValue = '';
                    
                    if (rutaTela === 'ACABADA') {
                        // RUTA TELA = ACABADA
                        if (estadoCorte === '' || estadoCorte === 'X PROG') {
                            statusValue = 'x cortar';
                        } else if (estadoCorte === 'PROG') {
                            statusValue = 'Proc Corte';
                        } else if (estadoCorte === 'OK') {
                            // Verificar estado_enumerado
                            if (evNorm === '' || evNorm === 'X PROG') {
                                statusValue = 'x enm';
                            } else if (evNorm === 'OK ENM' || evNorm === 'OK PAQUETEO') {
                                statusValue = 'x Hab';
                            } else {
                                statusValue = 'x enm';
                            }
                        }
                    } else if (rutaTela === 'LAVADA') {
                        // RUTA TELA = LAVADA
                        if (estadoBloqueo === '' || estadoBloqueo === 'X PROG') {
                            statusValue = 'x bloq';
                        } else if (estadoBloqueo === 'PROG') {
                            statusValue = 'x Bloq';
                        } else if (estadoBloqueo === 'OK') {
                            // Verificar estado_lavada
                            if (estadoLavada !== 'OK') {
                                statusValue = 'x lavar';
                            } else {
                                // estado_lavada = OK
                                if (estadoCorte === '' || estadoCorte === 'X PROG') {
                                    statusValue = 'x cortar';
                                } else if (estadoCorte === 'PROG 1T' || estadoCorte === 'PROG 2T' || estadoCorte === 'PROG 3T') {
                                    statusValue = 'Proc Corte';
                                } else if (estadoCorte === 'OK') {
                                    // Verificar estado_enumerado
                                    if (evNorm === 'OK ENM' || evNorm === 'OK PAQUETEO') {
                                        statusValue = 'x Hab';
                                    } else {
                                        statusValue = 'x enm';
                                    }
                                }
                            }
                        }
                    }
                    
                    // Aplicar estilo según el valor de STATUS
                    let statusHtml = '';
                    const statusUpper = statusValue.toUpperCase();
                    if (statusUpper.indexOf('X CORTAR') !== -1) {
                        statusHtml = `<td title="${statusValue}"><span class="pill pill-pda">${statusValue}</span></td>`;
                    } else if (statusUpper.indexOf('PROC CORTE') !== -1) {
                        statusHtml = `<td title="${statusValue}"><span class="pill pill-pza">${statusValue}</span></td>`;
                    } else if (statusUpper.indexOf('X ENM') !== -1) {
                        statusHtml = `<td title="${statusValue}"><span class="pill pill-pda">${statusValue}</span></td>`;
                    } else if (statusUpper.indexOf('X HAB') !== -1) {
                        statusHtml = `<td title="${statusValue}"><span class="pill pill-ok-dark">${statusValue}</span></td>`;
                    } else if (statusUpper.indexOf('X BLOQ') !== -1) {
                        statusHtml = `<td title="${statusValue}"><span class="pill pill-pda">${statusValue}</span></td>`;
                    } else if (statusUpper.indexOf('X LAVAR') !== -1) {
                        statusHtml = `<td title="${statusValue}"><span class="pill pill-pda">${statusValue}</span></td>`;
                    } else {
                        statusHtml = `<td title="${statusValue}">${statusValue}</td>`;
                    }

                    tr.innerHTML = `
                        <td class="p-cell">${pCell.innerHTML}</td>
                        <td class="date-cell">${fDesp}</td>
                        ${fIngHtml}
                        <td style="text-align:center;" title="${statusValue}">${statusHtml.replace(/<td[^>]*>|<\/td>/g, '')}</td>
                        <td style="text-align:center;" title="${cliente}">${cliente}</td>
                        ${ocHtml}
                        <td title="${color}">${color}</td>
                        <td class="kg-cell" style="text-align:center;">${pdsStr}</td>
                        <td title="${prenda}">${prenda}</td>
                        <td title="${tipoCert}">${tipoCert}</td>
                        ${ribHtml}
                        ${bloqHtml}
                        ${collHtml}
                        ${trsfHtml}
                        ${bordHtml}
                        ${estampHtml}
                        ${habilHtml}
                    `;

                    // Agregar clase de grupo para sombreado alternado
                    // En PROG 1T/2T/3T, usar currentRowGroup que se alterna por OP-PTDA dentro del grupo TRSF
                    if (isProgSubtab) {
                        tr.classList.add(`group-${currentRowGroup}`);
                    } else {
                        // En X PROG, alternar por OP-PTDA
                        const opTela = String(row[colMap["OP TELA"]] || "").trim();
                        const partida = String(row[colMap["PARTIDA"]] || "").trim();
                        const currentOpPtda = `${opTela}-${partida}`;
                        if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                            currentRowGroup = (currentRowGroup === 'a') ? 'b' : 'a';
                        }
                        lastOpPtda = currentOpPtda;
                        tr.classList.add(`group-${currentRowGroup}`);
                    }
                    
                    // Si P = 1, aplicar color rojo claro y transparente
                    const idxP = findHeaderIndexCaseInsensitive('P');
                    if (idxP !== -1) {
                        const pValue = String(row[idxP] || '').trim();
                        if (pValue === '1') {
                            tr.classList.add('priority-1');
                        }
                    }
                    
                    tbody.appendChild(tr);
            });
            document.getElementById('count-habilitado').innerText = count;
            
            // Actualizar badges de PDS por sub-tab
            try { document.getElementById('habilitado-pds-xprog').innerText = `[${formatThousands(pdsXProg, 0)}pds]`; } catch(e){}
            try { document.getElementById('habilitado-pds-1t').innerText = `[${formatThousands(pds1T, 0)}pds]`; } catch(e){}
            try { document.getElementById('habilitado-pds-2t').innerText = `[${formatThousands(pds2T, 0)}pds]`; } catch(e){}
            try { document.getElementById('habilitado-pds-3t').innerText = `[${formatThousands(pds3T, 0)}pds]`; } catch(e){}
            
            // Inicializar eventos de los selectores de fecha
            initializeDateInputs();
            
            // Agregar event listeners para click derecho en los encabezados (solo en X PROG)
            if (currentHabilitadoFilter === 'X PROG') {
                initializeHabilitadoHeaderContextMenus();
            }
        }
        
        function initializeHabilitadoHeaderContextMenus() {
            const allowedFields = ['P', 'HOD', 'F.ING.COST', 'STATUS', 'CLIENTE', 'OP-PTDA', 'OC', 'COLOR'];
            
            const thead = document.querySelector('#view-habilitado table thead');
            if (!thead) return;
            
            const ths = thead.querySelectorAll('th');
            ths.forEach(th => {
                th.oncontextmenu = function(event) {
                    // Obtener el texto del encabezado
                    let headerText = th.textContent.trim();
                    
                    // Limpiar el texto del encabezado (puede tener espacios extra o caracteres especiales)
                    headerText = headerText.replace(/\s+/g, ' ').trim();
                    
                    // Verificar si es un campo permitido
                    let matchedField = null;
                    for (let field of allowedFields) {
                        if (headerText.indexOf(field) === 0 || field.indexOf(headerText) === 0) {
                            matchedField = field;
                            break;
                        }
                    }
                    
                    if (matchedField) {
                        showHabilitadoContextMenu(event, matchedField);
                    }
                };
            });
        }

        // Función para formatear fechas al estilo: 04/Nov/25, 13/Ene/26, etc.
        function formatDateCustom(val) {
            // Meses abreviados en español (primeras 3 letras capitalizadas)
            const mesesEs = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 
                            'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
            
            // Caso 1: Si es un string tipo "Date(2026,1,13)" extraer los números
            if (typeof val === 'string' && val.includes('Date(')) {
                const match = val.match(/Date\((\d+),(\d+),(\d+)\)/);
                if (match) {
                    const month = parseInt(match[2]); // JavaScript usa 0-11 para meses
                    const day = String(match[3]).padStart(2, '0');
                    
                    return `${day}/${mesesEs[month]}`;
                }
            }
            
            // Caso 2: Si es un número de serie de Excel (número > 30000)
            if (typeof val === 'number' && val > 30000) {
                const date = new Date(Math.round((val - 25569) * 86400 * 1000));
                const day = String(date.getDate()).padStart(2, '0');
                const month = mesesEs[date.getMonth()];
                
                return `${day}/${month}`;
            }
            
            return val;
        }

        function formatValue(val, type) {
            if (type === 'date') {
                return formatDateCustom(val);
            }
            return val;
        }
        
        // Formatea números con separador de miles (reutilizable)
        function formatThousands(val, decimals = 0) {
            if (val === null || val === undefined || isNaN(val)) return val;
            if (decimals > 0) {
                return Number(val).toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
            }
            return Math.round(val).toLocaleString('en-US');
        }

        // Helper: indica si estamos en la vista Corte y en un sub-tab PROG (1T/2T/3T)
        function isCorteProgSubtab() {
            try {
                return document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active')
                    && currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG';
            } catch (e) { return false; }
        }
        
        // Helper: indica si estamos en la vista Enumerado
        function isEnumeradoView() {
            try {
                return document.getElementById('view-enumerado') && document.getElementById('view-enumerado').classList.contains('active');
            } catch (e) { return false; }
        }

        // Helper: indica si estamos en la vista Habilitado
        function isHabilitadoView() {
            try {
                return document.getElementById('view-habilitado') && document.getElementById('view-habilitado').classList.contains('active');
            } catch (e) { return false; }
        }
        
        function normalizeClientName(clientName) {
            if (!clientName) return "";
            const name = clientName.toString().toUpperCase();
            // Normalizaciones rápidas
            if (name.includes("LACOSTE")) return "LAC";
            if (name.includes("ATHLETA, INC.")) return "ATH";
            if (name.includes("BANANA REPUBLIC, LLC")) return "BNN";
            if (name.includes("THEORY LLC,")) return "THE";
            if (name.includes("DISH & DUER")) return "DDU";
            if (name.includes("SKECHERS PERFORMANCE")) return "SKE";
            if (name.includes("LULULEMON ATHLETICA CANADA INC")) return "LLL";
            if (name.includes("AM RETAIL S.A.C.")) return "AMR";
            return clientName;
        }

        // Normalización específica para la vista Transfer -> Asignar #Trf
        function normalizeClientForTransfer(clientName) {
            if (!clientName && clientName !== 0) return '';
            const s = String(clientName).trim();
            const up = s.toUpperCase();
            if (up.includes('LACOSTE - AMERICAS OPERATIONS PLATFORM')) return 'LACOSTE';
            if (up.includes('LULULEMON ATHLETICA CANADA INC')) return 'LULULEMON';
            if (up.includes('SKECHERS PERFORMANCE')) return 'SKECHERS';
            if (up.includes('ATHLETA, INC.')) return 'ATHLETA';
            if (up.includes('BANANA REPUBLIC, LLC')) return 'BANANA';
            if (up.includes('THEORY LLC,')) return 'THEORY';
            // Normalizaciones adicionales comunes
            if (up.includes('LACOSTE')) return 'LACOSTE';
            if (up.includes('LULULEMON')) return 'LULULEMON';
            if (up.includes('SKECHERS')) return 'SKECHERS';
            if (up.includes('ATHLETA')) return 'ATHLETA';
            if (up.includes('BANANA')) return 'BANANA';
            if (up.includes('THEORY')) return 'THEORY';
            return s;
        }

        // Abreviar 'HEATHER' o 'HEATHERED' -> 'HTR' en nombres de color (case-insensitive)
        function abbreviateHeather(colorName) {
            if (!colorName && colorName !== 0) return colorName;
            try {
                // Reemplaza 'HEATHER' o 'HEATHERED' por 'HTR', p. ej. 'HEATHER GREY' -> 'HTR GREY'
                return String(colorName).replace(/\bHEATHER(?:ED)?\b/ig, 'HTR');
            } catch (e) {
                return colorName;
            }
        }

        // Normaliza la descripción de PRENDA: elimina 'T-SHIRT' y quita '/' (ej. 'T-SHIRT M/L' -> 'ML')
        function normalizePrenda(prenda) {
            if (!prenda && prenda !== 0) return prenda || "";
            try {
                let s = String(prenda).toUpperCase().trim();
                // Eliminar variantes de T-SHIRT (T-SHIRT, T SHIRT, TSHIRT)
                s = s.replace(/\bT[- ]?SHIRT\b\s*/ig, '');
                // Si al eliminar 'T-SHIRT' queda vacío, devolver el valor original (mostrar 'T-SHIRT')
                if (s === '') return String(prenda).toUpperCase().trim();
                // Quitar espacios innecesarios
                s = s.replace(/\s+/g, '');
                // Reemplazar barras S/M -> SM, M/L -> ML
                s = s.replace(/\//g, '');
                return s;
            } catch (e) {
                return prenda;
            }
        }

        // Normaliza el campo TIPO CERT.: elimina espacios alrededor de '|' -> 'A | B | C' -> 'A|B|C'
        function normalizeTipoCert(tipoCert) {
            if (tipoCert === undefined || tipoCert === null) return '';
            try {
                return String(tipoCert).replace(/\s*\|\s*/g, '|').trim();
            } catch (e) { return tipoCert; }
        }

        function getVal(row, colName) {
            if (!colName) return "";
            // Try direct map first
            let idx = colMap[colName];
            if (idx !== undefined && idx !== -1) return row[idx] || "";

            // Try common variants: lower, upper, strip non-alphanum
            const variants = [
                colName,
                colName.toLowerCase(),
                colName.toUpperCase(),
                colName.replace(/[^a-zA-Z0-9]/g, ''),
                colName.toLowerCase().replace(/[^a-z0-9]/g, ''),
                colName.toUpperCase().replace(/[^A-Z0-9]/g, '')
            ];
            for (let k of variants) {
                idx = colMap[k];
                if (idx !== undefined && idx !== -1) return row[idx] || "";
            }

            // Fallback: try to find header index dynamically
            try {
                const found = findHeaderIndexCaseInsensitive(colName);
                if (found !== -1) return row[found] || "";
            } catch (e) {}

            return "";
        }

        function renderRutaBadge(rutaVal, row = null, rowIndex = null) {
            const rutaKey = String(rutaVal || "").toUpperCase().trim();
            let rutaDisplay = rutaVal;

            // Si la ruta contiene NORMAL y estamos en Corte X PROG, mostrar select con opciones
            try {
                const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                if (rutaKey.indexOf('NORMAL') !== -1 && onCorteView && currentCorteFilter === 'X PROG') {
                    const current = String(rutaVal || '').toUpperCase().trim();
                    const opts = ['LAVADA','ACABADA'];
                    let optionsHtml = '';
                    let matched = false;
                    for (const o of opts) {
                        const sel = (current === o) ? 'selected' : '';
                        if (sel) matched = true;
                        optionsHtml += `<option value="${o}" ${sel}>${o}</option>`;
                    }
                    if (current && !matched) {
                        optionsHtml = `<option value="${current}" selected>${current}</option>` + optionsHtml;
                    }
                    const idx = (rowIndex !== null) ? rowIndex : '';
                    rutaDisplay = `<select class="table-select" onchange="updateRow(${idx}, 'RUTA TELA', this.value, this)">${optionsHtml}</select>`;
                    return rutaDisplay;
                }
            } catch(e) { /* ignore */ }

            if (rutaKey === 'ACABADA') {
                rutaDisplay = `<span class="route-badge route-ac">AC</span>`;
            } else if (rutaKey === 'LAVADA') {
                if (row) {
                    const estadoBloqRaw = getVal(row, "estado_bloqueo");
                    const estadoBloq = (!estadoBloqRaw || estadoBloqRaw === "") ? "X PROG" : String(estadoBloqRaw).toUpperCase().trim();
                    const estadoLavRaw = getVal(row, "estado_lavada");
                    const estadoLav = (!estadoLavRaw || estadoLavRaw === "") ? "" : String(estadoLavRaw).toUpperCase().trim();

                    if (estadoBloq.includes('PROG')) {
                        rutaDisplay = `<span class="route-badge route-bloq">x bloq</span>`;
                    } else if (estadoBloq === 'OK' && (estadoLav === '' || estadoLav === 'EN LAV')) {
                        rutaDisplay = `<span class="route-badge route-xlav">x lavar</span>`;
                    } else if (estadoLav === 'OK') {
                        rutaDisplay = `<span class="route-badge route-lv">LV-ok</span>`;
                    } else {
                        rutaDisplay = `<span class="route-badge route-lv">LV</span>`;
                    }
                } else {
                    rutaDisplay = `<span class="route-badge route-lv">LV</span>`;
                }
            }
            
            return rutaDisplay;
        }

        function createRow(row, rowIndex, type, groupClass = "") {
            const tr = document.createElement('tr');
            if (groupClass) tr.className = `group-${groupClass}`;
            // Flag para marcar filas en devolución de lavado
            let isDevolucionRow = false;
            
            // Colorear fila si columna P = 1
            try {
                const idxP = findHeaderIndexCaseInsensitive('P');
                if (idxP !== -1) {
                    const pValue = String(row[idxP] || "").trim();
                    if (pValue === "1") {
                        tr.style.backgroundColor = "rgb(255,163,163)";
                    }
                }
            } catch (e) {} 
            
            if (type === "bloqueo" || type === "lavado") {
                const fDespacho = formatValue(getVal(row, "HOD"), 'date');
                
                // Determinar si F.ING.COST debe ser date picker
                let fIngCostHtml = '';
                let useDatePicker = false;
                try {
                    const isBloqueoView = document.getElementById('view-bloqueo') && document.getElementById('view-bloqueo').classList.contains('active');
                    const isLavadoView = document.getElementById('view-lavado') && document.getElementById('view-lavado').classList.contains('active');
                    
                    // Bloqueo → usar date picker en sub-tabs distintos de 'Por Programar' (X PROG)
                    // En 'Por Programar' queremos mostrar el dato como texto (no editable)
                    if (isBloqueoView && currentBloqueoFilter !== 'X PROG') useDatePicker = true;
                    // Lavado siempre tiene sub-tab activo, no aplica date picker aquí
                } catch (e) {}
                
                if (useDatePicker) {
                    const rawFIngCost = getVal(row, "F.ING.COST");
                    const dateValue = convertToDateInputFormat(rawFIngCost);
                    fIngCostHtml = `<td class="date-cell"><input type="date" class="short-year" value="${dateValue}" onchange="handleDateChange(this, ${rowIndex}, 'F.ING.COST')"><span class="date-yy">${formatDateShortFromInput(dateValue) || 'mm/dd/aaaa'}</span></td>`;
                } else {
                    const fIngCost = formatValue(getVal(row, "F.ING.COST"), 'date');
                    fIngCostHtml = `<td class="date-cell">${fIngCost}</td>`;
                }
                
                const cliente = normalizeClientName(getVal(row, "CLIENTE"));
                
                // === VISUALIZACIÓN TAL CUAL VIENE DEL EXCEL ===
                // Usamos la comilla invertida para forzar texto si es necesario, pero
                // con String() y trim() es suficiente. La clave es que no intentamos limpiar "ceros"
                const opTela = String(getVal(row, "OP TELA") || "").trim();
                const partida = String(getVal(row, "PARTIDA") || "").trim();
                
                // Unimos con un caracter visible
                const opPtda = `${opTela}-${partida}`; 
                
                const op = getVal(row, "OP");
                const corte = getVal(row, "CORTE");
                const rawColor = getVal(row, "COLOR");
                const color = abbreviateHeather(rawColor);
                const oc = `${op}-${corte}`;
                
                let kg = "0.00";
                const rawKg = getVal(row, "KG GIRADOS");
                if (rawKg) kg = parseFloat(rawKg).toFixed(2);
                
                const rib = getVal(row, "RIB");
                const articulo = getVal(row, "ARTÍCULO");
                const nroMolde = getVal(row, "NRO. MOLDE");
                const tipoCert = normalizeTipoCert(getVal(row, "TIPO CERTIFICADO"));
                const fGirado = formatValue(getVal(row, "F. GIRADO"), 'date');
                const ruta = getVal(row, "RUTA TELA") || "";

                let controlHtml = "";

                if (type === "bloqueo") {
                    const ribOriginal = rib || "NO LLEVA";
                    const ribGuardado = getVal(row, "estado_rib");
                    const ribValue = ribGuardado || (ribOriginal === "NO LLEVA" ? "NO LLEVA" : "SI LLEVA");
                    let ribDisabled = (ribOriginal === "NO LLEVA") ? "disabled" : "";
                    let ribClass = (ribValue === "OK") ? "sel-OK" : "";
                    // Si estamos en la vista Bloqueo y en el sub-tab 'Por Programar' (X PROG),
                    // mostrar solo el dato (sin desplegable). Para el resto de vistas
                    // mantener el select como antes.
                    let ribHtml = '';
                    try {
                        const onBloqView = document.getElementById('view-bloqueo') && document.getElementById('view-bloqueo').classList.contains('active');
                        if (onBloqView && currentBloqueoFilter === 'X PROG') {
                            const spanClass = (ribValue === 'SI LLEVA') ? 'rib-si-lleva' : 'rib-text';
                            ribHtml = `<td title="${ribValue}"><span class="${spanClass}">${ribValue}</span></td>`;
                        } else {
                            const ribSelect = `
                                <select class="table-select ${ribClass}" ${ribDisabled} onchange="updateRow(${rowIndex}, 'estado_rib', this.value, this)">
                                    ${ribOriginal === "NO LLEVA" 
                                        ? `<option>NO LLEVA</option>` 
                                        : `<option value="SI LLEVA" ${ribValue === "SI LLEVA" ? "selected" : ""}>SI LLEVA</option>
                                        <option value="NO PASO" ${ribValue === "NO PASO" ? "selected" : ""}>NO PASO</option>
                                        <option value="EN CORTE" ${ribValue === "EN CORTE" ? "selected" : ""}>EN CORTE</option>
                                        <option value="EN LAV" ${ribValue === "EN LAV" ? "selected" : ""}>EN LAV</option>
                                        <option value="LAV(rep)" ${ribValue === "LAV(rep)" ? "selected" : ""}>LAV(rep)</option>
                                        <option value="EN HAB" ${ribValue === "EN HAB" ? "selected" : ""}>EN HAB</option>`
                                    }
                                </select>`;
                            ribHtml = `<td>${ribSelect}</td>`;
                        }
                    } catch(e) {
                        const ribSelect = `
                            <select class="table-select ${ribClass}" ${ribDisabled} onchange="updateRow(${rowIndex}, 'estado_rib', this.value, this)">
                                ${ribOriginal === "NO LLEVA" 
                                    ? `<option>NO LLEVA</option>` 
                                    : `<option value="SI LLEVA" ${ribValue === "SI LLEVA" ? "selected" : ""}>SI LLEVA</option>
                                    <option value="NO PASO" ${ribValue === "NO PASO" ? "selected" : ""}>NO PASO</option>
                                    <option value="EN CORTE" ${ribValue === "EN CORTE" ? "selected" : ""}>EN CORTE</option>
                                    <option value="EN LAV" ${ribValue === "EN LAV" ? "selected" : ""}>EN LAV</option>
                                    <option value="LAV(rep)" ${ribValue === "LAV(rep)" ? "selected" : ""}>LAV(rep)</option>
                                    <option value="EN HAB" ${ribValue === "EN HAB" ? "selected" : ""}>EN HAB</option>`
                                }
                            </select>`;
                        ribHtml = `<td>${ribSelect}</td>`;
                    }
                    const bloqValue = getVal(row, "estado_bloqueo") || "X PROG";
                    let bloqClass = "";
                    if (bloqValue === "PROG") bloqClass = "sel-PROG";
                    if (bloqValue === "OK") bloqClass = "sel-OK";

                    // Determinar si se deben ocultar opciones en el select de Bloqueo
                    let showOkOption = true;
                    let showXProgOption = true;
                    try {
                        const onBloqView = document.getElementById('view-bloqueo') && document.getElementById('view-bloqueo').classList.contains('active');
                        if (onBloqView && currentBloqueoFilter === 'X PROG') showOkOption = false;
                        if (onBloqView && currentBloqueoFilter === 'PROG') showXProgOption = false;
                    } catch (e) { /* silent */ }

                    // Si ocultamos X PROG pero el valor actual es 'X PROG', forzamos un valor visible
                    const effectiveValue = (bloqValue === 'X PROG' && !showXProgOption) ? 'PROG' : bloqValue;

                    const xProgOptionHtml = showXProgOption ? `<option value="X PROG" ${effectiveValue === "X PROG" ? "selected" : ""}>X PROG</option>` : '';
                    const okOptionHtml = showOkOption ? `<option value="OK" ${effectiveValue === "OK" ? "selected" : ""}>OK</option>` : '';

                    // En la vista Bloqueo->Programado, requerir que el usuario haya seleccionado RIB (estado_rib)
                    // para permitir cambiar el estado de Bloqueo. Si no existe un valor guardado en estado_rib,
                    // deshabilitar el select y mostrar tooltip indicando que primero debe elegir RIB.
                    let requireRibSelection = false;
                    try {
                        const onBloqView = document.getElementById('view-bloqueo') && document.getElementById('view-bloqueo').classList.contains('active');
                        if (onBloqView && currentBloqueoFilter === 'PROG') requireRibSelection = true;
                    } catch (e) { /* ignore */ }

                    // Considerar que si la columna original "RIB" indica "NO LLEVA",
                    // entonces se considera como si ya estuviera seleccionada y por tanto
                    // permitir cambiar el estado de Bloqueo incluso en sub-tab PROG.
                    const hasRibSavedOrNoLleva = !!ribGuardado || (String(ribOriginal).toUpperCase() === "NO LLEVA");
                    const bloqDisabledAttr = (requireRibSelection && !hasRibSavedOrNoLleva) ? 'disabled' : '';
                    const bloqTitle = (requireRibSelection && !hasRibSavedOrNoLleva) ? 'Seleccione RIB primero' : '';

                    const bloqSelect = `
                        <select class="table-select ${bloqClass}" ${bloqDisabledAttr} title="${bloqTitle}" onchange="updateRow(${rowIndex}, 'estado_bloqueo', this.value, this)">
                            ${xProgOptionHtml}
                            <option value="PROG" ${effectiveValue === "PROG" ? "selected" : ""}>PROG</option>
                            ${okOptionHtml}
                        </select>`;

                    // Si estamos en la vista Bloqueo->Por Programar (X PROG), mostrar solo texto
                    let bloqHtml = '';
                    try {
                        const onBloqView = document.getElementById('view-bloqueo') && document.getElementById('view-bloqueo').classList.contains('active');
                        if (onBloqView && currentBloqueoFilter === 'X PROG') {
                            bloqHtml = `<td title="${effectiveValue}"><span class="${bloqClass}">${effectiveValue}</span></td>`;
                        } else {
                            bloqHtml = `<td>${bloqSelect}</td>`;
                        }
                    } catch(e) { bloqHtml = `<td>${bloqSelect}</td>`; }

                    controlHtml = `<td title="${nroMolde}">${nroMolde}</td><td title="${tipoCert}">${tipoCert}</td>${bloqHtml}${ribHtml}`;

                } else if (type === "lavado") {
                        const lavValue = getVal(row, "estado_lavada") || "EN LAV";
                        let lavClass = "sel-ENLAV"; 
                        if (lavValue === "OK") lavClass = "sel-OK";

                        // Detectar devolucion (tolerante a mayúsculas/acento)
                        const isDevol = String(lavValue || '').toUpperCase().includes('DEVOLUCION') || String(lavValue || '').toUpperCase().includes('DEVOLUCIÓN');
                        if (isDevol) isDevolucionRow = true;

                        const lavSelect = `
                            <div class="lav-wrap">
                                <select class="table-select ${lavClass}" onchange="updateRow(${rowIndex}, 'estado_lavada', this.value, this)">
                                    <option value="EN LAV" ${lavValue === "EN LAV" ? "selected" : ""}>EN LAV</option>
                                    <option value="X ARRANQUE" ${lavValue === "X ARRANQUE" ? "selected" : ""}>X ARRANQUE</option>
                                    <option value="X LAVAR" ${lavValue === "X LAVAR" ? "selected" : ""}>X LAVAR</option>
                                    <option value="X CENTRIFUGAR" ${lavValue === "X CENTRIFUGAR" ? "selected" : ""}>X CENTRIFUGAR</option>
                                    <option value="X SECAR" ${lavValue === "X SECAR" ? "selected" : ""}>X SECAR</option>
                                    <option value="X AUD INTERNA" ${lavValue === "X AUD INTERNA" ? "selected" : ""}>X AUD INTERNA</option>
                                    <option value="X AUD CALIDAD" ${lavValue === "X AUD CALIDAD" ? "selected" : ""}>X AUD CALIDAD</option>
                                    <option value="RECHAZADO" ${lavValue === "RECHAZADO" ? "selected" : ""}>RECHAZADO</option>
                                    <option value="OK" ${lavValue === "OK" ? "selected" : ""}>OK</option>
                                </select>
                                ${isDevol ? '<span class="lav-badge" title="EN LAV (devolucion)">DEVOL.</span>' : ''}
                            </div>`;

                        // En Lavado -> Por Lavar (EN LAV) mostrar solo el dato (sin select)
                        let lavHtml = '';
                        try {
                            const onLavView = document.getElementById('view-lavado') && document.getElementById('view-lavado').classList.contains('active');
                            if (onLavView && String(currentLavadoFilter).toUpperCase() === 'EN LAV') {
                                const spanClass = (lavValue === 'OK') ? 'sel-OK' : 'sel-ENLAV';
                                lavHtml = `<td><div class="lav-wrap"><span class="${spanClass}">${lavValue}</span>${isDevol ? '<span class="lav-badge" title="EN LAV (devolucion)">DEVOL.</span>' : ''}</div></td>`;
                            } else {
                                lavHtml = `<td>${lavSelect}</td>`;
                            }
                        } catch(e) { lavHtml = `<td>${lavSelect}</td>`; }
                    
                    const ribOriginal = rib || "NO LLEVA";
                    const ribGuardado = getVal(row, "estado_rib");
                    const ribValue = ribGuardado || (ribOriginal === "NO LLEVA" ? "NO LLEVA" : "SI LLEVA");
                    let ribDisabled = (ribOriginal === "NO LLEVA") ? "disabled" : "";
                    let ribClass = (ribValue === "OK") ? "sel-OK" : "";

                    // En Lavado mostrar sólo las opciones solicitadas. Si es NO LLEVA mantener celda deshabilitada.
                    let ribSelect = '';
                    try {
                        if (ribOriginal === "NO LLEVA") {
                            ribSelect = `<select class="table-select" disabled><option>NO LLEVA</option></select>`;
                        } else {
                            // Aplicar clase de peligro si el valor es NO PASO o LAV(rep)
                            const danger = (String(ribValue).toUpperCase() === 'NO PASO' || String(ribValue).toUpperCase() === 'LAV(REP)');
                            const extraClass = danger ? 'rib-danger' : '';
                            ribSelect = `
                                <select class="table-select ${ribClass} ${extraClass}" onchange="updateRow(${rowIndex}, 'estado_rib', this.value, this)">
                                    <option value="NO PASO" ${ribValue === "NO PASO" ? "selected" : ""}>NO PASO</option>
                                    <option value="EN CORTE" ${ribValue === "EN CORTE" ? "selected" : ""}>EN CORTE</option>
                                    <option value="EN LAV" ${ribValue === "EN LAV" ? "selected" : ""}>EN LAV</option>
                                    <option value="LAV(rep)" ${ribValue === "LAV(rep)" ? "selected" : ""}>LAV(rep)</option>
                                </select>`;
                        }
                    } catch (e) {
                        ribSelect = `<select class="table-select ${ribClass}" ${ribDisabled} onchange="updateRow(${rowIndex}, 'estado_rib', this.value, this)">
                                        <option value="NO PASO" ${ribValue === "NO PASO" ? "selected" : ""}>NO PASO</option>
                                        <option value="EN CORTE" ${ribValue === "EN CORTE" ? "selected" : ""}>EN CORTE</option>
                                        <option value="EN LAV" ${ribValue === "EN LAV" ? "selected" : ""}>EN LAV</option>
                                        <option value="LAV(rep)" ${ribValue === "LAV(rep)" ? "selected" : ""}>LAV(rep)</option>
                                    </select>`;
                    }

                    controlHtml = `<td title="${tipoCert}">${tipoCert}</td>${lavHtml}<td>${ribSelect}</td>`;
                }

                // Usamos title para mostrar el dato completo en hover por si acaso
                let html = `
                    ${type === "bloqueo" ? `<td>${fGirado}</td>` : ''}
                    <td class="date-cell">${fDespacho}</td>
                    ${fIngCostHtml}
                    <td>${cliente}</td>
                    ${type === "bloqueo" ? `<td title="${ruta}">${ruta}</td>` : ''}
                    <!-- TOOLTIP TITLE PARA VER TEXTO COMPLETO -->
                    <td class="op-cell wrap-text" title="${opPtda}">${opPtda}</td>
                    <td class="op-cell" title="${oc}">${oc}</td>
                    <td title="${color}">${color}</td>
                    <td class="kg-cell" style="text-align:right;">${kg}</td>
                    <td title="${articulo}">${articulo}</td>
                    ${controlHtml}
                `;  
                tr.innerHTML = html;

                // Inicializar eventos onclick de los spans de fecha
                setTimeout(() => {
                    const inputEl = tr.querySelector('input.short-year');
                    const spanEl = tr.querySelector('span.date-yy');
                    if (inputEl && spanEl) {
                        spanEl.onclick = function(e) {
                            e.stopPropagation();
                            inputEl.showPicker ? inputEl.showPicker() : inputEl.click();
                        };
                    }
                }, 0);

                // Si la fila corresponde a una devolución de lavado, marcar visualmente
                try {
                    if (isDevolucionRow) tr.classList.add('lav-devolucion');
                } catch (e) { /* ignore */ }

            } else {
                const fDespacho = formatValue(getVal(row, "HOD"), 'date');
                
                // Determinar si F.ING.COST debe ser date picker en esta vista/sub-tab
                let fIngCostHtml = '';
                let useDatePicker = false;
                try {
                    const isCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                    const isEnumeradoView = document.getElementById('view-enumerado') && document.getElementById('view-enumerado').classList.contains('active');
                    const isTransferView = document.getElementById('view-transfer') && document.getElementById('view-transfer').classList.contains('active');
                    const isArtesView = document.getElementById('view-artes') && document.getElementById('view-artes').classList.contains('active');
                    const isHabilitadoView = document.getElementById('view-habilitado') && document.getElementById('view-habilitado').classList.contains('active');
                    const isCorteBloques = document.getElementById('view-corte-bloques') && document.getElementById('view-corte-bloques').classList.contains('active');
                    
                    // Corte Pzas → usar date picker en sub-tabs distintos de 'Por Programar' (X PROG)
                    // En 'Por Programar' (X PROG) queremos mostrar F.ING.COST como texto (no editable)
                    if (isCorteView && currentCorteFilter !== 'X PROG') useDatePicker = true;
                    // Corte Bloques → usar date picker en sub-tabs distintos de 'Por Programar' (X PROG)
                    // En 'Por Programar' (X PROG) queremos mostrar F.ING.COST como texto (no editable)
                    if (isCorteBloques && currentCorteBloquesFilter !== 'X PROG') useDatePicker = true;
                    // Enumerado → Por enumerar (sub-tab activo)
                    if (isEnumeradoView) useDatePicker = true;
                    // Transfer → Por Programar (X PROG)
                    if (isTransferView && currentTransferFilter === 'X PROG') useDatePicker = true;
                    // Arte (Pzas) → Bordado X PROG o Estampado X PROG
                    if (isArtesView) {
                        const isBordado = document.getElementById('btn-artes-bordado') && document.getElementById('btn-artes-bordado').classList.contains('active');
                        const isEstampado = document.getElementById('btn-artes-estampado') && document.getElementById('btn-artes-estampado').classList.contains('active');
                        if (isBordado) {
                            // Verificar sub-tab X PROG de Bordado
                            const btnBordadoXProg = document.getElementById('btn-bordado-xprog');
                            if (btnBordadoXProg && btnBordadoXProg.classList.contains('active')) useDatePicker = true;
                        }
                        if (isEstampado) {
                            // Verificar sub-tab X PROG de Estampado
                            const btnEstampadoXProg = document.getElementById('btn-estampado-xprog');
                            if (btnEstampadoXProg && btnEstampadoXProg.classList.contains('active')) useDatePicker = true;
                        }
                    }
                    // Habilitado (toda la vista)
                    if (isHabilitadoView) useDatePicker = true;
                } catch (e) {}
                
                if (useDatePicker) {
                    const rawFIngCost = getVal(row, "F.ING.COST");
                    const dateValue = convertToDateInputFormat(rawFIngCost);
                    fIngCostHtml = `<td class="date-cell"><input type="date" class="short-year" value="${dateValue}" onchange="handleDateChange(this, ${rowIndex}, 'F.ING.COST')"><span class="date-yy">${formatDateShortFromInput(dateValue) || 'mm/dd/aaaa'}</span></td>`;
                } else {
                    const fIngCost = formatValue(getVal(row, "F.ING.COST"), 'date');
                    fIngCostHtml = `<td class="date-cell">${fIngCost}</td>`;
                }
                
                const cliente = normalizeClientName(getVal(row, "CLIENTE"));

                const op = getVal(row, "OP");
                const corte = getVal(row, "CORTE");
                const oc = (op || corte) ? `${op}-${corte}` : "";

                const rutaVal = getVal(row, "RUTA TELA") || getVal(row, "RUTA") || "";

                const rawColor = getVal(row, "COLOR");
                const color = abbreviateHeather(rawColor);
                const fGirado = formatValue(getVal(row, "F. GIRADO"), 'date');

                const opTela = String(getVal(row, "OP TELA") || "").trim();
                const partida = String(getVal(row, "PARTIDA") || "").trim();
                const opPtda = `${opTela}-${partida}`;

                const pdsRaw = parseFloat(getVal(row, "PDS GIRADAS")) || 0;
                const pdsStr = formatThousands(pdsRaw, 0);

                const prenda = getVal(row, "PRENDA");
                const prendaNorm = normalizePrenda(prenda);
                const articulo = getVal(row, "ARTÍCULO");
                const tipoCert = normalizeTipoCert(getVal(row, "TIPO CERTIFICADO"));
                const rib = getVal(row, "RIB") || getVal(row, "estado_rib") || "";

                const equipoCorte = getVal(row, "EQUIPO CORTE") || getVal(row, "EQUIPO_CORTE") || getVal(row, "equipo_corte") || "";
                const estadoCorte = getVal(row, "STATUS_CORTE") || getVal(row, "STATUS") || getVal(row, "status") || getVal(row, "ESTADO CORTE") || getVal(row, "ESTADO_CORTE") || getVal(row, "estado_corte") || "";
                // Determinar el nombre de columna a usar al guardar: preferir la que exista en colMap
                let updateColName = 'STATUS_CORTE';
                if (colMap[updateColName] === undefined || colMap[updateColName] === -1) {
                    const candidates = ['STATUS','status','estado_corte','ESTADO CORTE','ESTADO_CORTE'];
                    for (let c of candidates) {
                        if (colMap[c] !== undefined && colMap[c] !== -1) { updateColName = c; break; }
                    }
                }
                const estadoBloques = getVal(row, "ESTADO BLOQUES") || getVal(row, "ESTADO_BLOQUES") || getVal(row, "estado_bloques") || "";
                const estadoCollTap = getVal(row, "ESTADO COLL TAP") || getVal(row, "ESTADO_COLL_TAP") || getVal(row, "estado_coll_tap") || "";

                // Determinar si mostrar el botón de tendido (solo en sub-tabs PROG 1T/2T/3T)
                const showTendidoBtn = (currentCorteFilter === 'PROG 1T' || currentCorteFilter === 'PROG 2T' || currentCorteFilter === 'PROG 3T') && !isHabilitadoView();
                const tendidoBtnHtml = showTendidoBtn 
                    ? `<button class="btn-tendido" onclick="abrirModalTendido(${rowIndex}, '${op}', '${corte}', '${String(color).replace(/'/g, "\\'")}', ${pdsRaw})" title="Dividir en tendidos">+</button>` 
                    : '';

                // Usar la función helper para renderizar el badge de RUTA
                const rutaDisplay = renderRutaBadge(rutaVal, row, rowIndex);
                
                // Determinar si OP-PTDA debe ser clickeable (solo en Corte PROG 1T/2T/3T y cuando RUTA != "AC")
                const isCorteProgView = (currentCorteFilter === 'PROG 1T' || currentCorteFilter === 'PROG 2T' || currentCorteFilter === 'PROG 3T');
                const rutaKey = String(rutaVal || "").toUpperCase().trim();
                const makeOpPtdaClickable = isCorteProgView && rutaKey !== 'ACABADA' && !isHabilitadoView();
                const opPtdaHtml = makeOpPtdaClickable 
                    ? `<span class="oc-link" style="cursor:pointer;" onclick="abrirModalLavadoFromCorte(${rowIndex})" title="Cambiar estado lavada">${opPtda}</span>`
                    : opPtda;

                let html = `
                    <td>${fGirado}</td>
                    <td class="date-cell">${fDespacho}</td>
                    ${fIngCostHtml}
                    <td title="${cliente}">${cliente}</td>
                    <td title="${rutaVal}">${rutaDisplay}</td>
                    <td class="op-cell" title="${oc}">${tendidoBtnHtml}<span class="oc-link" onclick="if(isHabilitadoView()) abrirModalOC(${rowIndex});">${oc}</span></td>
                    <td title="${color}">${color}</td>
                    <td class="op-cell wrap-text" title="${opPtda}">${opPtdaHtml}</td>
                    <td class="kg-cell" style="text-align:center;">${pdsStr}</td>
                    <td title="${prenda}">${prendaNorm}</td>
                    <td title="${articulo}">${articulo}</td>
                    <td title="${tipoCert}">${tipoCert}</td>
                    <td>
                        ${(() => {
                            const ribOriginal = getVal(row, "RIB") || "NO LLEVA";
                            const ribGuardado = getVal(row, "estado_rib");
                            const ribValue = ribGuardado || (ribOriginal === "NO LLEVA" ? "NO LLEVA" : "SI LLEVA");
                            const ribDisabled = (ribOriginal === "NO LLEVA") ? "disabled" : "";
                            const ribClass = (ribValue === "OK") ? "sel-OK" : "";
                            try {
                                const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                                if (onCorteView && currentCorteFilter === 'X PROG') {
                                    const spanClass = (ribValue === 'SI LLEVA') ? 'rib-si-lleva' : 'rib-text';
                                    return `<span title="${ribValue}" class="${spanClass}">${ribValue}</span>`;
                                }
                            } catch (e) { /* ignore */ }
                            return `
                                <select class="table-select ${ribClass}" ${ribDisabled} onchange="updateRow(${rowIndex}, 'estado_rib', this.value, this)">
                                    ${ribOriginal === "NO LLEVA"
                                        ? `<option>NO LLEVA</option>`
                                        : `<option value="SI LLEVA" ${ribValue === "SI LLEVA" ? "selected" : ""}>SI LLEVA</option>
                                           <option value="NO PASO" ${ribValue === "NO PASO" ? "selected" : ""}>NO PASO</option>
                                           <option value="EN CORTE" ${ribValue === "EN CORTE" ? "selected" : ""}>EN CORTE</option>
                                           <option value="EN LAV" ${ribValue === "EN LAV" ? "selected" : ""}>EN LAV</option>
                                           <option value="LAV(rep)" ${ribValue === "LAV(rep)" ? "selected" : ""}>LAV(rep)</option>
                                           <option value="EN HAB" ${ribValue === "EN HAB" ? "selected" : ""}>EN HAB</option>`}
                                </select>
                            `;
                        })()}
                    </td>
                    <td>
                            ${(() => {
                                // En la vista Enumerado siempre mostrar solo el dato (sin select)
                                try {
                                    if (isEnumeradoView()) return equipoCorte || '';
                                } catch (e) {}

                                // En la vista Enumerado o en Corte->Por Programar (X PROG) mostrar solo el dato (texto)
                                try {
                                    const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                                    if (isEnumeradoView() || (onCorteView && currentCorteFilter === 'X PROG')) return equipoCorte || '';
                                } catch (e) {}

                                // Para otros sub-tabs (p.ej. PROG 1T/2T/3T) mostrar select editable
                                if (currentCorteFilter === 'X PROG') {
                                    const currentEquipo = equipoCorte || '';
                                    let optionsHtml = '<option value="">-- Seleccionar --</option>';
                                    equiposCorteData.forEach(eq => {
                                        const selected = (currentEquipo === eq.nombre) ? 'selected' : '';
                                        optionsHtml += `<option value="${eq.nombre}" ${selected}>${eq.nombre}</option>`;
                                    });
                                    return `
                                    <select class="table-select" onchange="updateRow(${rowIndex}, 'equipo_corte', this.value, this)">
                                        ${optionsHtml}
                                    </select>
                                `;
                                } else {
                                    return equipoCorte;
                                }
                            })()}
                        </td>
                        <td>
                            ${(() => {
                                const est = (estadoCorte || '').toString();
                                const estClass = est.toUpperCase().includes('PROG') ? 'sel-PROG' : (est === 'OK' ? 'sel-OK' : '');
                                // Ocultar opción OK sólo cuando estamos en la vista Corte y en el sub-tab 'X PROG'
                                let allowOk = true;
                                // Ocultar opción X PROG cuando estamos en la vista Corte y en un sub-tab PROG (1T/2T/3T)
                                let allowXProg = true;
                                try {
                                    const onCorte = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                                    if (onCorte && currentCorteFilter === 'X PROG') allowOk = false;
                                    if (onCorte && currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG') allowXProg = false;
                                } catch (e) { /* ignore */ }

                                const okOption = allowOk ? `<option value="OK" ${est === 'OK' ? 'selected' : ''}>OK</option>` : '';
                                // Si X PROG está oculto pero el valor actual es 'X PROG', forzar selección por defecto a 'PROG 1T'
                                let effectiveEst = est;
                                if (!allowXProg && est === 'X PROG') effectiveEst = 'PROG 1T';

                                const xProgOption = allowXProg ? `<option value="X PROG" ${(!effectiveEst || effectiveEst === '' || effectiveEst === 'X PROG') ? 'selected' : ''}>X PROG</option>` : '';

                                try {
                                    const onCorte = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                                    if (onCorte && currentCorteFilter === 'X PROG') {
                                        // Mostrar solo texto en Corte -> Por Programar
                                        const displayEst = effectiveEst || '';
                                        return `<span title="${displayEst}">${displayEst}</span>`;
                                    }
                                } catch(e) {}

                                return `
                                    <select class="table-select ${estClass}" onchange="updateRow(${rowIndex}, '${updateColName}', this.value, this)">
                                        ${xProgOption}
                                        <option value="PROG 1T" ${effectiveEst === 'PROG 1T' ? 'selected' : ''}>PROG 1T</option>
                                        <option value="PROG 2T" ${effectiveEst === 'PROG 2T' ? 'selected' : ''}>PROG 2T</option>
                                        <option value="PROG 3T" ${effectiveEst === 'PROG 3T' ? 'selected' : ''}>PROG 3T</option>
                                        ${okOption}
                                    </select>
                                `;
                            })()}
                        </td>
                    ${(() => {
                        // Si estamos en sub-tab PROG (1T/2T/3T) dentro de la vista Corte,
                        // o si estamos en la vista Enumerado, mostramos selects con las opciones solicitadas.
                        if (isCorteProgSubtab() || isEnumeradoView() || isHabilitadoView()) {
                            const bloqVal = (estadoBloques || '').toString();
                            const collVal = (estadoCollTap || '').toString();
                            // Para BLOQUES?: en las vistas Enumerado y Habilitado mostramos el dato (texto),
                            // en otras vistas mostramos el select editable.
                            let bloqCell = '';
                            if (isHabilitadoView() || isEnumeradoView()) {
                                const bloqDisplay = estadoBloques || '';
                                bloqCell = `<td title="${bloqDisplay}">${bloqDisplay}</td>`;
                            } else {
                                bloqCell = `
                                    <td>
                                        <select class="table-select" onchange="updateRow(${rowIndex}, 'ESTADO_BLOQUES', this.value, this)">
                                            <option value="LLEVA?" ${( !bloqVal || bloqVal === 'LLEVA?' ) ? 'selected' : ''}>LLEVA?</option>
                                            <option value="Ok corte" ${bloqVal === 'Ok corte' ? 'selected' : ''}>Ok corte</option>
                                            <option value="NO LLEVA" ${bloqVal === 'NO LLEVA' ? 'selected' : ''}>NO LLEVA</option>
                                        </select>
                                    </td>`;
                            }

                            // Para COLL o TAP?: en Habilitado mostrar select con el dato actual + OK,
                            // en otras vistas mantener las opciones completas. En particular,
                            // para los sub-tabs PROG de la vista Corte queremos el select completo
                            // (igual que Enumerado), así que forzamos ese HTML cuando corresponda.
                            let collSelect = '';
                            const fullCollSelectHtml = `
                                    <td>
                                        <select class="table-select" onchange="updateRow(${rowIndex}, 'ESTADO_COLL_TAP', this.value, this)">
                                            <option value="LLEVA?" ${(!collVal || collVal === 'LLEVA?') ? 'selected' : ''}>LLEVA?</option>
                                            <option value="Coll en Hab" ${collVal === 'Coll en Hab' ? 'selected' : ''}>Coll en Hab</option>
                                            <option value="Tap en Hab" ${collVal === 'Tap en Hab' ? 'selected' : ''}>Tap en Hab</option>
                                            <option value="Coll+Tap en Hab" ${collVal === 'Coll+Tap en Hab' ? 'selected' : ''}>Coll+Tap en Hab</option>
                                            <option value="NO LLEVA" ${collVal === 'NO LLEVA' ? 'selected' : ''}>NO LLEVA</option>
                                        </select>
                                    </td>`;

                            if (isHabilitadoView()) {
                                const currentVal = (collVal || '').toString();
                                const isOk = currentVal === 'OK';
                                const isNoLleva = currentVal.toUpperCase() === 'NO LLEVA';
                                
                                // Si es "NO LLEVA", mostrar badge con el mismo estilo que RUTA en Corte Pzas
                                if (isNoLleva) {
                                    collSelect = `
                                        <td title="NO LLEVA">
                                            <span class="route-badge route-bloq">NO LLEVA</span>
                                        </td>`;
                                } else {
                                    // Si está vacío, mostrar 'x llenar'
                                    const displayLabel = currentVal === '' ? 'x llenar' : currentVal;
                                    const safeVal = (currentVal === '' ? 'x llenar' : currentVal).replace(/\"/g, '&quot;');
                                    collSelect = `
                                        <td>
                                            <select class="table-select" onchange="updateRow(${rowIndex}, 'ESTADO_COLL_TAP', this.value, this)">
                                                <option value="${safeVal}" ${!isOk ? 'selected' : ''}>${displayLabel}</option>
                                                <option value="OK" ${isOk ? 'selected' : ''}>OK</option>
                                            </select>
                                        </td>`;
                                }
                            } else {
                                collSelect = fullCollSelectHtml;
                            }
                            // Si estamos en un sub-tab PROG dentro de Corte, devolver el select completo
                            // (igual que en Enumerado) y evitar caer en el retorno por defecto.
                            try {
                                if (isCorteProgSubtab()) {
                                    return bloqCell + collSelect;
                                }
                            } catch (e) {}

                                    // Si estamos en Enumerado o Habilitado, también añadir el select

                            // Forzar select completo en los sub-tabs PROG dentro de Corte
                            try {
                                if (isCorteProgSubtab()) collSelect = fullCollSelectHtml;
                            } catch(e){}

                                    // Si estamos en Enumerado o Habilitado, también añadir el select
                                    // para estado_enumerado como última columna
                                    if (isEnumeradoView() || isHabilitadoView()) {
                                        const enmVal = (estadoBloques && estadoBloques.toString()) ? '' : '';
                                        // Buscar valor actual en las variantes de columna
                                        const evCandidates = [ 'estado_enumerado', 'ESTADO_ENumerado', 'ESTADO ENUMERADO' ];
                                        // Intentar recuperar valor real (si existe) desde rawData
                                        let ev = '';
                                        try {
                                            const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
                                            if (idxEv !== -1 && rawData[rowIndex] && rawData[rowIndex][idxEv]) ev = String(rawData[rowIndex][idxEv]);
                                        } catch (e) { ev = ''; }
                                        const evNorm = (ev || '').toString();
                                        // Construir dos variantes del select: una para Enumerado y otra para Habilitado
                                        const enmSelectEnumerado = `
                                            <td>
                                                <select class="table-select" onchange="updateRow(${rowIndex}, 'estado_enumerado', this.value, this)">
                                                    <option value="X ENM" ${(evNorm === '' || evNorm === 'X ENM') ? 'selected' : ''}>X ENM</option>
                                                    <option value="OK ENM" ${evNorm === 'OK ENM' ? 'selected' : ''}>OK ENM</option>
                                                    <option value="OK Paqueteo" ${evNorm === 'OK PAQUETEO' || evNorm === 'OK Paqueteo' ? 'selected' : ''}>OK Paqueteo</option>
                                                </select>
                                            </td>`;

                                        const enmSelectHabilitado = `
                                            <td>
                                                <select class="table-select" onchange="updateRow(${rowIndex}, 'estado_enumerado', this.value, this)">
                                                    <option value="X ENM" ${(evNorm === '' || evNorm === 'X ENM') ? 'selected' : ''}>X ENM</option>
                                                    <option value="OK ENM" ${evNorm === 'OK ENM' ? 'selected' : ''}>OK ENM</option>
                                                    <option value="OK S/ENM" ${evNorm === 'OK S/ENM' ? 'selected' : ''}>OK S/ENM</option>
                                                </select>
                                            </td>`;

                                        // Si estamos en Enumerado, mostrar solo las opciones solicitadas (OK ENM, OK Paqueteo)
                                        if (isEnumeradoView() && !isHabilitadoView()) {
                                            return bloqCell + enmSelectEnumerado;
                                        }

                                        // Para la vista Habilitado añadimos una columna adicional ESTADO_BLOQS
                                        // entre BLOQUES? y COLL o TAP? que muestra el valor sin desplegable.
                                        if (isHabilitadoView()) {
                                            const estBloqsVal = getVal(row, 'estado_corte_bloques') || getVal(row, 'ESTADO_CORTE_BLOQUES') || getVal(row, 'ESTADO CORTE BLOQUES') || getVal(row, 'ESTADO_BLOQS') || '';
                                            const estBloqsTd = `<td title="${estBloqsVal}">${estBloqsVal}</td>`;
                                            return bloqCell + estBloqsTd + collSelect + enmSelectHabilitado;
                                        }

                                        // Comportamiento por defecto (Corte PROG u otros): incluir COLL + el select de Habilitado
                                        return bloqCell + collSelect + enmSelectHabilitado;
                                    }
                        }
                        return `<td title="${estadoBloques}">${estadoBloques}</td>\n                    <td title="${estadoCollTap}">${estadoCollTap}</td>`;
                    })()}
                `;
                tr.innerHTML = html;
            }

            return tr;
        }

        // Función auxiliar para propagar cambios a filas con mismo OP y serie de corte
        function propagateToSameOPAndCorteSeries(rowIndex, colName, value) {
            try {
                console.log('=== INICIANDO PROPAGACIÓN ===');
                console.log('Fila:', rowIndex, 'Columna:', colName, 'Valor:', value);
                
                // Función auxiliar para normalizar nombres de columnas
                const findColIndexNormalized = function(name) {
                    if (!rawData || rawData.length === 0) return -1;
                    const headers = rawData[0];
                    const norm = s => String(s || '').toLowerCase().replace(/[^a-z0-9]/g, '');
                    const target = norm(name);
                    for (let i = 0; i < headers.length; i++) {
                        if (norm(headers[i]) === target) return i;
                    }
                    return -1;
                };

                // Obtener índices de columnas necesarias
                const opIdx = findColIndexNormalized('OP');
                const corteIdx = findColIndexNormalized('CORTE');
                
                // Para la columna objetivo, intentar primero el nombre exacto, luego variantes
                let colIdx = -1;
                
                // Si colName ya está en colMap, usarlo
                if (colMap[colName] !== undefined && colMap[colName] !== -1) {
                    colIdx = colMap[colName];
                    console.log('Usando colIdx desde colMap:', colIdx);
                } else {
                    // Intentar encontrar la columna
                    colIdx = findColIndexNormalized(colName);
                    
                    // Si no encuentra la columna, intentar con variantes según el tipo
                    if (colIdx === -1) {
                        console.log('No se encontró columna con nombre:', colName, '- intentando variantes');
                        
                        if (colName.includes('BLOQUES') || colName.includes('bloques')) {
                            const variants = ['estado_bloques', 'ESTADO_BLOQUES', 'ESTADO BLOQUES'];
                            for (let v of variants) {
                                colIdx = findColIndexNormalized(v);
                                if (colIdx !== -1) {
                                    console.log('Encontrada variante:', v, 'en índice:', colIdx);
                                    break;
                                }
                            }
                        } else if (colName.includes('COLL') || colName.includes('TAP') || colName.includes('coll') || colName.includes('tap')) {
                            const variants = ['estado_coll_tap', 'ESTADO_COLL_TAP', 'ESTADO COLL TAP'];
                            for (let v of variants) {
                                colIdx = findColIndexNormalized(v);
                                if (colIdx !== -1) {
                                    console.log('Encontrada variante:', v, 'en índice:', colIdx);
                                    break;
                                }
                            }
                        } else if (colName.includes('rib') || colName.includes('RIB')) {
                            const variants = ['estado_rib', 'ESTADO_RIB', 'ESTADO RIB'];
                            for (let v of variants) {
                                colIdx = findColIndexNormalized(v);
                                if (colIdx !== -1) {
                                    console.log('Encontrada variante:', v, 'en índice:', colIdx);
                                    break;
                                }
                            }
                        }
                    }
                }

                console.log('Índices encontrados - OP:', opIdx, 'CORTE:', corteIdx, 'Columna objetivo:', colIdx);

                if (opIdx === -1 || corteIdx === -1 || colIdx === -1) {
                    console.warn('No se encontraron columnas necesarias para propagar', {opIdx, corteIdx, colIdx});
                    if (colIdx === -1) {
                        console.warn('Headers disponibles:', rawData[0]);
                    }
                    return;
                }

                // Obtener valores de la fila actual
                const currentOP = String(rawData[rowIndex][opIdx] || '').trim();
                const currentCorte = String(rawData[rowIndex][corteIdx] || '').trim();

                console.log('Valores actuales - OP:', currentOP, 'CORTE:', currentCorte);

                if (!currentOP || !currentCorte) {
                    console.warn('Fila sin OP o CORTE, no se propagará');
                    return;
                }

                // Extraer el número base del corte (todos menos el último dígito)
                // Ejemplos: 101 -> 10, 403 -> 40, 1202 -> 120
                const corteNum = currentCorte.match(/\d+/);
                if (!corteNum) {
                    console.warn('CORTE no contiene números:', currentCorte);
                    return;
                }
                
                const corteNumStr = corteNum[0];
                const corteBase = corteNumStr.slice(0, -1); // Remover último dígito
                
                console.log('Serie de corte identificada:', corteBase + 'x');
                
                let updatedCount = 0;
                
                // Buscar todas las filas con el mismo OP y mismo corteBase
                for (let j = 1; j < rawData.length; j++) {
                    if (j === rowIndex) continue; // Saltar la fila actual
                    
                    const otherOP = String(rawData[j][opIdx] || '').trim();
                    const otherCorte = String(rawData[j][corteIdx] || '').trim();
                    
                    // Verificar si tiene el mismo OP
                    if (otherOP !== currentOP) continue;
                    
                    // Verificar si el corte pertenece a la misma serie
                    const otherCorteNum = otherCorte.match(/\d+/);
                    if (!otherCorteNum) continue;
                    
                    const otherCorteNumStr = otherCorteNum[0];
                    const otherCorteBase = otherCorteNumStr.slice(0, -1);
                    
                    // Si el corteBase coincide, propagar el cambio
                    if (otherCorteBase === corteBase) {
                        const prevValue = rawData[j][colIdx];
                        console.log(`Fila ${j} (Corte: ${otherCorte}): ${prevValue} -> ${value}`);
                        
                        rawData[j][colIdx] = value;
                        updatedCount++;
                        
                        // Determinar el nombre de columna correcto para enviar al backend
                        const sendColName = (rawData[0] && rawData[0][colIdx]) ? rawData[0][colIdx] : colName;
                        
                        // Guardar cambio en el backend
                        fetch(WEB_APP_URL, {
                            method: 'POST',
                            mode: 'no-cors',
                            body: JSON.stringify({
                                action: "update",
                                row: j,
                                colName: sendColName,
                                value: value
                            })
                        }).catch(e => console.error('Error guardando propagación:', e));
                    }
                }
                
                console.log(`✓ Propagación completada: ${updatedCount} filas actualizadas para ${colName} en OP ${currentOP}, serie ${corteBase}x`);
            } catch (e) {
                console.error('Error en propagateToSameOPAndCorteSeries:', e);
            }
        }

        window.updateRow = function(rowIndex, colName, value, selectElement) {
            // Log para debugging
            console.log('updateRow llamado:', {rowIndex, colName, value});
            
            if (colName.includes('estado_') || (typeof colName === 'string' && colName.toUpperCase() === 'STATUS')) {
                selectElement.className = "table-select";
                const v = (value || '').toString();
                // Aplicar clases más flexibles: cualquier variante que contenga 'PROG' se considera programado
                if (v.toUpperCase().includes('PROG')) selectElement.classList.add("sel-PROG");
                if (v === "OK") selectElement.classList.add("sel-OK");
                if (v === "EN LAV") selectElement.classList.add("sel-ENLAV");
            }

            // Asegurar que colMap tiene el índice correcto para colName; intentar variantes normalizadas si es necesario
            function findColIndexNormalized(name) {
                if (!rawData || rawData.length === 0) return -1;
                const headers = rawData[0];
                const norm = s => String(s || '').toLowerCase().replace(/[^a-z0-9]/g, '');
                const target = norm(name);
                for (let i = 0; i < headers.length; i++) {
                    if (norm(headers[i]) === target) return i;
                }
                return -1;
            }

            if (colMap[colName] === undefined || colMap[colName] === -1) {
                const found = findColIndexNormalized(colName);
                if (found !== -1) colMap[colName] = found;
            }

            const writeIdx = colMap[colName];

            // Validación específica solicitada:
            // En la vista Corte, cuando estamos en sub-tab PROG (1T/2T/3T) y
            // el usuario intenta marcar STATUS_CORTE = 'OK', validar que
            // tanto 'estado_bloques' como 'estado_coll_tap' NO estén en 'LLEVA?'.
            try {
                const valNorm = (value || '').toString().toUpperCase().trim();
                const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                const isProgSubtab = (currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG');

                const isStatusCol = (colName === 'estado_corte' || (typeof colName === 'string' && colName.toUpperCase() === 'STATUS') || (typeof colName === 'string' && colName.toUpperCase().includes('STATUS_CORTE')));

                    // VALIDACIÓN 1: Verificar que tenga equipo_corte al cambiar de X PROG a PROG 1T/2T/3T
                    if (isStatusCol && (valNorm === 'PROG 1T' || valNorm === 'PROG 2T' || valNorm === 'PROG 3T') && onCorteView && currentCorteFilter === 'X PROG') {
                        const equipoCorteIdx = findColIndexNormalized('equipo_corte');
                        const equipoCorte = (equipoCorteIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][equipoCorteIdx]) ? String(rawData[rowIndex][equipoCorteIdx]).trim() : '';
                        
                        if (!equipoCorte || equipoCorte === '') {
                            // Revertir selección visual al valor anterior
                            const prev = (writeIdx !== undefined && writeIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][writeIdx]) ? rawData[rowIndex][writeIdx] : '';
                            try { if (selectElement) selectElement.value = prev; } catch (e) {}
                            try { if (selectElement) { selectElement.style.border = '2px solid #ef4444'; setTimeout(()=>{ selectElement.style.border=''; }, 1600); } } catch(e){}
                            alert('No ha seleccionado un equipo de corte');
                            return; // cancelar guardado
                        }
                    }

                    // VALIDACIÓN 2: Al marcar STATUS_CORTE = 'OK' en sub-tabs PROG
                    // - Primero: impedir si estado_bloqueo o estado_lavada no son 'OK'
                    if (isStatusCol && valNorm === 'OK' && onCorteView && isProgSubtab) {
                        // Obtener valor de RUTA TELA para excepciones (p.ej. ACABADA)
                        const idxRuta = findColIndexNormalized('RUTA TELA');
                        const rutaRaw = (idxRuta !== -1 && rawData[rowIndex] && rawData[rowIndex][idxRuta]) ? String(rawData[rowIndex][idxRuta]).toUpperCase().trim() : '';

                        // Si la ruta es ACABADA, no requerimos que esté OK en estado_lavada;
                        // en ese caso sólo exigimos que BLOQUES y COLL/TAP estén completados
                        let estBloqRaw = '';
                        let estLavRaw = '';
                        if (rutaRaw !== 'ACABADA') {
                            const idxEstBloq = findColIndexNormalized('estado_bloqueo');
                            const idxEstLav = findColIndexNormalized('estado_lavada');
                            estBloqRaw = (idxEstBloq !== -1 && rawData[rowIndex] && rawData[rowIndex][idxEstBloq]) ? String(rawData[rowIndex][idxEstBloq]).toUpperCase().trim() : '';
                            estLavRaw = (idxEstLav !== -1 && rawData[rowIndex] && rawData[rowIndex][idxEstLav]) ? String(rawData[rowIndex][idxEstLav]).toUpperCase().trim() : '';
                        }

                        const needBloquear = (rutaRaw === 'ACABADA') ? false : (estBloqRaw !== 'OK');
                        const needLavar = (rutaRaw === 'ACABADA') ? false : (estLavRaw !== 'OK');

                        if (needBloquear || needLavar) {
                            // Mensaje específico según el caso
                            let msg = '';
                            if (needBloquear && needLavar) msg = 'Por bloquear y por lavar';
                            else if (needBloquear) msg = 'Por bloquear';
                            else msg = 'Por lavar';

                            // Revertir selección visual al valor anterior
                            const prev = (writeIdx !== undefined && writeIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][writeIdx]) ? rawData[rowIndex][writeIdx] : '';
                            try { if (selectElement) selectElement.value = prev; } catch (e) {}
                            try { if (selectElement) { selectElement.style.border = '2px solid #ef4444'; setTimeout(()=>{ selectElement.style.border=''; }, 1600); } } catch(e){}
                            alert(msg);
                            return; // cancelar guardado
                        }

                        // Si pasa la validación anterior, continuar con la validación existente
                        // localizar índices normalizados para las dos columnas
                        const findBestIndexForRow = function(rIdx, names) {
                            // findColIndexNormalized está definido más arriba en este scope
                            // Priorizar la columna existente cuyo valor en la fila no esté vacía
                            for (let n of names) {
                                const idx = findColIndexNormalized(n);
                                if (idx !== -1) {
                                    const cell = (rawData[rIdx] && rawData[rIdx][idx]) ? String(rawData[rIdx][idx]).trim() : '';
                                    if (cell !== '') return idx;
                                }
                            }
                            // Si no hay ninguna no-vacía, devolver la primera columna existente (si existe)
                            for (let n of names) {
                                const idx = findColIndexNormalized(n);
                                if (idx !== -1) return idx;
                            }
                            return -1;
                        };

                        const bloqCandidates = ['ESTADO BLOQUES','ESTADO_BLOQUES','estado_bloques'];
                        const collCandidates = ['ESTADO COLL TAP','ESTADO_COLL_TAP','estado_coll_tap'];

                        const idxBloqFinal = findBestIndexForRow(rowIndex, bloqCandidates);
                        const idxCollFinal = findBestIndexForRow(rowIndex, collCandidates);

                        const bloqVal = (idxBloqFinal !== -1 && rawData[rowIndex] && rawData[rowIndex][idxBloqFinal]) ? String(rawData[rowIndex][idxBloqFinal]).toUpperCase().trim() : '';
                        const collVal = (idxCollFinal !== -1 && rawData[rowIndex] && rawData[rowIndex][idxCollFinal]) ? String(rawData[rowIndex][idxCollFinal]).toUpperCase().trim() : '';

                        // Validar que no estén en 'LLEVA?' O que no estén vacíos
                        if (bloqVal === 'LLEVA?' || collVal === 'LLEVA?' || bloqVal === '' || collVal === '') {
                            // Revertir selección visual al valor anterior y avisar al usuario
                            const prev = (writeIdx !== undefined && writeIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][writeIdx]) ? rawData[rowIndex][writeIdx] : '';
                            try { if (selectElement) selectElement.value = prev; } catch (e) {}
                            try { if (selectElement) { selectElement.style.border = '2px solid #ef4444'; setTimeout(()=>{ selectElement.style.border=''; }, 1600); } } catch(e){}
                            alert('Completar BLOQUES/COLL/TAP');
                            return; // cancelar guardado y propagación
                        }
                    }
            } catch (e) {
                console.error('Error validación OK Corte:', e);
            }

            if (writeIdx !== undefined && writeIdx !== -1) rawData[rowIndex][writeIdx] = value;
            updateCounters();

            // --- FIX: asegurar que 'estado_enumerado' se actualiza en rawData aunque colMap falle ---
            try {
                const normKey = (colName || '').toString().toLowerCase().replace(/[^a-z0-9]/g, '');
                if (normKey === 'estadoenumerado' || colName === 'estado_enumerado') {
                    const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
                    if (idxEv !== -1) {
                        const vNorm = (value || '').toString().trim();
                        rawData[rowIndex][idxEv] = vNorm;
                        // ensure colMap is aware for future ops
                        colMap['estado_enumerado'] = idxEv;
                        writeIdx = idxEv;
                    }
                }
            } catch (e) { console.error('Error asegurando rawData para estado_enumerado', e); }

            // Loguear intento de guardado para depuración (ver Network/Console)
            try {
                const payloadPreview = { row: rowIndex, colName: (rawData[0] && rawData[0][writeIdx]) ? rawData[0][writeIdx] : colName, value };
                console.log('Sending update to backend (preview):', payloadPreview);
            } catch (e) { console.log('Preview log failed', e); }

            // Si cambiamos el bloqueo a PROG, propagar a todas las filas
            // que tengan el mismo OP-PTDA (OP TELA + PARTIDA).
            if (colName === 'estado_bloqueo') {
                try {
                    if (value === 'PROG' && colMap["OP TELA"] !== undefined && colMap["PARTIDA"] !== undefined) {
                        const opTela = String(rawData[rowIndex][colMap["OP TELA"]] || "").trim().toLowerCase();
                        const partida = String(rawData[rowIndex][colMap["PARTIDA"]] || "").trim().toLowerCase();
                        const key = opTela + "-" + partida;

                        for (let j = 1; j < rawData.length; j++) {
                            if (j === rowIndex) continue;
                            const otherOpTela = String(rawData[j][colMap["OP TELA"]] || "").trim().toLowerCase();
                            const otherPartida = String(rawData[j][colMap["PARTIDA"]] || "").trim().toLowerCase();
                            if ((otherOpTela + "-" + otherPartida) === key) {
                                const prev = rawData[j][colMap['estado_bloqueo']];
                                if (prev !== 'PROG') {
                                    rawData[j][colMap['estado_bloqueo']] = 'PROG';
                                    // Guardar cada cambio en el backend
                                    fetch(WEB_APP_URL, {
                                        method: 'POST',
                                        mode: 'no-cors',
                                        body: JSON.stringify({
                                            action: "update",
                                            row: j,
                                            colName: 'estado_bloqueo',
                                            value: 'PROG'
                                        })
                                    }).catch(e => console.error('Error guardando', e));
                                }
                            }
                        }
                    }
                } catch (err) {
                    console.error('Error propagando PROG:', err);
                }

                // Volver a renderizar las vistas según el nuevo estado de bloqueo
                // Si es PROG, solo necesitamos actualizar Bloqueo (ya propagado a otras filas).
                if (value === 'PROG') {
                    setTimeout(() => renderBloqueo(), 600);
                } else {
                    // Si cambiamos a OK (u otro estado), actualizar todas las vistas relevantes
                    setTimeout(() => {
                        renderBloqueo();
                        renderLavado();
                        renderCorte();
                    }, 600);
                }
            }

            if (colName === 'estado_lavada') {
                setTimeout(() => {
                    renderLavado();
                    renderCorte();
                }, 600);
            }

            if (colName === 'estado_enumerado') {
                // Si cambiamos estado_enumerado, actualizar Enumerado y Habilitado
                setTimeout(() => {
                    renderEnumerado();
                    renderHabilitado();
                }, 600);
            }
            
            if (colName === 'estado_transfer') {
                // Si cambiamos estado_transfer, actualizar Transfer
                setTimeout(() => {
                    renderTransfer();
                }, 600);
            }

            if (colName === 'estado_rib') {
                // Propagar cambios en vista Corte, sub-tabs PROG (1T/2T/3T)
                try {
                    const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                    const isProgSubtab = (currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG');
                    
                    if (onCorteView && isProgSubtab) {
                        propagateToSameOPAndCorteSeries(rowIndex, 'estado_rib', value);
                        // Re-renderizar la vista después de propagar
                        setTimeout(() => { renderCorte(); }, 300);
                    }
                } catch(e) { console.error('Error propagando estado_rib:', e); }
                
                // Cuando se cambia RIB, re-renderizar Bloqueo para habilitar/deshabilitar el select
                try { setTimeout(() => { renderBloqueo(); }, 200); } catch(e) {}
            }

            if (colName === 'n.transfxpda') {
                // Si cambi el n.transfxpda (por ejemplo a 'NO LLEVA'), actualizar Transfer
                setTimeout(() => {
                    renderTransfer();
                }, 600);
            }
            
            // Manejo de cambios en ESTADO_BLOQUES
            if (colName === 'ESTADO_BLOQUES' || colName === 'ESTADO BLOQUES' || colName === 'estado_bloques') {
                console.log('Detectado cambio en ESTADO_BLOQUES');
                try {
                    const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                    const isProgSubtab = (currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG');
                    
                    console.log('Vista Corte activa:', onCorteView, 'Sub-tab PROG:', isProgSubtab, 'Filter:', currentCorteFilter);
                    
                    if (onCorteView && isProgSubtab) {
                        console.log('Llamando a propagateToSameOPAndCorteSeries para ESTADO_BLOQUES');
                        propagateToSameOPAndCorteSeries(rowIndex, colName, value);
                        // Re-renderizar la vista después de propagar
                        setTimeout(() => { renderCorte(); }, 300);
                    }
                } catch(e) { console.error('Error propagando ESTADO_BLOQUES:', e); }
            }
            
            // Manejo de cambios en ESTADO_COLL_TAP
            if (colName === 'ESTADO_COLL_TAP' || colName === 'ESTADO COLL TAP' || colName === 'estado_coll_tap') {
                console.log('Detectado cambio en ESTADO_COLL_TAP');
                try {
                    const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                    const isProgSubtab = (currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG');
                    
                    console.log('Vista Corte activa:', onCorteView, 'Sub-tab PROG:', isProgSubtab, 'Filter:', currentCorteFilter);
                    
                    if (onCorteView && isProgSubtab) {
                        console.log('Llamando a propagateToSameOPAndCorteSeries para ESTADO_COLL_TAP');
                        propagateToSameOPAndCorteSeries(rowIndex, colName, value);
                        // Re-renderizar la vista después de propagar
                        setTimeout(() => { renderCorte(); }, 300);
                    }
                } catch(e) { console.error('Error propagando ESTADO_COLL_TAP:', e); }
            }
            
            if (colName === 'estado_corte_bloques') {
                // Si cambiamos estado_corte_bloques: comportamiento línea-a-línea.
                // 1) Reflejar inmediatamente el valor seleccionado en la celda (evita que quede invisible)
                // 2) Actualizar contadores locales
                // 3) Seguir guardando en el sheet (petición se envía más abajo como siempre)
                try {
                    if (selectElement) {
                        const txt = (selectElement.options && selectElement.selectedIndex >= 0 && selectElement.options[selectElement.selectedIndex]) ? selectElement.options[selectElement.selectedIndex].text : String(value);
                        const td = selectElement.closest && selectElement.closest('td');
                        if (td) td.innerText = txt;
                    }
                } catch (e) { console.error('Error actualizando UI estado_corte_bloques:', e); }

                try { updateCorteBloquesCounters(); } catch (e) {}

                // Re-renderizar la vista en breve para mantener consistencia visual
                setTimeout(() => {
                    renderCorteBloques();
                }, 600);
            }

            if (colName === 'estado_corte' || (typeof colName === 'string' && colName.toUpperCase() === 'STATUS')) {
                try {
                    // Normalizar nombre de columna para buscar índices
                    const opTelaIdx = (colMap["OP TELA"] !== undefined) ? colMap["OP TELA"] : findColIndexNormalized('OP TELA');
                    const partidaIdx = (colMap["PARTIDA"] !== undefined) ? colMap["PARTIDA"] : findColIndexNormalized('PARTIDA');

                    // Decidir si debemos propagar el cambio a todas las filas con la misma OP-PTDA.
                    // Nuevo comportamiento: si el nuevo valor es 'OK' y el usuario está en la vista Corte
                    // en uno de los sub-tabs PROG (PROG 1T/2T/3T), NO propagar; solo mover la fila actual.
                    const valNorm = (value || '').toString().toUpperCase().trim();
                    const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                    const isProgSubtab = (currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG');

                    const shouldPropagate = !(valNorm === 'OK' && onCorteView && isProgSubtab);

                    if (shouldPropagate && opTelaIdx !== -1 && partidaIdx !== -1) {
                        const opTelaBase = String(rawData[rowIndex][opTelaIdx] || '').trim().toLowerCase();
                        const partidaBase = String(rawData[rowIndex][partidaIdx] || '').trim().toLowerCase();
                        const key = opTelaBase + '-' + partidaBase;

                        // Obtener el equipo_corte de la fila actual para propagarlo también
                        const equipoCorteIdx = findColIndexNormalized('equipo_corte');
                        const equipoCorteValue = (equipoCorteIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][equipoCorteIdx]) ? rawData[rowIndex][equipoCorteIdx] : '';

                        for (let j = 1; j < rawData.length; j++) {
                            if (j === rowIndex) continue;
                            const otherOp = String(rawData[j][opTelaIdx] || '').trim().toLowerCase();
                            const otherPart = String(rawData[j][partidaIdx] || '').trim().toLowerCase();
                            if ((otherOp + '-' + otherPart) === key) {
                                const prev = rawData[j][writeIdx];
                                if (prev !== value) {
                                    rawData[j][writeIdx] = value;
                                    // Guardar el cambio en backend (no-cors). Usar colName tal cual fue pasado (STATUS o estado_corte)
                                    fetch(WEB_APP_URL, {
                                        method: 'POST',
                                        mode: 'no-cors',
                                        body: JSON.stringify({ action: 'update', row: j, colName: colName, value: value })
                                    }).catch(e => console.error('Error guardando propagado estado_corte', e));
                                }
                                
                                // Propagar también el equipo_corte si estamos en sub-tab X PROG
                                if (onCorteView && currentCorteFilter === 'X PROG' && equipoCorteIdx !== -1 && equipoCorteValue) {
                                    const prevEquipo = rawData[j][equipoCorteIdx];
                                    if (prevEquipo !== equipoCorteValue) {
                                        rawData[j][equipoCorteIdx] = equipoCorteValue;
                                        // Guardar el cambio de equipo_corte en backend
                                        fetch(WEB_APP_URL, {
                                            method: 'POST',
                                            mode: 'no-cors',
                                            body: JSON.stringify({ action: 'update', row: j, colName: 'equipo_corte', value: equipoCorteValue })
                                        }).catch(e => console.error('Error guardando propagado equipo_corte', e));
                                    }
                                }
                            }
                        }
                    }

                    // Determinar comportamiento según nuevo valor: si es OK -> mostrar Enumerado,
                    // si es un PROG -> ir a Corte y seleccionar sub-tab correspondiente.
                    const tabMap = {
                        'X PROG': 'corte-btn-xprog',
                        'PROG 1T': 'corte-btn-1t',
                        'PROG 2T': 'corte-btn-2t',
                        'PROG 3T': 'corte-btn-3t'
                    };

                    if (valNorm === 'OK') {
                        // Si el cambio a OK se realizó desde un sub-tab de Corte PROG (1T/2T/3T),
                        // mantener la vista y el sub-tab actuales para no desorientar al usuario
                        // y NO propagar (comportamiento aplicado arriba).
                        if (onCorteView && isProgSubtab) {
                            setTimeout(() => { renderEnumerado(); renderCorte(); }, 600);
                        } else {
                            // Seleccionar la vista Enumerado si existe
                            let enumBtn = null;
                            document.querySelectorAll('.nav-tab').forEach(nb => {
                                const onclickAttr = nb.getAttribute('onclick') || '';
                                if (onclickAttr.indexOf("switchView('enumerado'") !== -1) enumBtn = nb;
                            });
                            if (enumBtn) switchView('enumerado', enumBtn);
                            setTimeout(() => { renderEnumerado(); renderCorte(); }, 600);
                        }
                    } else {
                        // Ir a Corte y seleccionar sub-tab correspondiente
                        const btnId = tabMap[valNorm] || tabMap['X PROG'];
                        const subBtn = document.getElementById(btnId);

                        let mainNavBtn = null;
                        document.querySelectorAll('.nav-tab').forEach(nb => {
                            const onclickAttr = nb.getAttribute('onclick') || '';
                            if (onclickAttr.indexOf("switchView('corte'") !== -1) mainNavBtn = nb;
                        });
                        if (mainNavBtn) switchView('corte', mainNavBtn);

                        if (subBtn) {
                            filterCorte(valNorm, subBtn);
                        } else {
                            setTimeout(() => { renderCorte(); }, 600);
                        }
                    }
                } catch (err) {
                    console.error('Error al propagar estado_corte:', err);
                    setTimeout(() => {
                        renderCorte();
                        renderEnumerado();
                    }, 600);
                }
            }

            // Propagar equipo_corte cuando se cambia en sub-tab X PROG
            if (colName === 'equipo_corte') {
                try {
                    const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                    
                    // Solo propagar si estamos en vista Corte y sub-tab X PROG
                    if (onCorteView && currentCorteFilter === 'X PROG') {
                        const opTelaIdx = (colMap["OP TELA"] !== undefined) ? colMap["OP TELA"] : findColIndexNormalized('OP TELA');
                        const partidaIdx = (colMap["PARTIDA"] !== undefined) ? colMap["PARTIDA"] : findColIndexNormalized('PARTIDA');
                        
                        if (opTelaIdx !== -1 && partidaIdx !== -1) {
                            const opTelaBase = String(rawData[rowIndex][opTelaIdx] || '').trim().toLowerCase();
                            const partidaBase = String(rawData[rowIndex][partidaIdx] || '').trim().toLowerCase();
                            const key = opTelaBase + '-' + partidaBase;
                            
                            for (let j = 1; j < rawData.length; j++) {
                                if (j === rowIndex) continue;
                                const otherOp = String(rawData[j][opTelaIdx] || '').trim().toLowerCase();
                                const otherPart = String(rawData[j][partidaIdx] || '').trim().toLowerCase();
                                
                                if ((otherOp + '-' + otherPart) === key) {
                                    const prev = rawData[j][writeIdx];
                                    if (prev !== value) {
                                        rawData[j][writeIdx] = value;
                                        // Guardar el cambio en backend
                                        fetch(WEB_APP_URL, {
                                            method: 'POST',
                                            mode: 'no-cors',
                                            body: JSON.stringify({ action: 'update', row: j, colName: 'equipo_corte', value: value })
                                        }).catch(e => console.error('Error guardando propagado equipo_corte', e));
                                    }
                                }
                            }
                        }
                    }
                    
                    // Re-renderizar la vista Corte después de propagar
                    setTimeout(() => { renderCorte(); }, 600);
                } catch (err) {
                    console.error('Error propagando equipo_corte:', err);
                    setTimeout(() => { renderCorte(); }, 600);
                }
            }

            // Guardar el cambio original (si no fue guardado por la propagación)
            // Enviar al backend el nombre exacto de la cabecera si podemos
            // localizarlo para asegurar que el sheet reciba la columna correcta.
            try {
                let sendColName = colName;
                if (writeIdx !== undefined && writeIdx !== -1 && rawData[0] && rawData[0][writeIdx]) {
                    sendColName = rawData[0][writeIdx];
                } else {
                    // intentar resolver por normalización
                    const found = (function(name){
                        if (!rawData || rawData.length === 0) return -1;
                        const headers = rawData[0];
                        const norm = s => String(s || '').toLowerCase().replace(/[^a-z0-9]/g, '');
                        const target = norm(name);
                        for (let i = 0; i < headers.length; i++) {
                            if (norm(headers[i]) === target) return i;
                        }
                        return -1;
                    })(colName);
                    if (found !== -1 && rawData[0] && rawData[0][found]) sendColName = rawData[0][found];
                }

                fetch(WEB_APP_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: JSON.stringify({
                        action: "update",
                        row: rowIndex,
                        colName: sendColName,
                        value: value
                    })
                }).catch(e => console.error("Error guardando", e));
            } catch (e) {
                console.error('Error preparando guardado:', e);
            }
        };

        window.switchView = function(viewName, btn) {
            document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.nav-tab').forEach(el => el.classList.remove('active'));
            document.getElementById(`view-${viewName}`).classList.add('active');
            btn.classList.add('active');
            // Re-render the view we just activated so dynamic row content
            // (selects shown for Enumerado or Corte sub-tabs) is created
            // while the view has the 'active' class.
            try {
                if (viewName === 'bloqueo') renderBloqueo();
                else if (viewName === 'lavado') renderLavado();
                else if (viewName === 'corte') renderCorte();
                else if (viewName === 'corte-bloques') renderCorteBloques();
                else if (viewName === 'enumerado') renderEnumerado();
                else if (viewName === 'transfer') renderTransfer();
                else if (viewName === 'artes') renderArtes();
                else if (viewName === 'habilitado') renderHabilitado();
            } catch (e) { console.error('Error re-rendering view after switch:', e); }
        };

        // Helper para comparar fechas en formato DD/MMM/YY (ej: 15/Ene/26)
        function compareDates(dateStr1, dateStr2) {
            const monthMap = {
                'ene': 0, 'enero': 0,
                'feb': 1, 'febrero': 1,
                'mar': 2, 'marzo': 2,
                'abr': 3, 'abril': 3,
                'may': 4, 'mayo': 4,
                'jun': 5, 'junio': 5,
                'jul': 6, 'julio': 6,
                'ago': 7, 'agosto': 7,
                'sep': 8, 'septiembre': 8,
                'oct': 9, 'octubre': 9,
                'nov': 10, 'noviembre': 10,
                'dic': 11, 'diciembre': 11
            };
            
            const parseDateStr = (str) => {
                const parts = str.split('/');
                if (parts.length !== 3) return null;
                const day = parseInt(parts[0], 10);
                const month = monthMap[parts[1].toLowerCase()];
                if (month === undefined) return null;
                let year = parseInt(parts[2], 10);
                // Convertir YY a YYYY (26 -> 2026, 50 -> 1950)
                if (year < 100) {
                    year = year < 50 ? 2000 + year : 1900 + year;
                }
                return new Date(year, month, day);
            };
            
            const date1 = parseDateStr(dateStr1);
            const date2 = parseDateStr(dateStr2);
            
            if (!date1 || !date2) return dateStr1.localeCompare(dateStr2);
            return date1 - date2;
        }
        
        window.filterHabilitado = function(filterState, btn) {
            currentHabilitadoFilter = filterState;
            document.querySelectorAll('#view-habilitado .sub-tab').forEach(el => el.classList.remove('active'));
            if (btn) btn.classList.add('active');
            // Limpiar filtro de encabezado cuando se cambia de sub-tab
            habilitadoHeaderFilter = null;
            renderHabilitado();
        };
        
        // Funciones para el menú contextual de filtro en Habilitado
        let habilitadoContextMenuField = null;
        let habilitadoContextMenuX = 0;
        let habilitadoContextMenuY = 0;
        
        window.showHabilitadoContextMenu = function(event, fieldName) {
            // Solo permitir en sub-tab "Por Programar" (X PROG)
            if (currentHabilitadoFilter !== 'X PROG') {
                return;
            }
            
            event.preventDefault();
            event.stopPropagation();
            
            habilitadoContextMenuField = fieldName;
            habilitadoContextMenuX = event.clientX;
            habilitadoContextMenuY = event.clientY;
            
            const menu = document.getElementById('habilitado-context-menu');
            if (!menu) return;
            
            const input = document.getElementById('habilitado-filter-input');
            const select = document.getElementById('habilitado-filter-select');
            
            // Mostrar el menú
            document.getElementById('habilitado-filter-field').textContent = fieldName;
            
            // Campos que usan dropdown
            const dropdownFields = ['HOD', 'F.ING.COST', 'STATUS', 'CLIENTE'];
            
            if (dropdownFields.includes(fieldName)) {
                // Mostrar select y poblar con valores únicos
                input.style.display = 'none';
                select.style.display = 'block';
                select.value = '';
                populateHabilitadoFilterSelect(fieldName);
                select.focus();
            } else {
                // Mostrar input de texto
                select.style.display = 'none';
                input.style.display = 'block';
                input.value = '';
                input.focus();
            }
            
            menu.classList.add('active');
            menu.style.left = habilitadoContextMenuX + 'px';
            menu.style.top = habilitadoContextMenuY + 'px';
        };
        
        function populateHabilitadoFilterSelect(fieldName) {
            const select = document.getElementById('habilitado-filter-select');
            if (!select) return;
            
            // Limpiar opciones existentes (excepto la primera)
            while (select.options.length > 1) {
                select.remove(1);
            }
            
            const values = new Set();
            
            // Iterar sobre los datos válidos (solo X PROG)
            const idxHabil = findHeaderIndexCaseInsensitive('estado_habilitado');
            const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
            
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                
                // Filtrar solo filas que sean X PROG
                let habilVal = '';
                if (idxHabil !== -1 && row[idxHabil] !== undefined) habilVal = row[idxHabil];
                else habilVal = getVal(row, 'estado_habilitado') || getVal(row, 'ESTADO_HABILITADO') || '';
                const habilNorm = (habilVal || '').toString().toUpperCase().trim();
                
                if (habilNorm !== '' && habilNorm !== 'X PROG') continue;
                
                let fieldValue = '';
                
                switch(fieldName) {
                    case 'HOD':
                        fieldValue = formatValue(getVal(row, 'HOD'), 'date') || '';
                        break;
                    case 'F.ING.COST':
                        const rawFIng = getVal(row, 'F.ING.COST');
                        const dateValue = convertToDateInputFormat(rawFIng);
                        fieldValue = formatDateShortFromInput(dateValue) || '';
                        break;
                    case 'STATUS':
                        // STATUS es un valor CALCULADO basado en RUTA TELA y estados
                        const rutaTela = (getVal(row, 'RUTA TELA') || getVal(row, 'RUTA_TELA') || getVal(row, 'RUTA') || '').toString().toUpperCase().trim();
                        const estadoCorte = (getVal(row, 'estado_corte') || getVal(row, 'ESTADO_CORTE') || '').toString().toUpperCase().trim();
                        const estadoBloqueo = (getVal(row, 'estado_bloqueo') || getVal(row, 'ESTADO_BLOQUEO') || '').toString().toUpperCase().trim();
                        const estadoLavada = (getVal(row, 'estado_lavada') || getVal(row, 'ESTADO_LAVADA') || '').toString().toUpperCase().trim();
                        
                        let ev = '';
                        try {
                            if (idxEv !== -1 && row[idxEv] !== undefined) ev = row[idxEv];
                            else ev = getVal(row, 'estado_enumerado') || '';
                        } catch (e) { ev = ''; }
                        const evNorm = (ev || '').toString().toUpperCase().trim();
                        
                        if (rutaTela === 'ACABADA') {
                            if (estadoCorte === '' || estadoCorte === 'X PROG') {
                                fieldValue = 'x cortar';
                            } else if (estadoCorte === 'PROG') {
                                fieldValue = 'Proc Corte';
                            } else if (estadoCorte === 'OK') {
                                if (evNorm === '' || evNorm === 'X PROG') {
                                    fieldValue = 'x enm';
                                } else if (evNorm === 'OK ENM' || evNorm === 'OK PAQUETEO') {
                                    fieldValue = 'x Hab';
                                } else {
                                    fieldValue = 'x enm';
                                }
                            }
                        } else if (rutaTela === 'LAVADA') {
                            if (estadoBloqueo === '' || estadoBloqueo === 'X PROG') {
                                fieldValue = 'x bloq';
                            } else if (estadoBloqueo === 'PROG') {
                                fieldValue = 'x Bloq';
                            } else if (estadoBloqueo === 'OK') {
                                if (estadoLavada !== 'OK') {
                                    fieldValue = 'x lavar';
                                } else {
                                    if (estadoCorte === '' || estadoCorte === 'X PROG') {
                                        fieldValue = 'x cortar';
                                    } else if (estadoCorte === 'PROG 1T' || estadoCorte === 'PROG 2T' || estadoCorte === 'PROG 3T') {
                                        fieldValue = 'Proc Corte';
                                    } else if (estadoCorte === 'OK') {
                                        if (evNorm === 'OK ENM' || evNorm === 'OK PAQUETEO') {
                                            fieldValue = 'x Hab';
                                        } else {
                                            fieldValue = 'x enm';
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case 'CLIENTE':
                        // Usar normalizeClientName para obtener el nombre corto del cliente
                        fieldValue = normalizeClientName(getVal(row, 'CLIENTE')) || '';
                        break;
                }
                
                if (fieldValue) {
                    values.add(fieldValue);
                }
            }
            
            // Agregar opciones al select, ordenadas
            // Si es fecha (HOD o F.ING.COST), ordenar por fecha; si no, alfabético
            const sortedValues = Array.from(values).sort((a, b) => {
                if (fieldName === 'HOD' || fieldName === 'F.ING.COST') {
                    return compareDates(a, b);
                }
                return a.localeCompare(b);
            });
            sortedValues.forEach(value => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value;
                select.appendChild(option);
            });
        }
        
        window.hideHabilitadoContextMenu = function() {
            const menu = document.getElementById('habilitado-context-menu');
            if (menu) menu.classList.remove('active');
            habilitadoContextMenuField = null;
        };
        
        window.clearHabilitadoFilter = function() {
            habilitadoHeaderFilter = null;
            hideHabilitadoContextMenu();
            renderHabilitado();
        };
        
        window.applyHabilitadoFilter = function() {
            if (!habilitadoContextMenuField) {
                hideHabilitadoContextMenu();
                return;
            }
            
            const input = document.getElementById('habilitado-filter-input');
            const select = document.getElementById('habilitado-filter-select');
            
            let filterValue = '';
            
            // Obtener valor del input o select según cuál esté visible
            if (input.style.display !== 'none') {
                filterValue = input.value.trim().toUpperCase();
            } else if (select.style.display !== 'none') {
                filterValue = select.value.trim().toUpperCase();
            }
            
            if (!filterValue) {
                alert('Por favor seleccione o ingrese un valor para filtrar');
                return;
            }
            
            habilitadoHeaderFilter = {
                field: habilitadoContextMenuField,
                value: filterValue
            };
            
            hideHabilitadoContextMenu();
            renderHabilitado();
        };
        
        // Cerrar el menú contextual al hacer click fuera
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('habilitado-context-menu');
            if (menu && !menu.contains(e.target) && e.target !== document.querySelector('thead')) {
                hideHabilitadoContextMenu();
            }
            // También cerrar otros menús contextuales
            const menuBloqueo = document.getElementById('bloqueo-context-menu');
            if (menuBloqueo && !menuBloqueo.contains(e.target)) hideBloqueoContextMenu();
            const menuCorte = document.getElementById('corte-context-menu');
            if (menuCorte && !menuCorte.contains(e.target)) hideCorteContextMenu();
            const menuEnumerado = document.getElementById('enumerado-context-menu');
            if (menuEnumerado && !menuEnumerado.contains(e.target)) hideEnumeradoContextMenu();
        });

        // =============================================
        // FUNCIONES DE FILTRO CONTEXTUAL PARA BLOQUEO
        // =============================================
        let bloqueoContextMenuField = null;
        
        window.showBloqueoContextMenu = function(event, fieldName) {
            if (currentBloqueoFilter !== 'X PROG') return;
            event.preventDefault();
            event.stopPropagation();
            
            bloqueoContextMenuField = fieldName;
            const menu = document.getElementById('bloqueo-context-menu');
            if (!menu) return;
            
            const input = document.getElementById('bloqueo-filter-input');
            const select = document.getElementById('bloqueo-filter-select');
            
            document.getElementById('bloqueo-filter-field').textContent = fieldName;
            
            const dropdownFields = ['HOD', 'F.ING.COST', 'CLIENTE'];
            
            if (dropdownFields.includes(fieldName)) {
                input.style.display = 'none';
                select.style.display = 'block';
                select.value = '';
                populateBloqueoFilterSelect(fieldName);
                select.focus();
            } else {
                select.style.display = 'none';
                input.style.display = 'block';
                input.value = '';
                input.focus();
            }
            
            menu.classList.add('active');
            menu.style.left = event.clientX + 'px';
            menu.style.top = event.clientY + 'px';
        };
        
        window.hideBloqueoContextMenu = function() {
            const menu = document.getElementById('bloqueo-context-menu');
            if (menu) menu.classList.remove('active');
            bloqueoContextMenuField = null;
        };
        
        window.clearBloqueoFilter = function() {
            bloqueoHeaderFilter = null;
            hideBloqueoContextMenu();
            renderBloqueo();
        };
        
        window.applyBloqueoFilter = function() {
            if (!bloqueoContextMenuField) { hideBloqueoContextMenu(); return; }
            
            const input = document.getElementById('bloqueo-filter-input');
            const select = document.getElementById('bloqueo-filter-select');
            let filterValue = '';
            
            if (input.style.display !== 'none') filterValue = input.value.trim().toUpperCase();
            else if (select.style.display !== 'none') filterValue = select.value.trim().toUpperCase();
            
            if (!filterValue) { alert('Por favor seleccione o ingrese un valor para filtrar'); return; }
            
            bloqueoHeaderFilter = { field: bloqueoContextMenuField, value: filterValue };
            hideBloqueoContextMenu();
            renderBloqueo();
        };
        
        function populateBloqueoFilterSelect(fieldName) {
            const select = document.getElementById('bloqueo-filter-select');
            if (!select) return;
            while (select.options.length > 1) select.remove(1);
            
            const values = new Set();
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const rutaTela = (getVal(row, 'RUTA TELA') || '').toString().toUpperCase().trim();
                if (rutaTela !== 'LAVADA') continue;
                const estadoBloqueo = (getVal(row, 'estado_bloqueo') || '').toString().toUpperCase().trim();
                if (estadoBloqueo !== '' && estadoBloqueo !== 'X PROG') continue;
                
                let fieldValue = '';
                switch(fieldName) {
                    case 'HOD': fieldValue = formatValue(getVal(row, 'HOD'), 'date') || ''; break;
                    case 'F.ING.COST':
                        const rawFIng = getVal(row, 'F.ING.COST');
                        const dateValue = convertToDateInputFormat(rawFIng);
                        fieldValue = formatDateShortFromInput(dateValue) || '';
                        break;
                    case 'CLIENTE': fieldValue = normalizeClientName(getVal(row, 'CLIENTE')) || ''; break;
                }
                if (fieldValue) values.add(fieldValue);
            }
            
            // Si es fecha (HOD o F.ING.COST), ordenar por fecha; si no, alfabético
            const sortedValues = Array.from(values).sort((a, b) => {
                if (fieldName === 'HOD' || fieldName === 'F.ING.COST') {
                    return compareDates(a, b);
                }
                return a.localeCompare(b);
            });
            sortedValues.forEach(value => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value;
                select.appendChild(option);
            });
        }
        
        function initializeBloqueoHeaderContextMenus() {
            const allowedFields = ['HOD', 'F.ING.COST', 'CLIENTE', 'OP-PTDA', 'OC', 'COLOR'];
            const thead = document.querySelector('#view-bloqueo table thead');
            if (!thead) return;
            
            thead.querySelectorAll('th').forEach(th => {
                th.oncontextmenu = function(event) {
                    let headerText = th.textContent.trim().replace(/\s+/g, ' ');
                    let matchedField = null;
                    for (let field of allowedFields) {
                        if (headerText.indexOf(field) === 0 || field.indexOf(headerText) === 0) {
                            matchedField = field;
                            break;
                        }
                    }
                    if (matchedField) showBloqueoContextMenu(event, matchedField);
                };
            });
        }

        // =============================================
        // FUNCIONES DE FILTRO CONTEXTUAL PARA CORTE
        // =============================================
        let corteContextMenuField = null;
        
        window.showCorteContextMenu = function(event, fieldName) {
            if (currentCorteFilter !== 'X PROG') return;
            event.preventDefault();
            event.stopPropagation();
            
            corteContextMenuField = fieldName;
            const menu = document.getElementById('corte-context-menu');
            if (!menu) return;
            
            const input = document.getElementById('corte-filter-input');
            const select = document.getElementById('corte-filter-select');
            
            document.getElementById('corte-filter-field').textContent = fieldName;
            
            const dropdownFields = ['HOD', 'F.ING.COST', 'CLIENTE', 'RUTA'];
            
            if (dropdownFields.includes(fieldName)) {
                input.style.display = 'none';
                select.style.display = 'block';
                select.value = '';
                populateCorteFilterSelect(fieldName);
                select.focus();
            } else {
                select.style.display = 'none';
                input.style.display = 'block';
                input.value = '';
                input.focus();
            }
            
            menu.classList.add('active');
            menu.style.left = event.clientX + 'px';
            menu.style.top = event.clientY + 'px';
        };
        
        window.hideCorteContextMenu = function() {
            const menu = document.getElementById('corte-context-menu');
            if (menu) menu.classList.remove('active');
            corteContextMenuField = null;
        };
        
        window.clearCorteFilter = function() {
            corteHeaderFilter = null;
            hideCorteContextMenu();
            renderCorte();
        };
        
        window.applyCorteFilter = function() {
            if (!corteContextMenuField) { hideCorteContextMenu(); return; }
            
            const input = document.getElementById('corte-filter-input');
            const select = document.getElementById('corte-filter-select');
            let filterValue = '';
            
            if (input.style.display !== 'none') filterValue = input.value.trim().toUpperCase();
            else if (select.style.display !== 'none') filterValue = select.value.trim().toUpperCase();
            
            if (!filterValue) { alert('Por favor seleccione o ingrese un valor para filtrar'); return; }
            
            corteHeaderFilter = { field: corteContextMenuField, value: filterValue };
            hideCorteContextMenu();
            renderCorte();
        };
        
        function populateCorteFilterSelect(fieldName) {
            const select = document.getElementById('corte-filter-select');
            if (!select) return;
            while (select.options.length > 1) select.remove(1);
            
            const values = new Set();
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const estadoCorte = (getVal(row, 'estado_corte') || '').toString().toUpperCase().trim();
                if (estadoCorte !== '' && estadoCorte !== 'X PROG') continue;
                
                let fieldValue = '';
                switch(fieldName) {
                    case 'HOD': fieldValue = formatValue(getVal(row, 'HOD'), 'date') || ''; break;
                    case 'F.ING.COST':
                        const rawFIng = getVal(row, 'F.ING.COST');
                        const dateValue = convertToDateInputFormat(rawFIng);
                        fieldValue = formatDateShortFromInput(dateValue) || '';
                        break;
                    case 'CLIENTE': fieldValue = normalizeClientName(getVal(row, 'CLIENTE')) || ''; break;
                    case 'RUTA':
                        const rutaTela = (getVal(row, 'RUTA TELA') || '').toString().toUpperCase().trim();
                        const estadoBloqueo = (getVal(row, 'estado_bloqueo') || '').toString().toUpperCase().trim();
                        const estadoLavada = (getVal(row, 'estado_lavada') || '').toString().toUpperCase().trim();
                        if (rutaTela === 'LAVADA') {
                            if (estadoBloqueo === 'OK' && estadoLavada === 'OK') fieldValue = 'LV-ok';
                            else if (estadoBloqueo !== 'OK') fieldValue = 'x bloq';
                            else if (estadoLavada !== 'OK') fieldValue = 'x lavar';
                        } else if (rutaTela === 'ACABADA') {
                            fieldValue = 'AC';
                        }
                        break;
                }
                if (fieldValue) values.add(fieldValue);
            }
            
            // Si es fecha (HOD o F.ING.COST), ordenar por fecha; si no, alfabético
            const sortedValues = Array.from(values).sort((a, b) => {
                if (fieldName === 'HOD' || fieldName === 'F.ING.COST') {
                    return compareDates(a, b);
                }
                return a.localeCompare(b);
            });
            sortedValues.forEach(value => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value;
                select.appendChild(option);
            });
        }
        
        function initializeCorteHeaderContextMenus() {
            const allowedFields = ['HOD', 'F.ING.COST', 'CLIENTE', 'OP-PTDA', 'RUTA', 'OC', 'COLOR'];
            const thead = document.querySelector('#view-corte table thead');
            if (!thead) return;
            
            thead.querySelectorAll('th').forEach(th => {
                th.oncontextmenu = function(event) {
                    let headerText = th.textContent.trim().replace(/\s+/g, ' ');
                    let matchedField = null;
                    for (let field of allowedFields) {
                        if (headerText.indexOf(field) === 0 || field.indexOf(headerText) === 0) {
                            matchedField = field;
                            break;
                        }
                    }
                    if (matchedField) showCorteContextMenu(event, matchedField);
                };
            });
        }

        // =============================================
        // FUNCIONES DE FILTRO CONTEXTUAL PARA ENUMERADO
        // =============================================
        let enumeradoContextMenuField = null;
        
        window.showEnumeradoContextMenu = function(event, fieldName) {
            event.preventDefault();
            event.stopPropagation();
            
            enumeradoContextMenuField = fieldName;
            const menu = document.getElementById('enumerado-context-menu');
            if (!menu) return;
            
            const input = document.getElementById('enumerado-filter-input');
            const select = document.getElementById('enumerado-filter-select');
            
            document.getElementById('enumerado-filter-field').textContent = fieldName;
            
            const dropdownFields = ['HOD', 'F.ING.COST', 'CLIENTE', 'RUTA'];
            
            if (dropdownFields.includes(fieldName)) {
                input.style.display = 'none';
                select.style.display = 'block';
                select.value = '';
                populateEnumeradoFilterSelect(fieldName);
                select.focus();
            } else {
                select.style.display = 'none';
                input.style.display = 'block';
                input.value = '';
                input.focus();
            }
            
            menu.classList.add('active');
            menu.style.left = event.clientX + 'px';
            menu.style.top = event.clientY + 'px';
        };
        
        window.hideEnumeradoContextMenu = function() {
            const menu = document.getElementById('enumerado-context-menu');
            if (menu) menu.classList.remove('active');
            enumeradoContextMenuField = null;
        };
        
        window.clearEnumeradoFilter = function() {
            enumeradoHeaderFilter = null;
            hideEnumeradoContextMenu();
            renderEnumerado();
        };
        
        window.applyEnumeradoFilter = function() {
            if (!enumeradoContextMenuField) { hideEnumeradoContextMenu(); return; }
            
            const input = document.getElementById('enumerado-filter-input');
            const select = document.getElementById('enumerado-filter-select');
            let filterValue = '';
            
            if (input.style.display !== 'none') filterValue = input.value.trim().toUpperCase();
            else if (select.style.display !== 'none') filterValue = select.value.trim().toUpperCase();
            
            if (!filterValue) { alert('Por favor seleccione o ingrese un valor para filtrar'); return; }
            
            enumeradoHeaderFilter = { field: enumeradoContextMenuField, value: filterValue };
            hideEnumeradoContextMenu();
            renderEnumerado();
        };
        
        function populateEnumeradoFilterSelect(fieldName) {
            const select = document.getElementById('enumerado-filter-select');
            if (!select) return;
            while (select.options.length > 1) select.remove(1);
            
            const values = new Set();
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const estadoCorte = (getVal(row, 'estado_corte') || '').toString().toUpperCase().trim();
                if (estadoCorte !== 'OK') continue;
                const estadoEnumerado = (getVal(row, 'estado_enumerado') || '').toString().toUpperCase().trim();
                if (estadoEnumerado === 'OK ENM' || estadoEnumerado === 'OK PAQUETEO' || estadoEnumerado === 'OK S/ENM') continue;
                
                let fieldValue = '';
                switch(fieldName) {
                    case 'HOD': fieldValue = formatValue(getVal(row, 'HOD'), 'date') || ''; break;
                    case 'F.ING.COST':
                        const rawFIng = getVal(row, 'F.ING.COST');
                        const dateValue = convertToDateInputFormat(rawFIng);
                        fieldValue = formatDateShortFromInput(dateValue) || '';
                        break;
                    case 'CLIENTE': fieldValue = normalizeClientName(getVal(row, 'CLIENTE')) || ''; break;
                    case 'RUTA':
                        const rutaTela = (getVal(row, 'RUTA TELA') || '').toString().toUpperCase().trim();
                        if (rutaTela === 'LAVADA') fieldValue = 'LAVADA';
                        else if (rutaTela === 'ACABADA') fieldValue = 'ACABADA';
                        break;
                }
                if (fieldValue) values.add(fieldValue);
            }
            
            // Si es fecha (HOD o F.ING.COST), ordenar por fecha; si no, alfabético
            const sortedValues = Array.from(values).sort((a, b) => {
                if (fieldName === 'HOD' || fieldName === 'F.ING.COST') {
                    return compareDates(a, b);
                }
                return a.localeCompare(b);
            });
            sortedValues.forEach(value => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value;
                select.appendChild(option);
            });
        }
        
        function initializeEnumeradoHeaderContextMenus() {
            const allowedFields = ['HOD', 'F.ING.COST', 'CLIENTE', 'OP-PTDA', 'RUTA', 'OC', 'COLOR'];
            const thead = document.querySelector('#view-enumerado table thead');
            if (!thead) return;
            
            thead.querySelectorAll('th').forEach(th => {
                th.oncontextmenu = function(event) {
                    let headerText = th.textContent.trim().replace(/\s+/g, ' ');
                    let matchedField = null;
                    for (let field of allowedFields) {
                        if (headerText.indexOf(field) === 0 || field.indexOf(headerText) === 0) {
                            matchedField = field;
                            break;
                        }
                    }
                    if (matchedField) showEnumeradoContextMenu(event, matchedField);
                };
            });
        }

        window.filterBloqueo = function(filterState, btn) {
            currentBloqueoFilter = filterState;
            document.querySelectorAll('#view-bloqueo .sub-tab').forEach(el => el.classList.remove('active'));
            btn.classList.add('active');
            bloqueoHeaderFilter = null; // Limpiar filtro al cambiar de sub-tab
            renderBloqueo();
        };

        window.filterLavado = function(filterState, btn) {
            currentLavadoFilter = filterState;
            document.querySelectorAll('#view-lavado .sub-tab').forEach(el => el.classList.remove('active'));
            btn.classList.add('active');
            renderLavado();
        };

        window.filterCorte = function(filterState, btn) {
            currentCorteFilter = filterState;
            document.querySelectorAll('#view-corte .sub-tab').forEach(el => el.classList.remove('active'));
            btn.classList.add('active');
            corteHeaderFilter = null; // Limpiar filtro al cambiar de sub-tab
                    // Mostrar/ocultar filtros por RUTA solo cuando estemos en 'Por Programar' (X PROG)
                    try {
                        const filtEl = document.getElementById('corte-route-filters');
                        if (filtEl) filtEl.style.display = (filterState === 'X PROG') ? 'flex' : 'none';
                        // Ocultar el switch 'Normal' cuando estemos en Por Programar (X PROG)
                        try {
                            const normalInput = document.getElementById('flt-normal');
                            if (normalInput && normalInput.parentElement) {
                                normalInput.parentElement.style.display = (filterState === 'X PROG') ? 'none' : '';
                            }
                        } catch(e) {}
                    } catch (e) {}
                    // Mostrar/ocultar botón EQ_Corte solo cuando estemos en 'Por Programar' (X PROG)
                    try {
                        const eqBtn = document.getElementById('eqcorte-btn');
                        if (eqBtn) eqBtn.style.display = (filterState === 'X PROG') ? 'inline-flex' : 'none';
                    } catch (e) {}
                    renderCorte();
        };

        // Filter for Corte Bloques (X PROG o PROG)
        window.filterCorteBloques = function(filterState, btn) {
            currentCorteBloquesFilter = filterState;
            document.querySelectorAll('#view-corte-bloques .sub-tab').forEach(el => el.classList.remove('active'));
            if (btn) btn.classList.add('active');
            renderCorteBloques();
        };

        window.filterTransfer = function(filterState, btn) {
            currentTransferFilter = filterState;
            document.querySelectorAll('#view-transfer .sub-tab').forEach(el => el.classList.remove('active'));
            if (btn) btn.classList.add('active');
            
            // Mostrar/ocultar contenedores según el sub-tab
            const normalContainer = document.getElementById('table-container-transfer-normal');
            const asignarContainer = document.getElementById('table-container-transfer-asignar');
            const asignarFilters = document.getElementById('transfer-asignar-filters');
            
            if (filterState === 'ASIGNAR') {
                if (normalContainer) normalContainer.style.display = 'none';
                if (asignarContainer) asignarContainer.style.display = 'block';
                if (asignarFilters) asignarFilters.style.display = 'flex';
                renderTransferAsignar();
            } else {
                if (normalContainer) normalContainer.style.display = 'block';
                if (asignarContainer) asignarContainer.style.display = 'none';
                if (asignarFilters) asignarFilters.style.display = 'none';
                renderTransfer();
            }
        };

        window.filterBordado = function(filterState, btn) {
            window.currentArtesBordadoFilter = filterState;
            document.querySelectorAll('#bordado-subtabs .sub-tab').forEach(el => el.classList.remove('active'));
            if (btn) btn.classList.add('active');
            renderArtesBordado();
        };

        window.currentArtesEstampadoFilter = 'X PROG';
        window.filterEstampado = function(filterState, btn) {
            window.currentArtesEstampadoFilter = filterState;
            document.querySelectorAll('#estampado-subtabs .sub-tab').forEach(el => el.classList.remove('active'));
            if (btn) btn.classList.add('active');
            renderArtesEstampado();
        };

        window.renderTransferAsignar = function() {
            const tbody = document.getElementById('tbody-transfer-asignar');
            if (!tbody) return;
            tbody.innerHTML = '';
            
            // Obtener valores de filtros
            const filterHayDato = document.getElementById('filter-transfer-haydato')?.value || '';
            const filterCliente = document.getElementById('filter-transfer-cliente')?.value || '';
            const filterEstilo = document.getElementById('filter-transfer-estilo')?.value || '';
            
            // Poblar opciones de filtros si están vacíos
            const selectCliente = document.getElementById('filter-transfer-cliente');
            const selectEstilo = document.getElementById('filter-transfer-estilo');
            
            if (selectCliente && selectCliente.options.length <= 1) {
                const clientes = new Set();
                for (let i = 1; i < rawData.length; i++) {
                    const clienteRaw = getVal(rawData[i], 'CLIENTE');
                    const cliente = normalizeClientForTransfer(clienteRaw);
                    if (cliente) clientes.add(cliente);
                }
                Array.from(clientes).sort().forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c;
                    opt.textContent = c;
                    selectCliente.appendChild(opt);
                });
            }
            
            if (selectEstilo) {
                // Reconstruir siempre la lista de estilos según el cliente seleccionado
                selectEstilo.innerHTML = '';
                const defaultOpt = document.createElement('option');
                defaultOpt.value = '';
                defaultOpt.textContent = 'Todos los estilos';
                selectEstilo.appendChild(defaultOpt);

                const estilos = new Set();
                for (let i = 1; i < rawData.length; i++) {
                    const row = rawData[i];
                    const clienteRow = getVal(row, 'CLIENTE');
                    const clienteNorm = normalizeClientForTransfer(clienteRow);
                    // Si hay filtro por cliente, sólo recolectar estilos de ese cliente
                    if (filterCliente && clienteNorm !== filterCliente) continue;
                    const estilo = getVal(row, 'ESTILO');
                    if (estilo) estilos.add(estilo);
                }
                Array.from(estilos).sort().forEach(e => {
                    const opt = document.createElement('option');
                    opt.value = e;
                    opt.textContent = e;
                    selectEstilo.appendChild(opt);
                });

                // Si el estilo actualmente seleccionado ya no existe, resetearlo
                if (filterEstilo) {
                    const exists = Array.from(selectEstilo.options).some(o => o.value === filterEstilo);
                    if (!exists) selectEstilo.value = '';
                    else selectEstilo.value = filterEstilo;
                } else {
                    selectEstilo.value = '';
                }
            }
            
            // Agrupar por CLIENTE + ESTILO único y acumular datos
            const grupoMap = new Map(); // "cliente|estilo" -> { cliente, estilo, totalPds, nTransfValues, rowIndices }
            
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const clienteRaw = getVal(row, 'CLIENTE') || '';
                const cliente = normalizeClientForTransfer(clienteRaw);
                const estilo = getVal(row, 'ESTILO') || '';
                const pds = parseFloat(getVal(row, 'PDS')) || 0;
                
                // Obtener n.transfxpda usando getVal (igual que tipo-transfer)
                const nTransf = (getVal(row, 'n.transfxpda') || getVal(row, 'N.TRANSFXPDA') || getVal(row, 'ntransfxpda') || '').toString().trim();

                // Obtener tipo-transfer (valor por fila)
                const tipoTransfRaw = (getVal(row, 'tipo-transfer') || getVal(row, 'tipo_transfer') || getVal(row, 'TIPO-TRANSFER')) || '';

                // Aplicar filtros
                if (filterCliente && cliente !== filterCliente) continue;
                if (filterEstilo && estilo !== filterEstilo) continue;
                
                if (!estilo) continue;

                const key = cliente + '|' + estilo;
                if (!grupoMap.has(key)) {
                    grupoMap.set(key, {
                        cliente: cliente,
                        estilo: estilo,
                        totalPds: 0,
                        nTransfValues: [],
                        tipoValues: [],
                        rowIndices: []
                    });
                }
                
                const data = grupoMap.get(key);
                data.totalPds += pds;
                data.rowIndices.push(i);
                // Recopilar todos los valores de n.transfxpda
                // Incluir valores numéricos (1, 2, 3...) y "NO LLEVA", excluir vacíos y "LLEVA?"
                const nTransfUpper = nTransf.toUpperCase();
                if (nTransf !== '' && nTransfUpper !== 'LLEVA?') {
                    data.nTransfValues.push(nTransf);
                }
                // Recopilar valores de tipo-transfer para el grupo
                const tipoNorm = (tipoTransfRaw || '').toString().trim();
                if (tipoNorm !== '') data.tipoValues.push(tipoNorm);
            }
            
            // Función para calcular el valor representativo de n.transfxpda
            function calcularNTransfRepresentativo(values) {
                if (!values || values.length === 0) return '';
                
                // Si algún valor contiene "NO LLEVA", retornar "NO LLEVA"
                const hasNoLleva = values.some(v => String(v).toUpperCase().includes('NO LLEVA'));
                if (hasNoLleva) return 'NO LLEVA';
                
                // Filtrar solo valores numéricos
                const numericValues = values
                    .map(v => parseFloat(v))
                    .filter(v => !isNaN(v));
                
                if (numericValues.length === 0) {
                    // Si no hay valores numéricos, retornar el primer valor o vacío
                    return values[0] || '';
                }
                
                // Calcular promedio y redondear al entero más cercano
                const promedio = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;
                const promedioRedondeado = Math.round(promedio);
                
                return String(promedioRedondeado);
            }
            
            // Convertir grupoMap a estiloMap para compatibilidad con el código existente
            const estiloMap = new Map();
            grupoMap.forEach((data, key) => {
                // Usar la función avgTransfByClienteEstilo existente para mayor consistencia
                let nTransfCalculado = avgTransfByClienteEstilo(data.cliente, data.estilo);
                // Si avgTransfByClienteEstilo retorna null, usar el valor calculado localmente como fallback
                if (nTransfCalculado === null) {
                    nTransfCalculado = calcularNTransfRepresentativo(data.nTransfValues);
                }
                // Determinar valor representativo de tipo-transfer para el grupo
                const uniqueTipos = Array.from(new Set((data.tipoValues || []).filter(v => v && v.toString().trim() !== '')));
                const tipoRepresentativo = (uniqueTipos.length === 1) ? uniqueTipos[0] : '';

                // Incluir aquí también grupos con 'NO LLEVA' — este render es para "Asignar #Trf"
                estiloMap.set(key, {
                    cliente: data.cliente,
                    estilo: data.estilo,
                    totalPds: data.totalPds,
                    nTransf: nTransfCalculado || '',
                    tipoTransf: tipoRepresentativo,
                    rowIndices: data.rowIndices
                });
            });
            
            // Renderizar filas agrupadas por CLIENTE + ESTILO
            Array.from(estiloMap.entries()).sort((a, b) => {
                // Ordenar por cliente primero, luego por estilo
                const clienteA = a[1].cliente || '';
                const clienteB = b[1].cliente || '';
                if (clienteA !== clienteB) return clienteA.localeCompare(clienteB);
                return (a[1].estilo || '').localeCompare(b[1].estilo || '');
            }).forEach(([key, data]) => {
                // Aplicar filtro nuevo: Todos / Con dato / Sin dato
                if (filterHayDato === 'CON') {
                    if (!data.nTransf || String(data.nTransf).trim() === '') return;
                } else if (filterHayDato === 'SIN') {
                    if (data.nTransf && String(data.nTransf).trim() !== '') return;
                }
                const tr = document.createElement('tr');

                // CLIENTE
                const tdCliente = document.createElement('td');
                tdCliente.textContent = data.cliente;
                tr.appendChild(tdCliente);
                
                // ESTILO
                const tdEstilo = document.createElement('td');
                tdEstilo.innerHTML = `<strong>${data.estilo}</strong>`;
                tr.appendChild(tdEstilo);

                // OP (usar el primer OP del grupo)
                const tdOP = document.createElement('td');
                let opValue = '';
                if (data.rowIndices && data.rowIndices.length > 0) {
                    opValue = getVal(rawData[data.rowIndices[0]], 'OP') || '';
                }
                tdOP.textContent = opValue;
                tr.appendChild(tdOP);

                // tipo-transfer (valor representativo del grupo) -> mostrar select editable
                const tdTipo = document.createElement('td');
                const selTipo = document.createElement('select');
                selTipo.className = 'table-select sel-tipo-transfer';
                selTipo.setAttribute('data-cliente', data.cliente);
                selTipo.setAttribute('data-estilo', data.estilo);
                // Opciones: LLEVA? (por defecto), NO LLEVA, En pieza, En prenda
                selTipo.innerHTML = `
                    <option value="LLEVA?" ${!data.tipoTransf || data.tipoTransf === 'LLEVA?' ? 'selected' : ''}>LLEVA?</option>
                    <option value="NO LLEVA" ${data.tipoTransf === 'NO LLEVA' ? 'selected' : ''}>NO LLEVA</option>
                    <option value="En pieza" ${data.tipoTransf === 'En pieza' ? 'selected' : ''}>En pieza</option>
                    <option value="En prenda" ${data.tipoTransf === 'En prenda' ? 'selected' : ''}>En prenda</option>
                `;
                selTipo.onchange = function() {
                    handleTipoTransferChange(this);
                };
                tdTipo.appendChild(selTipo);
                tr.appendChild(tdTipo);

                // n.transfxpda (select editable para todo el CLIENTE + ESTILO)
                const tdTransf = document.createElement('td');
                const sel = document.createElement('select');
                sel.className = 'table-select sel-ntransf-transfer';
                sel.setAttribute('data-cliente', data.cliente);
                sel.setAttribute('data-estilo', data.estilo);
                sel.onchange = function() {
                    handleNTransfChange(this);
                };
                // Normalize nTransf to avoid mismatches due to case or surrounding whitespace
                const nValNorm = (data.nTransf || '').toString().toUpperCase().trim();
                sel.innerHTML = `
                    <option value="LLEVA?" ${(nValNorm === '' || nValNorm === 'LLEVA?') ? 'selected' : ''}>LLEVA?</option>
                    <option value="NO LLEVA" ${(nValNorm.indexOf('NO LLEVA') !== -1) ? 'selected' : ''}>NO LLEVA</option>
                    <option value="1" ${(nValNorm === '1') ? 'selected' : ''}>1</option>
                    <option value="2" ${(nValNorm === '2') ? 'selected' : ''}>2</option>
                    <option value="3" ${(nValNorm === '3') ? 'selected' : ''}>3</option>
                    <option value="4" ${(nValNorm === '4') ? 'selected' : ''}>4</option>
                    <option value="5" ${(nValNorm === '5') ? 'selected' : ''}>5</option>
                `;
                tdTransf.appendChild(sel);
                tr.appendChild(tdTransf);
                
                tbody.appendChild(tr);
            });
        };

        // Función para actualizar todas las filas de un CLIENTE + ESTILO específico
        window.updateClienteEstiloTransfer = function(cliente, estilo, value, selectElement) {
            if (!cliente || !estilo) return;
            
            // Mostrar modal de carga al inicio
            const modal = document.getElementById('modal-loading-artes');
            if (modal) modal.classList.add('active');
            
            // Buscar índice de n.transfxpda de forma flexible
            let idx = findHeaderIndexCaseInsensitive('n.transfxpda');
            if (idx === -1) idx = colMap['n.transfxpda'];
            if (idx === -1 || idx === undefined) idx = colMap['N.TRANSFXPDA'];
            if (idx === -1 || idx === undefined) idx = getColIndex('n.transfxpda');
            
            if (idx === -1 || idx === undefined) {
                alert('Error: No se encontró la columna n.transfxpda');
                if (modal) modal.classList.remove('active');
                return;
            }
            
            // Recopilar los índices de las filas a actualizar
            const rowsToUpdate = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const rowClienteRaw = getVal(row, 'CLIENTE') || '';
                const rowCliente = normalizeClientForTransfer(rowClienteRaw);
                const rowEstilo = getVal(row, 'ESTILO');
                
                if (rowCliente === cliente && rowEstilo === estilo) {
                    rowsToUpdate.push(i);
                    // Actualizar en rawData localmente
                    rawData[i][idx] = value;
                }
            }
            
            if (rowsToUpdate.length === 0) {
                alert('No se encontraron filas para actualizar');
                if (modal) modal.classList.remove('active');
                return;
            }
            
            // Deshabilitar el select mientras se guarda
            if (selectElement) selectElement.disabled = true;
            
            // Enviar actualizaciones individuales al backend usando action: 'update'
            let completedCount = 0;
            const totalCount = rowsToUpdate.length;
            
            rowsToUpdate.forEach((rowIndex, i) => {
                // Pequeño delay para no saturar el servidor
                setTimeout(() => {
                    fetch(WEB_APP_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'update',
                            row: rowIndex,
                            colName: 'n.transfxpda',
                            value: value
                        })
                    }).then(() => {
                        completedCount++;
                        if (completedCount === totalCount) {
                            if (selectElement) selectElement.disabled = false;
                            updateCounters();
                            renderTransfer();
                            // Also refresh the 'Asignar #Trf' table if visible so the select reflects the new value
                            try { renderTransferAsignar(); } catch(e) { /* ignore if not present */ }
                            // Cerrar modal de carga cuando todos los datos se hayan actualizado
                            const modal = document.getElementById('modal-loading-artes');
                            if (modal) modal.classList.remove('active');
                        }
                    }).catch(err => {
                        console.error('Error al guardar fila', rowIndex, err);
                        completedCount++;
                        if (completedCount === totalCount) {
                            if (selectElement) selectElement.disabled = false;
                            // Cerrar modal de carga incluso si hay error
                            const modal = document.getElementById('modal-loading-artes');
                            if (modal) modal.classList.remove('active');
                        }
                    });
                }, i * 100); // 100ms de delay entre cada petición
            });
        };

        window.guardarCambiosAsignarTransfer = function() {
            alert('Los cambios se guardan automáticamente al seleccionar un valor para cada estilo.');
        };

        // --- ARTES (Pza) : filtros y renderizado ---
        window.currentArtesFilter = 'BORDADO';
        window.currentArtesBordadoFilter = 'X PROG';

        window.filterArtes = function(filterState, btn) {
            window.currentArtesFilter = filterState;
            document.querySelectorAll('#view-artes .sub-tab').forEach(el => el.classList.remove('active'));
            if (btn) btn.classList.add('active');

            // Mostrar/ocultar subtabs de Bordado/Estampado según la pestaña activa
            try {
                const bordadoSubs = document.getElementById('bordado-subtabs');
                const estampadoSubs = document.getElementById('estampado-subtabs');
                if (filterState === 'BORDADO') { if (bordadoSubs) bordadoSubs.style.display = 'flex'; if (estampadoSubs) estampadoSubs.style.display = 'none'; }
                else if (filterState === 'ESTAMPADO') { if (bordadoSubs) bordadoSubs.style.display = 'none'; if (estampadoSubs) estampadoSubs.style.display = 'flex'; }
                else if (filterState === 'ASIGNAR') { if (bordadoSubs) bordadoSubs.style.display = 'none'; if (estampadoSubs) estampadoSubs.style.display = 'none'; }
                else { if (bordadoSubs) bordadoSubs.style.display = 'flex'; if (estampadoSubs) estampadoSubs.style.display = 'none'; }
            } catch(e) {}

            const bordadoContainer = document.getElementById('table-container-artes-bordado');
            const estampadoContainer = document.getElementById('table-container-artes-estampado');
            const asignarContainer = document.getElementById('table-container-artes-asignar');
            const asignarFilters = document.getElementById('artes-asignar-filters');

            if (filterState === 'ASIGNAR') {
                if (bordadoContainer) bordadoContainer.style.display = 'none';
                if (estampadoContainer) estampadoContainer.style.display = 'none';
                if (asignarContainer) asignarContainer.style.display = 'block';
                if (asignarFilters) asignarFilters.style.display = 'flex';
                renderArtesAsignar();
            } else if (filterState === 'ESTAMPADO') {
                if (bordadoContainer) bordadoContainer.style.display = 'none';
                if (estampadoContainer) estampadoContainer.style.display = 'block';
                if (asignarContainer) asignarContainer.style.display = 'none';
                if (asignarFilters) asignarFilters.style.display = 'none';
                // Asegurar que el sub-tab interno de Estampado muestre el estado "activo"
                try {
                    const subs = document.querySelectorAll('#estampado-subtabs .sub-tab');
                    subs.forEach(el => el.classList.remove('active'));
                    const btnId = (window.currentArtesEstampadoFilter && window.currentArtesEstampadoFilter.toUpperCase().indexOf('PROG') !== -1 && window.currentArtesEstampadoFilter.toUpperCase() !== 'X PROG') ? 'btn-estampado-prog' : 'btn-estampado-xprog';
                    const btn = document.getElementById(btnId);
                    if (btn) btn.classList.add('active');
                } catch(e) {}
                renderArtesEstampado();
            } else {
                if (bordadoContainer) bordadoContainer.style.display = 'block';
                if (estampadoContainer) estampadoContainer.style.display = 'none';
                if (asignarContainer) asignarContainer.style.display = 'none';
                if (asignarFilters) asignarFilters.style.display = 'none';
                // Asegurar que el sub-tab interno de Bordado muestre el estado "activo"
                try {
                    const subs = document.querySelectorAll('#bordado-subtabs .sub-tab');
                    subs.forEach(el => el.classList.remove('active'));
                    const btnId = (window.currentArtesBordadoFilter && window.currentArtesBordadoFilter.toUpperCase().indexOf('PROG') !== -1 && window.currentArtesBordadoFilter.toUpperCase() !== 'X PROG') ? 'btn-bordado-prog' : 'btn-bordado-xprog';
                    const btn = document.getElementById(btnId);
                    if (btn) btn.classList.add('active');
                } catch(e) {}
                renderArtesBordado();
            }
        };

        window.renderArtes = function() {
            if (window.currentArtesFilter === 'ASIGNAR') renderArtesAsignar();
            else if (window.currentArtesFilter === 'ESTAMPADO') renderArtesEstampado();
            else renderArtesBordado();
        };

        window.renderArtesBordado = function() {
            const tbody = document.getElementById('tbody-artes-bordado');
            if (!tbody) return; tbody.innerHTML = '';
            let lastOpPtda = null;
            let currentGroup = 'a'; // Para alternar sombreado de filas
            // actualizar badges de sub-tabs Bordado (sumar PDS en lugar de contar filas)
            let pdsX = 0, pdsProg = 0;
            const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                let ev = '';
                try {
                    if (idxEv !== -1 && row && row[idxEv] !== undefined) ev = row[idxEv];
                    else ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO ENUMERADO') || getVal(row, 'ESTADO_ENumerado') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || '' }
                const evNorm = (ev || '').toString().toUpperCase().trim();
                if (!(evNorm === 'OK PAQUETEO' || evNorm === 'OK ENM' || evNorm === 'OK S/ENM')) continue;

                // Filtrar por n.BDxpda: mostrar solo si es vacío o 1-4; excluir si indica NO LLEVA
                const rawNbd = getVal(row, 'n.BDxpda') || getVal(row, 'N.BDXPDA') || getVal(row, 'n.BDxpda ') || '';
                const nbdNorm = (rawNbd || '').toString().toUpperCase().trim();
                if (nbdNorm.indexOf('NO LLEVA') !== -1) continue;
                if (nbdNorm !== '' && ['1','2','3','4'].indexOf(nbdNorm) === -1) continue;

                // determinar estado_bordado normalizado (vacío => 'X PROG')
                let rawEstadoB = getVal(row, 'estado_bordado') || '';
                let estadoBNorm = (rawEstadoB || '').toString().trim();
                if (estadoBNorm === '') estadoBNorm = 'X PROG';
                // contar PDS para badges (sumar PDS GIRADAS / PDS)
                const pdsVal = parseFloat(getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || 0) || 0;
                if (estadoBNorm.toUpperCase().indexOf('PROG') !== -1 && estadoBNorm.toUpperCase() !== 'X PROG') pdsProg += pdsVal;
                else pdsX += pdsVal;

                // Aplicar filtro por sub-tab (X PROG / PROG)
                if (window.currentArtesBordadoFilter) {
                    if (window.currentArtesBordadoFilter === 'PROG') {
                        if (!(estadoBNorm.toUpperCase().indexOf('PROG') !== -1 && estadoBNorm.toUpperCase() !== 'X PROG')) continue;
                    } else {
                        // X PROG
                        if (!(estadoBNorm.toUpperCase() === 'X PROG' || estadoBNorm === '')) continue;
                    }
                }

                const tr = document.createElement('tr');

                // HOD (formateada)
                const tdFDesp = document.createElement('td'); tdFDesp.className = 'date-cell';
                tdFDesp.innerText = formatValue(getVal(row, 'HOD') || getVal(row, 'F DESPACHO') || '', 'date');
                tr.appendChild(tdFDesp);

                // F.ING.COST - mostrar como texto en X PROG (no editable)
                const tdFCost = document.createElement('td'); tdFCost.className = 'date-cell';
                if (window.currentArtesBordadoFilter === 'X PROG') {
                    tdFCost.innerText = formatValue(getVal(row, 'F.ING.COST') || getVal(row, 'F ING COST') || '', 'date');
                } else {
                    const rawFIngCost = getVal(row, 'F.ING.COST') || getVal(row, 'F ING COST') || '';
                    const dateValue = convertToDateInputFormat(rawFIngCost);
                    tdFCost.innerHTML = `<input type="date" class="short-year" value="${dateValue}" onchange="handleDateChange(this, ${i}, 'F.ING.COST')"><span class="date-yy">${formatDateShortFromInput(dateValue) || 'mm/dd/aaaa'}</span>`;
                    // Inicializar evento onclick del span
                    setTimeout(() => {
                        const inputEl = tdFCost.querySelector('input.short-year');
                        const spanEl = tdFCost.querySelector('span.date-yy');
                        if (inputEl && spanEl) {
                            spanEl.onclick = function(e) {
                                e.stopPropagation();
                                inputEl.showPicker ? inputEl.showPicker() : inputEl.click();
                            };
                        }
                    }, 0);
                }
                tr.appendChild(tdFCost);

                // CLIENTE (normalizado)
                const tdCliente = document.createElement('td'); tdCliente.innerText = normalizeClientForTransfer(getVal(row, 'CLIENTE') || ''); tr.appendChild(tdCliente);

                // OC
                const tdOC = document.createElement('td');
                let ocVal = getVal(row, 'OC') || '';
                if ((!ocVal || String(ocVal).trim() === '')) {
                    const opVal = getVal(row, 'OP') || getVal(row, 'OP TELA') || getVal(row, 'OP-PTDA') || '';
                    const corteVal = getVal(row, 'CORTE') || getVal(row, 'PARTIDA') || '';
                    if (opVal && corteVal) ocVal = `${String(opVal).trim()}-${String(corteVal).trim()}`;
                }
                tdOC.innerText = ocVal; tr.appendChild(tdOC);

                // COLOR
                const tdColor = document.createElement('td'); tdColor.innerText = abbreviateHeather(getVal(row, 'COLOR') || ''); tr.appendChild(tdColor);

                // PDS
                const tdPds = document.createElement('td'); tdPds.style.textAlign = 'center'; tdPds.innerText = getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || ''; tr.appendChild(tdPds);

                // PRENDA
                const tdPrenda = document.createElement('td'); tdPrenda.innerText = getVal(row, 'PRENDA') || ''; tr.appendChild(tdPrenda);

                // TIPO CERT.
                const tdTipo = document.createElement('td'); tdTipo.innerText = getVal(row, 'TIPO CERT.') || getVal(row, 'TIPO CERTIFICADO') || ''; tr.appendChild(tdTipo);

                // n.BDxpda (nuevo)
                const tdNbd = document.createElement('td');
                const valNbd = getVal(row, 'n.BDxpda') || getVal(row, 'N.BDXPDA') || getVal(row, 'n.BDx pda') || '';
                tdNbd.innerText = valNbd;
                tr.appendChild(tdNbd);

                // estado_bordado -> mostrar como texto en X PROG, sino select editable
                const tdEst = document.createElement('td');
                if (window.currentArtesBordadoFilter === 'X PROG') {
                    tdEst.innerText = estadoBNorm;
                } else {
                    const selEst = document.createElement('select');
                    selEst.className = 'table-select';
                    selEst.innerHTML = `<option value="X PROG" ${estadoBNorm === 'X PROG' ? 'selected' : ''}>X PROG</option><option value="PROG" ${estadoBNorm.toUpperCase().indexOf('PROG')!==-1 && estadoBNorm.toUpperCase()!=='X PROG' ? 'selected' : ''}>PROG</option>`;
                    selEst.onchange = function(){ updateRow(i, 'estado_bordado', this.value, this); setTimeout(()=>{ renderArtesBordado(); updateCounters(); }, 300); };
                    tdEst.appendChild(selEst);
                }
                tr.appendChild(tdEst);

                // Alternar sombreado por OP-PTDA
                const opTela = String(row[colMap["OP TELA"]] || "").trim();
                const partida = String(row[colMap["PARTIDA"]] || "").trim();
                const currentOpPtda = `${opTela}-${partida}`;
                if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                    currentGroup = (currentGroup === 'a') ? 'b' : 'a';
                }
                lastOpPtda = currentOpPtda;
                tr.classList.add(`group-${currentGroup}`);

                tbody.appendChild(tr);
            }
            // actualizar badges de subtabs
            try { document.getElementById('artes-bordado-xprog-count').innerText = `[${formatThousands(pdsX,0)}pds]`; } catch(e){}
            try { document.getElementById('artes-bordado-prog-count').innerText = `[${formatThousands(pdsProg,0)}pds]`; } catch(e){}
            // actualizar badge del botón padre (suma de X PROG + PROG)
            try { document.getElementById('artes-pds-bordado').innerText = `[${formatThousands((pdsX||0) + (pdsProg||0),0)}pds]`; } catch(e){}
            
            // Inicializar eventos de los selectores de fecha
            initializeDateInputs();
        };

        window.renderArtesEstampado = function() {
            const tbody = document.getElementById('tbody-artes-estampado');
            if (!tbody) return; tbody.innerHTML = '';

            // Recolectar índices válidos según las reglas previas
            let pdsX = 0, pdsProg = 0;
            const validIndices = [];
            const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                let ev = '';
                try {
                    if (idxEv !== -1 && row && row[idxEv] !== undefined) ev = row[idxEv];
                    else ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO ENUMERADO') || getVal(row, 'ESTADO_ENumerado') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || '' }
                const evNorm = (ev || '').toString().toUpperCase().trim();
                if (!(evNorm === 'OK PAQUETEO' || evNorm === 'OK ENM' || evNorm === 'OK S/ENM')) continue;

                const rawNest = getVal(row, 'n.ESTAMPxpda') || getVal(row, 'N.ESTAMPXPDA') || getVal(row, 'n.ESTAMP xpda') || '';
                const nestNorm = (rawNest || '').toString().toUpperCase().trim();
                if (nestNorm.indexOf('NO LLEVA') !== -1) continue;
                if (nestNorm !== '' && ['1','2','3','4'].indexOf(nestNorm) === -1) continue;

                let rawEstado = getVal(row, 'estado_estampado') || '';
                let estadoNorm = (rawEstado || '').toString().trim();
                if (estadoNorm === '') estadoNorm = 'X PROG';
                const grupoKey = (estadoNorm.toUpperCase().indexOf('PROG') !== -1 && estadoNorm.toUpperCase() !== 'X PROG') ? 'PROG' : 'X PROG';

                const pdsVal = parseFloat(getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || 0) || 0;
                if (grupoKey === 'X PROG') pdsX += pdsVal; else pdsProg += pdsVal;
                validIndices.push(i);
            }

            // ordenar por OP-PTDA para mantener consistencia visual
            let sorted = validIndices;
            try { sorted = sortBloqueoData(sorted); } catch (e) { /* ignore */ }

            // Renderizar lista plana según sub-tab activo (no headers)
            let lastOpPtda = null;
            let currentGroupClass = 'a';
            sorted.forEach(i => {
                const row = rawData[i];
                let rawEstado = getVal(row, 'estado_estampado') || '';
                let estadoNorm = (rawEstado || '').toString().trim();
                if (estadoNorm === '') estadoNorm = 'X PROG';
                const grupoKey = (estadoNorm.toUpperCase().indexOf('PROG') !== -1 && estadoNorm.toUpperCase() !== 'X PROG') ? 'PROG' : 'X PROG';

                if (grupoKey !== window.currentArtesEstampadoFilter) return; // mostrar solo el sub-tab activo

                const opTela = String(getVal(row, 'OP TELA') || '').trim();
                const partida = String(getVal(row, 'PARTIDA') || '').trim();
                const currentOpPtda = `${opTela}-${partida}`;
                if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                    currentGroupClass = (currentGroupClass === 'a') ? 'b' : 'a';
                }
                lastOpPtda = currentOpPtda;

                const tr = document.createElement('tr');
                tr.className = `grupo-${currentGroupClass}`;

                // HOD
                const tdFDesp = document.createElement('td'); tdFDesp.className = 'date-cell'; tdFDesp.innerText = formatValue(getVal(row, 'HOD') || getVal(row, 'F DESPACHO') || '', 'date'); tr.appendChild(tdFDesp);
                // F.ING.COST - mostrar como texto en X PROG (no editable)
                const tdFCost = document.createElement('td'); tdFCost.className = 'date-cell';
                if (window.currentArtesEstampadoFilter === 'X PROG') {
                    tdFCost.innerText = formatValue(getVal(row, 'F.ING.COST') || getVal(row, 'F ING COST') || '', 'date');
                } else {
                    const rawFIngCost = getVal(row, 'F.ING.COST') || getVal(row, 'F ING COST') || '';
                    const dateValue = convertToDateInputFormat(rawFIngCost);
                    tdFCost.innerHTML = `<input type="date" class="short-year" value="${dateValue}" onchange="handleDateChange(this, ${i}, 'F.ING.COST')"><span class="date-yy">${formatDateShortFromInput(dateValue) || 'mm/dd/aaaa'}</span>`;
                    // Inicializar evento onclick del span
                    setTimeout(() => {
                        const inputEl = tdFCost.querySelector('input.short-year');
                        const spanEl = tdFCost.querySelector('span.date-yy');
                        if (inputEl && spanEl) {
                            spanEl.onclick = function(e) {
                                e.stopPropagation();
                                inputEl.showPicker ? inputEl.showPicker() : inputEl.click();
                            };
                        }
                    }, 0);
                }
                tr.appendChild(tdFCost);
                // CLIENTE
                const tdCliente = document.createElement('td'); tdCliente.innerText = normalizeClientForTransfer(getVal(row, 'CLIENTE') || ''); tr.appendChild(tdCliente);
                // OC
                const tdOC = document.createElement('td'); let ocVal = getVal(row, 'OC') || ''; if ((!ocVal || String(ocVal).trim() === '')) { const opVal = getVal(row, 'OP') || getVal(row, 'OP TELA') || getVal(row, 'OP-PTDA') || ''; const corteVal = getVal(row, 'CORTE') || getVal(row, 'PARTIDA') || ''; if (opVal && corteVal) ocVal = `${String(opVal).trim()}-${String(corteVal).trim()}`; } tdOC.innerText = ocVal; tr.appendChild(tdOC);
                // COLOR
                const tdColor = document.createElement('td'); tdColor.innerText = abbreviateHeather(getVal(row, 'COLOR') || ''); tr.appendChild(tdColor);
                // PDS
                const tdPds = document.createElement('td'); tdPds.style.textAlign = 'center'; tdPds.innerText = formatThousands(parseFloat(getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || 0) || 0, 0); tr.appendChild(tdPds);
                // PRENDA
                const tdPrenda = document.createElement('td'); tdPrenda.innerText = getVal(row, 'PRENDA') || ''; tr.appendChild(tdPrenda);
                // TIPO CERT.
                const tdTipo = document.createElement('td'); tdTipo.innerText = getVal(row, 'TIPO CERT.') || getVal(row, 'TIPO CERTIFICADO') || ''; tr.appendChild(tdTipo);
                // n.ESTAMPxpda
                const tdNest = document.createElement('td'); const valNest = getVal(row, 'n.ESTAMPxpda') || getVal(row, 'N.ESTAMPXPDA') || getVal(row, 'n.ESTAMP xpda') || ''; tdNest.innerText = valNest; tr.appendChild(tdNest);

                // estado_estampado -> mostrar como texto en X PROG, sino select editable
                const tdEst = document.createElement('td');
                if (window.currentArtesEstampadoFilter === 'X PROG') {
                    tdEst.innerText = estadoNorm;
                } else {
                    const selEst = document.createElement('select'); selEst.className = 'table-select';
                    selEst.innerHTML = `<option value="X PROG" ${estadoNorm === 'X PROG' ? 'selected' : ''}>X PROG</option><option value="PROG" ${estadoNorm.toUpperCase().indexOf('PROG')!==-1 && estadoNorm.toUpperCase()!=='X PROG' ? 'selected' : ''}>PROG</option>`;
                    selEst.onchange = function(){ updateRow(i, 'estado_estampado', this.value, this); setTimeout(()=>{ renderArtesEstampado(); updateCounters(); }, 300); };
                    tdEst.appendChild(selEst);
                }
                tr.appendChild(tdEst);

                tbody.appendChild(tr);
            });

            // actualizar badges de subtabs Estampado
            try { document.getElementById('artes-estampado-xprog-count').innerText = `[${formatThousands(pdsX||0,0)}pds]`; } catch(e){}
            try { document.getElementById('artes-estampado-prog-count').innerText = `[${formatThousands(pdsProg||0,0)}pds]`; } catch(e){}
            // actualizar badge del botón padre (suma de X PROG + PROG)
            try { document.getElementById('artes-pds-estampado').innerText = `[${formatThousands((pdsX||0) + (pdsProg||0),0)}pds]`; } catch(e){}
            
            // Inicializar eventos de los selectores de fecha
            initializeDateInputs();
        };

        window.renderArtesAsignar = function() {
            const tbody = document.getElementById('tbody-artes-asignar');
            if (!tbody) return; tbody.innerHTML = '';

            // Poblar selects de cliente y estilo
            const selectCliente = document.getElementById('filter-artes-cliente');
            const selectEstilo = document.getElementById('filter-artes-estilo');
            const filterCliente = document.getElementById('filter-artes-cliente')?.value || '';
            const filterEstilo = document.getElementById('filter-artes-estilo')?.value || '';

            if (selectCliente && selectCliente.options.length <= 1) {
                const clientes = new Set();
                for (let i = 1; i < rawData.length; i++) {
                    const clienteRaw = getVal(rawData[i], 'CLIENTE');
                    const clienteNorm = normalizeClientForTransfer(clienteRaw || '');
                    if (clienteNorm) clientes.add(clienteNorm);
                }
                Array.from(clientes).sort().forEach(c => {
                    const opt = document.createElement('option'); opt.value = c; opt.textContent = c; selectCliente.appendChild(opt);
                });
            }

            if (selectEstilo) {
                selectEstilo.innerHTML = '';
                const defaultOpt = document.createElement('option'); defaultOpt.value = ''; defaultOpt.textContent = 'Todos los estilos'; selectEstilo.appendChild(defaultOpt);
                const estilos = new Set();
                for (let i = 1; i < rawData.length; i++) {
                    const row = rawData[i];
                    const clienteRow = normalizeClientForTransfer(getVal(row,'CLIENTE') || '');
                    if (filterCliente && clienteRow !== filterCliente) continue;
                    const estilo = getVal(row,'ESTILO'); if (estilo) estilos.add(estilo);
                }
                Array.from(estilos).sort().forEach(e => { const opt = document.createElement('option'); opt.value = e; opt.textContent = e; selectEstilo.appendChild(opt); });
                if (filterEstilo) {
                    const exists = Array.from(selectEstilo.options).some(o => o.value === filterEstilo);
                    if (!exists) selectEstilo.value = '';
                    else selectEstilo.value = filterEstilo;
                }
            }

            // Agrupar por CLIENTE|ESTILO
            const grupo = new Map();
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const cliente = normalizeClientForTransfer(getVal(row,'CLIENTE') || '');
                const estilo = getVal(row,'ESTILO') || '';
                if (!estilo) continue;
                if (filterCliente && cliente !== filterCliente) continue;
                if (filterEstilo && estilo !== filterEstilo) continue;
                const key = cliente + '|' + estilo;
                if (!grupo.has(key)) grupo.set(key, {cliente, estilo, rows: []});
                grupo.get(key).rows.push(i);
            }

            Array.from(grupo.values()).sort((a,b)=> (a.cliente||'').localeCompare(b.cliente) || (a.estilo||'').localeCompare(b.estilo)).forEach(g => {
                // calcular representativos para n.BDxpda y n.ESTAMPxpda
                function calcularRepresentativo(colName) {
                    let idx = getColIndex(colName);
                    if (idx === -1) {
                        for (const k in colMap) { if (k.toString().toUpperCase().indexOf(colName.toUpperCase())!==-1) { idx = colMap[k]; break; } }
                    }
                    
                    const valores = [];
                    const counts = {};
                    let hasNoLleva = false;
                    let emptyCount = 0;
                    
                    for (const rIdx of g.rows) {
                        const rv = (idx !== -1 && idx !== undefined) ? rawData[rIdx][idx] : getVal(rawData[rIdx], colName);
                        const v = (rv === undefined || rv === null) ? '' : String(rv).trim();
                        
                        if (v === '' || v.toUpperCase() === 'LLEVA?') {
                            emptyCount++;
                            continue;
                        }
                        
                        if (v.toUpperCase() === 'NO LLEVA') {
                            hasNoLleva = true;
                            continue;
                        }
                        
                        valores.push(v);
                        const vNorm = v.toUpperCase();
                        counts[vNorm] = (counts[vNorm] || 0) + 1;
                    }
                    
                    // Si todas las filas están vacías, retornar LLEVA?
                    if (emptyCount === g.rows.length) return 'LLEVA?';
                    
                    // Si hay "NO LLEVA", priorizar
                    if (hasNoLleva) return 'NO LLEVA';
                    
                    // Si no hay valores después de filtrar vacíos y NO LLEVA
                    if (valores.length === 0) return 'LLEVA?';
                    
                    // Verificar si son numéricos para calcular promedio
                    const numericos = valores.map(v => parseFloat(v)).filter(n => !isNaN(n));
                    
                    if (numericos.length > 0 && numericos.length === valores.length) {
                        // Todos son numéricos, calcular promedio y redondear
                        const promedio = numericos.reduce((a, b) => a + b, 0) / numericos.length;
                        const redondeado = Math.round(promedio);
                        // Asegurar que esté en el rango 1-4
                        if (redondeado >= 1 && redondeado <= 4) return String(redondeado);
                        return String(redondeado);
                    }
                    
                    // Si son textos, retornar el más frecuente
                    let best = ''; let bestC = 0;
                    for (const k in counts) {
                        if (counts[k] > bestC) { best = k; bestC = counts[k]; }
                    }
                    return best || 'LLEVA?';
                }

                const repBD = calcularRepresentativo('n.BDxpda');
                const repEST = calcularRepresentativo('n.ESTAMPxpda');

                // aplicar filtro HayDato (CON/SIN) inspeccionando filas reales del grupo
                // CON: mostrar grupos donde exista AL MENOS UNA fila con AMBAS columnas (BD y EST) llenas
                // SIN: mostrar grupos donde exista AL MENOS UNA fila con BD o EST vacía
                const uiFilterHayDato = document.getElementById('filter-artes-haydato')?.value || '';
                let anyRowBothFilled = false;
                let anyRowMissingBDorEST = false;
                // localizar índices si es posible
                let idxBD = getColIndex('n.BDxpda');
                if (idxBD === -1) {
                    for (const k in colMap) { if (k.toString().toUpperCase().indexOf('N.BDXPDA')!==-1) { idxBD = colMap[k]; break; } }
                }
                let idxEST = getColIndex('n.ESTAMPxpda');
                if (idxEST === -1) {
                    for (const k in colMap) { if (k.toString().toUpperCase().indexOf('N.ESTAMPXPDA')!==-1) { idxEST = colMap[k]; break; } }
                }
                for (const rIdx of g.rows) {
                    const rawBD = (idxBD !== -1 && idxBD !== undefined) ? (rawData[rIdx][idxBD] || '') : (getVal(rawData[rIdx],'n.BDxpda') || '');
                    const rawEST = (idxEST !== -1 && idxEST !== undefined) ? (rawData[rIdx][idxEST] || '') : (getVal(rawData[rIdx],'n.ESTAMPxpda') || '');
                    const normBD = (rawBD||'').toString().trim();
                    const normEST = (rawEST||'').toString().trim();
                    const bdHas = (normBD !== '' && normBD.toUpperCase() !== 'LLEVA?');
                    const estHas = (normEST !== '' && normEST.toUpperCase() !== 'LLEVA?');
                    if (bdHas && estHas) anyRowBothFilled = true;
                    if (!bdHas || !estHas) anyRowMissingBDorEST = true;
                }

                if (uiFilterHayDato === 'CON') {
                    if (!anyRowBothFilled) return; // no hay ninguna fila con ambas columnas llenas -> saltar
                } else if (uiFilterHayDato === 'SIN') {
                    if (!anyRowMissingBDorEST) return; // ninguna fila con columna vacía -> saltar
                }

                const tr = document.createElement('tr');
                const tdCliente = document.createElement('td'); tdCliente.textContent = normalizeClientForTransfer(g.cliente || ''); tr.appendChild(tdCliente);
                const tdEstilo = document.createElement('td'); tdEstilo.innerHTML = `<strong>${g.estilo}</strong>`; tr.appendChild(tdEstilo);

                // Agregar columna OP (usar el primer OP del grupo)
                const tdOP = document.createElement('td');
                let opValue = '';
                if (g.rows.length > 0) {
                    opValue = getVal(rawData[g.rows[0]], 'OP') || '';
                }
                tdOP.textContent = opValue;
                tr.appendChild(tdOP);

                const tdBord = document.createElement('td');
                const selB = document.createElement('select'); selB.className='table-select sel-nbd-artes';
                selB.setAttribute('data-cliente', g.cliente); selB.setAttribute('data-estilo', g.estilo);
                selB.innerHTML = `<option value="LLEVA?">LLEVA?</option><option value="NO LLEVA">NO LLEVA</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option>`;
                // Asignar valor representativo al select
                if (repBD && repBD !== '') {
                    // Verificar si el valor existe como opción
                    const existeOpcion = Array.from(selB.options).some(opt => opt.value.toUpperCase() === repBD.toUpperCase());
                    if (existeOpcion) {
                        selB.value = Array.from(selB.options).find(opt => opt.value.toUpperCase() === repBD.toUpperCase()).value;
                    } else {
                        // Agregar opción personalizada si no existe
                        const newOpt = document.createElement('option');
                        newOpt.value = repBD;
                        newOpt.textContent = repBD;
                        selB.appendChild(newOpt);
                        selB.value = repBD;
                    }
                } else {
                    selB.value = 'LLEVA?';
                }
                selB.onchange = function(){ handleNBDChange(this); };
                tdBord.appendChild(selB); tr.appendChild(tdBord);

                const tdEst = document.createElement('td');
                const selE = document.createElement('select'); selE.className='table-select sel-nest-artes';
                selE.setAttribute('data-cliente', g.cliente); selE.setAttribute('data-estilo', g.estilo);
                selE.innerHTML = `<option value="LLEVA?">LLEVA?</option><option value="NO LLEVA">NO LLEVA</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option>`;
                // Asignar valor representativo al select
                if (repEST && repEST !== '') {
                    // Verificar si el valor existe como opción
                    const existeOpcionE = Array.from(selE.options).some(opt => opt.value.toUpperCase() === repEST.toUpperCase());
                    if (existeOpcionE) {
                        selE.value = Array.from(selE.options).find(opt => opt.value.toUpperCase() === repEST.toUpperCase()).value;
                    } else {
                        // Agregar opción personalizada si no existe
                        const newOptE = document.createElement('option');
                        newOptE.value = repEST;
                        newOptE.textContent = repEST;
                        selE.appendChild(newOptE);
                        selE.value = repEST;
                    }
                } else {
                    selE.value = 'LLEVA?';
                }
                selE.onchange = function(){ handleNESTChange(this); };
                tdEst.appendChild(selE); tr.appendChild(tdEst);

                tbody.appendChild(tr);
            });
        };

        window.updateClienteEstiloArtes = function(cliente, estilo, value, colName, selectElement) {
            if (!cliente) return;
            // Si el estilo no provisto y no está en modo 'para todo', no hacemos nada
            const paraTodo = !!document.getElementById('chk-artes-para-todo') && document.getElementById('chk-artes-para-todo').checked;
            if (!estilo && !paraTodo) return;
            
            // Mostrar modal de carga al inicio
            const modal = document.getElementById('modal-loading-artes');
            if (modal) modal.classList.add('active');
            
            // intentar encontrar índice de columna por nombre en colMap
            let idx = getColIndex(colName);
            if (idx === -1) {
                // intenta buscar en colMap por variantes
                for (const k in colMap) { if (k.toString().toUpperCase().indexOf(colName.toUpperCase())!==-1) { idx = colMap[k]; break; } }
            }
            if (idx === -1 || idx === undefined) {
                // no se encontró columna; solo actualizar localmente (comparar clientes normalizados)
                const clienteNorm = normalizeClientForTransfer(cliente || '');
                for (let i=1;i<rawData.length;i++){
                    const rCliente = normalizeClientForTransfer(getVal(rawData[i],'CLIENTE')||'');
                    const rEstilo = (getVal(rawData[i],'ESTILO')||'').toString().trim();
                    if (rCliente===clienteNorm && (paraTodo || rEstilo===estilo)) {
                        rawData[i][idx] = value;
                    }
                }
                alert('Actualizado localmente. Columna no identificada para guardar en servidor.');
                if (modal) modal.classList.remove('active');
                return;
            }

            // Recolectar filas a actualizar.
            // Si 'Para todo' está activo -> aplicar a TODO lo filtrado por los selects actuales (cliente/estilo/haydato).
            // Si no -> aplicar a todas las filas del mismo estilo para el cliente.
            const rowsToUpdate = [];
            const clienteNorm = normalizeClientForTransfer(cliente || '');
            const uiFilterCliente = document.getElementById('filter-artes-cliente')?.value || '';
            const uiFilterEstilo = document.getElementById('filter-artes-estilo')?.value || '';
            const uiFilterHayDato = document.getElementById('filter-artes-haydato')?.value || '';
            for (let i=1;i<rawData.length;i++){
                const rCliente = normalizeClientForTransfer(getVal(rawData[i],'CLIENTE')||'');
                const rEstilo = (getVal(rawData[i],'ESTILO')||'').toString().trim();
                if (rCliente !== clienteNorm) continue;

                if (paraTodo) {
                    // respetar filtros UI: si hay filtro por estilo, aplicarlo; si hay filtro haydato, evaluar la columna objetivo
                    if (uiFilterEstilo && rEstilo !== uiFilterEstilo) continue;

                    if (uiFilterHayDato === 'CON' || uiFilterHayDato === 'SIN') {
                        // verificar valor actual de la columna objetivo en esta fila
                        let idxCheck = getColIndex(colName);
                        if (idxCheck === -1) {
                            for (const k in colMap) { if (k.toString().toUpperCase().indexOf(colName.toUpperCase())!==-1) { idxCheck = colMap[k]; break; } }
                        }
                        const rawVal = (idxCheck !== -1 && idxCheck !== undefined) ? (rawData[i][idxCheck] || '') : (getVal(rawData[i], colName) || '');
                        const rawNorm = (rawVal||'').toString().trim();
                        const hasDato = (rawNorm !== '' && rawNorm.toUpperCase().indexOf('NO LLEVA') === -1);
                        if (uiFilterHayDato === 'CON' && !hasDato) continue;
                        if (uiFilterHayDato === 'SIN' && hasDato) continue;
                    }

                    rowsToUpdate.push(i);
                } else {
                    // aplicar únicamente a filas con el mismo estilo
                    if (rEstilo === estilo) rowsToUpdate.push(i);
                }
            }
            if (rowsToUpdate.length===0) { alert('No se encontraron filas para actualizar'); if (modal) modal.classList.remove('active'); return; }

            if (selectElement) selectElement.disabled = true;
            // Actualizar localmente primero para respuesta inmediata
            rowsToUpdate.forEach(rowIndex => { rawData[rowIndex][idx] = value; });
            // Enviar todas las peticiones en paralelo (más dinámico). Si el backend acepta batch, mejorar posteriormente.
            const promises = rowsToUpdate.map(rowIndex => {
                return fetch(WEB_APP_URL, {
                    method: 'POST', mode: 'no-cors', headers: {'Content-Type':'application/json'},
                    body: JSON.stringify({ action:'update', row: rowIndex, colName: colName, value: value })
                }).catch(err => { console.error('Err saving row', rowIndex, err); });
            });
            Promise.all(promises).then(()=>{
                if (selectElement) selectElement.disabled = false;
                updateCounters();
                renderArtes();
                // Cerrar modal de carga cuando todos los datos se hayan actualizado
                if (modal) modal.classList.remove('active');
            }).catch(()=>{
                if (selectElement) selectElement.disabled = false;
                renderArtes();
                // Cerrar modal de carga incluso si hay error
                if (modal) modal.classList.remove('active');
            });
        };

        window.guardarCambiosAsignarArtes = function() { alert('Los cambios se guardan automáticamente al seleccionar un valor para cada estilo.'); };

        function renderCorteBloques() {
            const tbody = document.getElementById('tbody-corte-bloques');
            if (!tbody) return;
            tbody.innerHTML = '';
            let count = 0;
            
            // Mostrar/ocultar columna P según el sub-tab activo (solo en PROG)
            const showPColumn = (currentCorteBloquesFilter === 'PROG');
            try {
                const thP = document.getElementById('th-corte-bloques-p');
                if (thP) thP.style.display = showPColumn ? '' : 'none';
            } catch (e) {}

            let validIndices = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const estadoCorteVal = (row[colMap["STATUS_CORTE"]] || row[colMap["STATUS"]] || row[colMap["status"]] || row[colMap["estado_corte"]] || row[colMap["ESTADO CORTE"]] || row[colMap["ESTADO_CORTE"]]) || "";
                const isCorteOk = String(estadoCorteVal).toUpperCase() === 'OK';
                const estadoCorteNorm = (!estadoCorteVal || estadoCorteVal === '') ? 'X PROG' : String(estadoCorteVal);

                // Mostrar solo filas cuyo estado_bloques === 'OK CORTE' (case-insensitive)
                const estadoBloquesRaw = getVal(row, 'ESTADO BLOQUES') || getVal(row, 'ESTADO_BLOQUES') || getVal(row, 'estado_bloques') || '';
                const estadoBloquesNorm = (estadoBloquesRaw || '').toString().toUpperCase().trim();
                
                if (estadoBloquesNorm === 'OK CORTE') {
                    // Filtrar por estado_corte_bloques según el sub-tab activo
                    let estadoCorteBloqsRaw = getVal(row, 'estado_corte_bloques') || getVal(row, 'ESTADO_CORTE_BLOQUES') || getVal(row, 'ESTADO CORTE BLOQUES') || '';
                    // Fallback robusto: buscar índice de encabezado directamente si getVal no encontró nada
                    if ((!estadoCorteBloqsRaw || estadoCorteBloqsRaw === '') && typeof findHeaderIndexCaseInsensitive === 'function') {
                        const idx = findHeaderIndexCaseInsensitive('estado_corte_bloques');
                        if (idx !== -1 && row[idx] !== undefined) estadoCorteBloqsRaw = row[idx];
                    }
                    const estadoCorteBloqsNorm = (!estadoCorteBloqsRaw || estadoCorteBloqsRaw === '') ? 'X PROG' : String(estadoCorteBloqsRaw);
                    
                    if (estadoCorteBloqsNorm === currentCorteBloquesFilter) {
                        validIndices.push(i);
                    }
                }
            }

            validIndices = sortBloqueoData(validIndices);

            let lastOpPtda = null;
            let currentGroup = 'a';

            validIndices.forEach(i => {
                count++;
                const row = rawData[i];
                const opTela = String(getVal(row, "OP TELA") || "").trim();
                const partida = String(getVal(row, "PARTIDA") || "").trim();
                const currentOpPtda = opTela + "-" + partida;
                if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                    currentGroup = (currentGroup === 'a') ? 'b' : 'a';
                }
                lastOpPtda = currentOpPtda;

                const tr = createRow(row, i, 'corte', currentGroup);

                // Quitar el botón de tendido ('+') que aparece dentro de la celda OC
                // en la vista Corte Bloques: no debe mostrarse aquí.
                try {
                    const tendidoBtn = tr.querySelector('button.btn-tendido');
                    if (tendidoBtn) tendidoBtn.remove();
                } catch (e) {}

                // Remove RIB cell if present (select with onchange updateRow(...,'estado_rib'))
                try {
                    const ribSelect = tr.querySelector('select[onchange*="estado_rib"]');
                    if (ribSelect) {
                        const td = ribSelect.closest('td');
                        if (td) td.remove();
                    }
                } catch (e) {}

                // En la vista "Corte Bloques" mostrar solo texto para `equipo_corte` y `STATUS_CORTE`.
                // Reemplazamos los <select> correspondientes por su valor visible.
                try {
                    const selects = tr.querySelectorAll('select');
                    selects.forEach(s => {
                        const oc = s.getAttribute('onchange') || '';
                        const on = oc.toString().toLowerCase();
                        // equipo_corte -> updateRow(..., 'equipo_corte', ...)
                        if (on.indexOf("'equipo_corte'") !== -1) {
                            const txt = (s.options && s.selectedIndex >= 0 && s.options[s.selectedIndex]) ? s.options[s.selectedIndex].text : (s.value || '');
                            const td = s.closest('td');
                            if (td) td.innerText = txt;
                        }
                        // STATUS_CORTE variants, avoid matching 'estado_corte_bloques'
                        if ((on.indexOf("'status_corte'") !== -1 || on.indexOf("'status'") !== -1 || on.indexOf("'estado_corte'") !== -1) && on.indexOf("'estado_corte_bloques'") === -1) {
                            const txt = (s.options && s.selectedIndex >= 0 && s.options[s.selectedIndex]) ? s.options[s.selectedIndex].text : (s.value || '');
                            const td = s.closest('td');
                            if (td) td.innerText = txt;
                        }
                    });
                } catch (e) {}

                // Remove last two cells (estado_bloques and estado_coll_tap)
                try {
                    for (let k = 0; k < 2; k++) {
                        const tds = tr.querySelectorAll('td');
                        if (tds && tds.length) tds[tds.length - 1].remove();
                    }
                } catch (e) {}

                // Append the new column 'BLOQUES?' (value from estado_bloques) then 'ESTADO_BLOQS' como select
                try {
                    const valBloq = getVal(row, 'ESTADO BLOQUES') || getVal(row, 'ESTADO_BLOQUES') || getVal(row, 'estado_bloques') || '';
                    const tdBloq = document.createElement('td');
                    tdBloq.title = valBloq;
                    tdBloq.innerText = valBloq;
                    tr.appendChild(tdBloq);

                    let val = getVal(row, 'estado_corte_bloques') || getVal(row, 'ESTADO_CORTE_BLOQUES') || getVal(row, 'ESTADO CORTE BLOQUES') || '';
                    // Fallback robusto para leer directamente de rawData si colMap no contiene la columna
                    if ((!val || val === '') && typeof findHeaderIndexCaseInsensitive === 'function') {
                        const idxVal = findHeaderIndexCaseInsensitive('estado_corte_bloques');
                        if (idxVal !== -1 && row[idxVal] !== undefined) val = row[idxVal];
                    }
                    const valNorm = (!val || val === '') ? 'X PROG' : String(val);
                    let selectClass = '';
                    if (valNorm.toUpperCase().includes('PROG') && valNorm !== 'X PROG') selectClass = 'sel-PROG';
                    if (valNorm === 'OK') selectClass = 'sel-OK';
                    
                    const td = document.createElement('td');
                    // Si estamos en Corte Bloques -> Por Programar (X PROG), mostrar solo texto
                    try {
                        if (currentCorteBloquesFilter === 'X PROG') {
                            td.title = valNorm;
                            td.innerText = valNorm;
                        } else {
                            // Ocultar la opción OK cuando el sub-tab activo sea 'X PROG' (Por Programar)
                            const showOkOption = (typeof currentCorteBloquesFilter === 'undefined') ? true : (currentCorteBloquesFilter !== 'X PROG');
                            td.innerHTML = `
                                <select class="table-select ${selectClass}" onchange="updateRow(${i}, 'estado_corte_bloques', this.value, this)">
                                    <option value="X PROG" ${valNorm === 'X PROG' ? 'selected' : ''}>X PROG</option>
                                    <option value="PROG" ${valNorm === 'PROG' ? 'selected' : ''}>PROG</option>
                                    ${showOkOption ? `<option value="OK" ${valNorm === 'OK' ? 'selected' : ''}>OK</option>` : ''}
                                </select>
                            `;
                        }
                    } catch(e) {
                        td.innerHTML = `
                            <select class="table-select ${selectClass}" onchange="updateRow(${i}, 'estado_corte_bloques', this.value, this)">
                                <option value="X PROG" ${valNorm === 'X PROG' ? 'selected' : ''}>X PROG</option>
                                <option value="PROG" ${valNorm === 'PROG' ? 'selected' : ''}>PROG</option>
                                <option value="OK" ${valNorm === 'OK' ? 'selected' : ''}>OK</option>
                            </select>
                        `;
                    }
                    tr.appendChild(td);
                } catch (e) {}

                // Agregar celda P al inicio si estamos en sub-tab PROG
                if (showPColumn) {
                    const pCell = document.createElement('td');
                    pCell.innerHTML = createPrioridadCell(i, row).replace(/<td.*?>|<\/td>/g, '');
                    tr.insertBefore(pCell, tr.firstChild);
                }
                
                // Si P = 1, aplicar color rojo claro
                const idxP = findHeaderIndexCaseInsensitive('P');
                if (idxP !== -1) {
                    const pValue = String(row[idxP] || '').trim();
                    if (pValue === '1') {
                        tr.classList.add('priority-1');
                    }
                }

                tbody.appendChild(tr);
            });

            document.getElementById('tbody-corte-bloques') && (document.getElementById('count-corte-bloques').innerText = count);
            
            // Actualizar badges de pds según el filtro
            updateCorteBloquesCounters();
        }
        
        function updateCorteBloquesCounters() {
            let pds_xprog = 0;
            let pds_prog = 0;
            
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const estadoBloquesRaw = getVal(row, 'ESTADO BLOQUES') || getVal(row, 'ESTADO_BLOQUES') || getVal(row, 'estado_bloques') || '';
                const estadoBloquesNorm = (estadoBloquesRaw || '').toString().toUpperCase().trim();

                if (estadoBloquesNorm === 'OK CORTE') {
                    // Leer estado_corte_bloques robustamente
                    let estadoCorteBloqsRaw = getVal(row, 'estado_corte_bloques') || getVal(row, 'ESTADO_CORTE_BLOQUES') || getVal(row, 'ESTADO CORTE BLOQUES') || '';
                    if ((!estadoCorteBloqsRaw || estadoCorteBloqsRaw === '') && typeof findHeaderIndexCaseInsensitive === 'function') {
                        const idx = findHeaderIndexCaseInsensitive('estado_corte_bloques');
                        if (idx !== -1 && row[idx] !== undefined) estadoCorteBloqsRaw = row[idx];
                    }
                    const estadoCorteBloqsNorm = (!estadoCorteBloqsRaw || estadoCorteBloqsRaw === '') ? 'X PROG' : String(estadoCorteBloqsRaw).toUpperCase().trim();

                    // Leer PDS con fallback a rawData si es necesario
                    let pdsVal = parseFloat(getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || 0) || 0;
                    if ((pdsVal === 0 || isNaN(pdsVal)) && typeof findHeaderIndexCaseInsensitive === 'function') {
                        let idxPds = findHeaderIndexCaseInsensitive('PDS GIRADAS');
                        if (idxPds === -1) idxPds = findHeaderIndexCaseInsensitive('PDS');
                        if (idxPds !== -1 && row[idxPds] !== undefined) pdsVal = parseFloat(row[idxPds]) || 0;
                    }

                    if (estadoCorteBloqsNorm === 'X PROG') pds_xprog += pdsVal;
                    if (estadoCorteBloqsNorm === 'PROG') pds_prog += pdsVal;
                }
            }
            
            const elX = document.getElementById('corte-bloques-pds-xprog');
            if (elX) elX.innerText = `[${formatThousands(pds_xprog, 0)}pds]`;
            const elP = document.getElementById('corte-bloques-pds-prog');
            if (elP) elP.innerText = `[${formatThousands(pds_prog, 0)}pds]`;
        }

        // ===============================
        // FUNCIONES DEL MODAL DE TENDIDO
        // ===============================

        window.abrirModalTendido = function(rowIndex, op, corte, color, pdsTotal) {
            // Detectar si el CORTE es ya un tendido (termina en 01, 02, etc.)
            const corteStr = String(corte);
            const lastTwoChars = corteStr.slice(-2);
            const isTendidoExistente = /^0[1-9]$|^[1-9]\d$/.test(lastTwoChars) && corteStr.length > 2;
            
            if (isTendidoExistente) {
                // Modo EDICIÓN: mostrar los tendidos ya existentes
                abrirModalTendidoEdicion(rowIndex, op, corte, color);
            } else {
                // Modo CREACIÓN: crear nuevos tendidos
                abrirModalTendidoCreacion(rowIndex, op, corte, color, pdsTotal);
            }
        };

        window.abrirModalTendidoCreacion = function(rowIndex, op, corte, color, pdsTotal) {
            modalTendidoData = {
                rowIndex: rowIndex,
                oc: `${op}-${corte}`,
                op: op,
                corte: corte,
                color: color,
                pdsTotal: pdsTotal,
                modo: 'crear',
                tendidos: []
            };

            document.getElementById('modal-tendido-title').innerText = `OC: ${op}-${corte}`;
            document.getElementById('modal-tendido-subtitle').innerText = `COLOR: ${color} | PDS: ${formatThousands(pdsTotal, 0)}`;

            const tbody = document.getElementById('modal-tendido-tbody');
            const tendido1 = `${corte}01`;
            const tendido2 = `${corte}02`;

            modalTendidoData.tendidos = [tendido1, tendido2];

            let html = '';
            for (let i = 0; i < modalTendidoData.tendidos.length; i++) {
                const tendido = modalTendidoData.tendidos[i];
                const isLast = (i === modalTendidoData.tendidos.length - 1);
                const btnHTML = isLast ? `<button class="btn-tendido" onclick="agregarTendidoModal()" style="margin-right: 6px;" title="Agregar tendido">+</button>` : '';
                
                if (isLast) {
                    html += `<tr><td style="font-weight: 600; text-align: center;">${btnHTML}${tendido}</td><td><input type="number" id="pds-tendido-${i}" placeholder="Diferencia" oninput="recalcularTendidosModal()" min="0" max="${pdsTotal}"></td></tr>`;
                } else {
                    html += `<tr><td style="font-weight: 600; text-align: center;">${tendido}</td><td><input type="number" id="pds-tendido-${i}" placeholder="Ingrese PDS" oninput="recalcularTendidosModal()" min="0" max="${pdsTotal}"></td></tr>`;
                }
            }
            tbody.innerHTML = html;
            document.getElementById('modal-tendido').classList.add('active');
        };

        window.abrirModalTendidoEdicion = function(rowIndex, op, corte, color) {
            const corteBase = String(corte).slice(0, -2);
            const corteIdx = colMap["CORTE"];
            const pdsIdx = colMap["PDS GIRADAS"];
            
            const tendidos = [];
            const tendidoRows = [];
            const tendidoPds = [];
            
            for (let i = 1; i < rawData.length; i++) {
                const rowCorte = String(rawData[i][corteIdx] || '');
                const match = rowCorte.match(new RegExp(`^${corteBase}(\\d{2})$`));
                if (match) {
                    tendidos.push(rowCorte);
                    tendidoRows.push(i);
                    tendidoPds.push(parseFloat(rawData[i][pdsIdx]) || 0);
                }
            }
            
            const sortedIndices = Array.from(Array(tendidos.length).keys()).sort((a, b) => {
                const numA = parseInt(tendidos[a].slice(-2));
                const numB = parseInt(tendidos[b].slice(-2));
                return numA - numB;
            });
            
            const sortedTendidos = sortedIndices.map(i => tendidos[i]);
            const sortedRows = sortedIndices.map(i => tendidoRows[i]);
            const sortedPds = sortedIndices.map(i => tendidoPds[i]);
            const totalPds = sortedPds.reduce((a, b) => a + b, 0);
            
            modalTendidoData = {
                rowIndex: rowIndex,
                tendidoRows: sortedRows,
                oc: `${op}-${corteBase}`,
                op: op,
                corte: corteBase,
                color: color,
                pdsTotal: totalPds,
                modo: 'editar',
                tendidos: sortedTendidos
            };

            document.getElementById('modal-tendido-title').innerText = `OC: ${op}-${corteBase}`;
            document.getElementById('modal-tendido-subtitle').innerText = `COLOR: ${color} | PDS: ${formatThousands(totalPds, 0)}`;

            const tbody = document.getElementById('modal-tendido-tbody');
            let html = '';
            for (let i = 0; i < sortedTendidos.length; i++) {
                const tendido = sortedTendidos[i];
                const pds = sortedPds[i];
                const isLast = (i === sortedTendidos.length - 1);
                const btnHTML = isLast ? `<button class="btn-tendido" onclick="agregarTendidoModal()" style="margin-right: 6px;" title="Agregar tendido">+</button>` : '';
                html += `<tr><td style="font-weight: 600; text-align: center;">${btnHTML}${tendido}</td><td><input type="number" id="pds-tendido-${i}" value="${pds}" oninput="recalcularTendidosModal()" min="0" max="${totalPds}"></td></tr>`;
            }
            tbody.innerHTML = html;
            document.getElementById('modal-tendido').classList.add('active');
        };

        window.recalcularTendidosModal = function() {
            const total = modalTendidoData.pdsTotal;
            const numTendidos = modalTendidoData.tendidos ? modalTendidoData.tendidos.length : 2;
            
            let sumaParcial = 0;
            for (let i = 0; i < numTendidos - 1; i++) {
                const input = document.getElementById(`pds-tendido-${i}`);
                if (input) {
                    const val = parseFloat(input.value) || 0;
                    sumaParcial += val;
                }
            }
            
            const ultimoInput = document.getElementById(`pds-tendido-${numTendidos - 1}`);
            if (ultimoInput) {
                const diferencia = total - sumaParcial;
                ultimoInput.value = Math.max(0, diferencia);
            }
        };

        window.agregarTendidoModal = function() {
            if (!modalTendidoData.tendidos) {
                alert('Error: No hay datos de tendidos');
                return;
            }
            
            const corte = modalTendidoData.corte;
            const numTendidos = modalTendidoData.tendidos.length;
            const siguienteNum = String(numTendidos + 1).padStart(2, '0');
            const nuevoTendido = `${corte}${siguienteNum}`;
            
            modalTendidoData.tendidos.push(nuevoTendido);
            
            const tbody = document.getElementById('modal-tendido-tbody');
            const total = modalTendidoData.pdsTotal;
            
            let html = '';
            for (let i = 0; i < modalTendidoData.tendidos.length; i++) {
                const tendido = modalTendidoData.tendidos[i];
                const isLast = (i === modalTendidoData.tendidos.length - 1);
                const btnHTML = isLast ? `<button class="btn-tendido" onclick="agregarTendidoModal()" style="margin-right: 6px;" title="Agregar tendido">+</button>` : '';
                
                let inputVal = '';
                const oldInput = document.getElementById(`pds-tendido-${i}`);
                if (oldInput) inputVal = oldInput.value;
                
                html += `<tr><td style="font-weight: 600; text-align: center;">${btnHTML}${tendido}</td><td><input type="number" id="pds-tendido-${i}" value="${inputVal}" oninput="recalcularTendidosModal()" min="0" max="${total}"></td></tr>`;
            }
            tbody.innerHTML = html;
            setTimeout(() => recalcularTendidosModal(), 100);
        };

        window.cerrarModalTendido = function() {
            document.getElementById('modal-tendido').classList.remove('active');
            modalTendidoData = { rowIndex: null, oc: '', op: '', corte: '', color: '', pdsTotal: 0 };
        };

        // Modal para mostrar información OC (RUTA, EQUIPO_CORTE, ESTADO_ENUMERADO)
        window.abrirModalOC = function(rowIndex) {
            try {
                console.log('abrirModalOC called, rowIndex=', rowIndex, 'isHabilitadoView=', isHabilitadoView && isHabilitadoView());
                if (!isHabilitadoView || !isHabilitadoView()) { console.log('abrirModalOC: not in habilitado view'); return; }
                if (typeof rawData === 'undefined') { console.warn('abrirModalOC: rawData undefined'); return; }
                const row = rawData[rowIndex];
                if (!row) return;
                const op = getVal(row,'OP') || '';
                const corte = getVal(row,'CORTE') || '';
                const oc = (op || corte) ? `${op}-${corte}` : '';
                const colorRaw = getVal(row,'COLOR') || '';
                const color = abbreviateHeather(colorRaw);
                const ruta = getVal(row,'RUTA TELA') || getVal(row,'RUTA') || '';
                const equipo = getVal(row,'EQUIPO CORTE') || getVal(row,'EQUIPO_CORTE') || getVal(row,'equipo_corte') || '';
                const estadoEnum = getVal(row,'estado_enumerado') || getVal(row,'ESTADO_ENUMERADO') || getVal(row,'ESTADO ENUMERADO') || '';
                const estadoCorte = getVal(row,'STATUS_CORTE') || getVal(row,'STATUS') || getVal(row,'status') || getVal(row,'ESTADO CORTE') || getVal(row,'ESTADO_CORTE') || getVal(row,'estado_corte') || '';

                document.getElementById('modal-oc-title').innerText = `${oc} ${color}`;
                document.getElementById('modal-oc-subtitle').innerText = '';

                const tbody = document.getElementById('modal-oc-tbody');
                let html = '';
                html += `<tr><td style="font-weight:700;">RUTA</td><td title="${ruta}">${ruta}</td></tr>`;
                html += `<tr><td style="font-weight:700;">EQUIPO_CORTE</td><td title="${equipo}">${equipo}</td></tr>`;
                html += `<tr><td style="font-weight:700;">ESTADO_CORTE</td><td title="${estadoCorte}">${estadoCorte}</td></tr>`;
                html += `<tr><td style="font-weight:700;">ESTADO_ENUMERADO</td><td title="${estadoEnum}">${estadoEnum}</td></tr>`;
                tbody.innerHTML = html;
                document.getElementById('modal-oc').classList.add('active');
            } catch (e) { console.error('abrirModalOC error', e); }
        };

        window.cerrarModalOC = function() {
            try {
                document.getElementById('modal-oc').classList.remove('active');
                const tbody = document.getElementById('modal-oc-tbody'); if (tbody) tbody.innerHTML = '';
            } catch (e) {}
        };

        // ===============================
        // FUNCIONES DEL MODAL DE LAVADORA (desde Corte PROG)
        // ===============================
        
        window.abrirModalLavadoFromCorte = function(rowIndex) {
            try {
                const row = rawData[rowIndex] || [];
                const estado = getVal(row, 'estado_lavada') || '';
                const ruta = getVal(row, 'RUTA TELA') || getVal(row, 'RUTA') || '';
                const opTela = String(getVal(row, 'OP TELA') || '').trim();
                const partida = String(getVal(row, 'PARTIDA') || '').trim();
                const opPtda = `${opTela}-${partida}`;

                document.getElementById('modal-lavadora-title').innerText = `OP-PTDA: ${opPtda}`;
                document.getElementById('modal-lavadora-sub').innerText = `Estado actual: ${estado || '(vacío)'}`;
                document.getElementById('modal-lavadora-ruta').innerText = ruta || '-';
                const sel = document.getElementById('modal-lavadora-select');
                if (sel) sel.value = '';

                window._pendingWasherUpdate = { rowIndex, prev: estado };
                const m = document.getElementById('modal-lavadora');
                if (m) m.classList.add('active');
            } catch (e) { console.error('Error abriendo modal lavadora', e); }
        };

        function cerrarModalLavado() {
            const m = document.getElementById('modal-lavadora');
            if (m) m.classList.remove('active');
            // limpiar pending
            window._pendingWasherUpdate = null;
        }

        function onModalLavadoraApply() {
            try {
                const sel = document.getElementById('modal-lavadora-select');
                if (!sel) return;
                const val = sel.value || '';
                if (val === '') { alert('Seleccione una opción.'); return; }
                // Abrir modal de confirmación
                const modal = document.getElementById('modal-confirm-washer');
                window._pendingWasherUpdate = window._pendingWasherUpdate || {};
                window._pendingWasherUpdate.value = val;
                try {
                    const txt = document.getElementById('modal-confirm-washer-text');
                    if (txt) {
                        if (val === 'EN LAV (devolucion)') txt.innerText = 'Aplica para toda la partida?';
                        else txt.innerText = '¿Está seguro que desea actualizar el estado de lavado?';
                    }
                } catch (e) {}
                if (modal) modal.classList.add('active');
            } catch (e) { console.error('Error aplicando en modal lavadora', e); }
        }

        function cerrarModalConfirmWasher() {
            const m = document.getElementById('modal-confirm-washer');
            if (m) m.classList.remove('active');
        }

        function handleConfirmWasher(confirmed) {
            const pending = window._pendingWasherUpdate;
            const modal = document.getElementById('modal-confirm-washer');
            if (!pending) { if (modal) modal.classList.remove('active'); return; }

            const val = pending.value || '';

            // If the selected action is the special 'EN LAV (devolucion)'
            // we treat the confirm dialog as: Si = aplicar a toda la partida, No = aplicar solo la fila
            if (val === 'EN LAV (devolucion)') {
                if (modal) modal.classList.remove('active');
                try {
                    const fake = document.createElement('select'); fake.className = 'table-select';
                    if (confirmed) {
                        // Aplicar a todas las filas con mismo OP-PTDA
                        const rowIdx = pending.rowIndex;
                        const opTela = String(getVal(rawData[rowIdx], 'OP TELA') || getVal(rawData[rowIdx], 'OP') || '').trim();
                        const partida = String(getVal(rawData[rowIdx], 'PARTIDA') || '').trim();
                        for (let i = 1; i < rawData.length; i++) {
                            try {
                                const rOp = String(getVal(rawData[i], 'OP TELA') || getVal(rawData[i], 'OP') || '').trim();
                                const rPart = String(getVal(rawData[i], 'PARTIDA') || '').trim();
                                if (rOp === opTela && rPart === partida) {
                                    window.updateRow(i, 'estado_lavada', val, fake);
                                }
                            } catch (e) { /* ignore row errors */ }
                        }
                    } else {
                        // Aplicar sólo a la fila
                        const rowIndex = pending.rowIndex;
                        window.updateRow(rowIndex, 'estado_lavada', val, fake);
                    }
                } catch (e) { console.error('Error actualizando estado_lavada en batch/single', e); }

                // Cerrar modal de edición
                cerrarModalLavado();
                window._pendingWasherUpdate = null;
                return;
            }

            // Comportamiento por defecto para otras opciones: confirmar o cancelar
            if (!confirmed) {
                if (modal) modal.classList.remove('active');
                // keep modal lavadora open so user can choose again
                return;
            }

            // Confirmado: escribir en estado_lavada (solo fila)
            try {
                if (modal) modal.classList.remove('active');
                const rowIndex = pending.rowIndex;
                const value = pending.value || 'EN LAV';
                try {
                    const fake = document.createElement('select');
                    fake.className = 'table-select';
                    window.updateRow(rowIndex, 'estado_lavada', value, fake);
                } catch (e) { console.error('Error actualizando estado_lavada', e); }
            } catch (e) { console.error('Error en handleConfirmWasher', e); }
            // Cerrar modal de edición
            cerrarModalLavado();
            window._pendingWasherUpdate = null;
        }

        // FUNCIONES PARA MODAL INGRESO A COSTURA
        let currentIngresoCosturaRowIndex = -1;
        let currentIngresoCosturaData = {};

        window.abrirModalIngresoCostura = function(rowIndex) {
            try {
                currentIngresoCosturaRowIndex = rowIndex;
                const row = rawData[rowIndex];
                
                // Obtener datos de la fila
                const cliente = getVal(row, 'CLIENTE') || '';
                const op = getVal(row, 'OP') || '';
                const corte = getVal(row, 'CORTE') || '';
                const color = getVal(row, 'COLOR') || '';
                const pds = getVal(row, 'PDS GIRADAS') || '';
                
                // Obtener PLANTA
                const planta = getVal(row, 'PLANTA') || '';
                
                // Guardar datos actuales
                currentIngresoCosturaData = {
                    rowIndex: rowIndex,
                    cliente: cliente,
                    op: op,
                    corte: corte,
                    color: color,
                    pds: pds,
                    planta: planta
                };
                
                // Llenar el modal
                document.getElementById('modal-ingreso-costura-sub').textContent = `${cliente} ${op}-${corte} ${color} ${pds}`;
                
                // Establecer valor de PLANTA en el select
                const plantaSelect = document.getElementById('modal-ingreso-planta');
                if (planta) {
                    plantaSelect.value = planta;
                } else {
                    plantaSelect.value = '';
                }
                
                document.getElementById('modal-ingreso-linea').value = '';
                
                // Abrir modal
                document.getElementById('modal-ingreso-costura').classList.add('active');
                
                // Enfocar en el campo de LINEA
                setTimeout(() => {
                    const inputLinea = document.getElementById('modal-ingreso-linea');
                    if (inputLinea) inputLinea.focus();
                }, 100);
            } catch (e) {
                console.error('Error en abrirModalIngresoCostura:', e);
                alert('Error al abrir el modal');
            }
        };

        window.cerrarModalIngresoCostura = function() {
            document.getElementById('modal-ingreso-costura').classList.remove('active');
            currentIngresoCosturaRowIndex = -1;
            currentIngresoCosturaData = {};
        };

        window.guardarModalIngresoCostura = function() {
            try {
                const linea = document.getElementById('modal-ingreso-linea').value.trim();
                
                if (!linea) {
                    alert('Por favor ingrese la línea');
                    return;
                }
                
                // Abrir modal de confirmación
                document.getElementById('modal-confirm-ingreso-costura').classList.add('active');
            } catch (e) {
                console.error('Error en guardarModalIngresoCostura:', e);
                alert('Error al guardar');
            }
        };

        window.cerrarModalConfirmIngresoCostura = function() {
            document.getElementById('modal-confirm-ingreso-costura').classList.remove('active');
        };

        window.confirmarIngresoCostura = function() {
            try {
                const linea = document.getElementById('modal-ingreso-linea').value.trim();
                const planta = document.getElementById('modal-ingreso-planta').value.trim();
                
                if (!linea) {
                    alert('Por favor ingrese la línea');
                    return;
                }
                
                if (!planta) {
                    alert('Por favor seleccione la planta');
                    return;
                }
                
                // Obtener fecha y hora actual
                const ahora = new Date();
                const fechaHora = ahora.toLocaleString('es-ES', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                // Enviar datos al backend para guardar todos de una vez
                const rowIndex = currentIngresoCosturaRowIndex;
                
                // Crear array de actualizaciones incluyendo PLANTA
                const updates = [
                    { colName: 'PLANTA', value: planta },
                    { colName: 'LINEA', value: linea },
                    { colName: 'F.ING.REAL', value: fechaHora },
                    { colName: 'estado_habilitado', value: 'OK' }
                ];
                
                // Guardar todos los datos
                guardarVariosDatosIngresoCostura(rowIndex, updates);
                
            } catch (e) {
                console.error('Error en confirmarIngresoCostura:', e);
                alert('Error al confirmar');
            }
        };

        window.guardarVariosDatosIngresoCostura = function(rowIndex, updates) {
            try {
                let completadas = 0;
                const total = updates.length;
                
                updates.forEach(update => {
                    const params = {
                        action: 'update',
                        row: rowIndex,
                        colName: update.colName,
                        value: update.value
                    };
                    
                    fetch(WEB_APP_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        body: JSON.stringify(params)
                    })
                    .then(response => {
                        completadas++;
                        if (completadas === total) {
                            // Todas las actualizaciones completadas
                            alert('Datos guardados correctamente');
                            cerrarModalConfirmIngresoCostura();
                            cerrarModalIngresoCostura();
                            setTimeout(() => renderHabilitado(), 500);
                        }
                    })
                    .catch(e => {
                        console.error(`Error guardando ${update.colName}:`, e);
                    });
                });
            } catch (e) {
                console.error('Error en guardarVariosDatosIngresoCostura:', e);
                alert('Error al guardar los datos');
            }
        };

        window.guardarDatoIngresoCostura = function(rowIndex, colName, value, callback) {
            try {
                const params = {
                    action: 'update',
                    row: rowIndex,
                    colName: colName,
                    value: value
                };
                
                fetch(WEB_APP_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: JSON.stringify(params)
                })
                .then(() => {
                    if (callback) callback();
                })
                .catch(e => {
                    console.error(`Error guardando ${colName}:`, e);
                });
            } catch (e) {
                console.error('Error en guardarDatoIngresoCostura:', e);
            }
        };

        window.limpiarModalTendido = function() {
            const numTendidos = modalTendidoData.tendidos ? modalTendidoData.tendidos.length : 2;
            for (let i = 0; i < numTendidos; i++) {
                const input = document.getElementById(`pds-tendido-${i}`);
                if (input) input.value = '';
            }
        };

        window.guardarModalTendido = function() {
            const numTendidos = modalTendidoData.tendidos ? modalTendidoData.tendidos.length : 2;
            const pdsValues = [];
            
            for (let i = 0; i < numTendidos; i++) {
                const input = document.getElementById(`pds-tendido-${i}`);
                const pds = parseFloat(input ? input.value : 0) || 0;
                pdsValues.push(pds);
            }

            if (pdsValues.some(v => v <= 0)) {
                alert('Por favor ingrese valores válidos para todos los tendidos.');
                return;
            }

            if (modalTendidoData.modo === 'crear') {
                guardarModalTendidoCreacion(pdsValues);
            } else if (modalTendidoData.modo === 'editar') {
                guardarModalTendidoEdicion(pdsValues);
            }
        };

        window.guardarModalTendidoCreacion = function(pdsValues) {
            const rowIndex = modalTendidoData.rowIndex;
            if (rowIndex === null || !rawData[rowIndex]) {
                alert('Error: No se encontró la fila original.');
                cerrarModalTendido();
                return;
            }

            const originalRow = rawData[rowIndex];
            const corte = modalTendidoData.corte;
            const corteIdx = colMap["CORTE"];
            const pdsIdx = colMap["PDS GIRADAS"];

            if (corteIdx === undefined || corteIdx === -1 || pdsIdx === undefined || pdsIdx === -1) {
                alert('Error: No se encontraron las columnas CORTE o PDS GIRADAS.');
                cerrarModalTendido();
                return;
            }

            try {
                // Reemplazar la fila original con el primer tendido
                const firstTendido = `${corte}01`;
                const firstPds = pdsValues[0];
                
                const newRow1 = [...originalRow];
                newRow1[corteIdx] = firstTendido;
                newRow1[pdsIdx] = firstPds;
                // marcar como recién creado para priorizar su visualización
                try { newRow1._inserted = Date.now(); } catch(e){}
                rawData[rowIndex] = newRow1;

                fetch(WEB_APP_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: JSON.stringify({
                        action: "update",
                        row: rowIndex,
                        colName: "CORTE",
                        value: firstTendido
                    })
                }).catch(e => console.error("Error guardando CORTE tendido 1", e));

                fetch(WEB_APP_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: JSON.stringify({
                        action: "update",
                        row: rowIndex,
                        colName: "PDS GIRADAS",
                        value: firstPds
                    })
                }).catch(e => console.error("Error guardando PDS tendido 1", e));

                // Crear tendidos adicionales (si hay más de uno)
                let alertMsg = `Se han creado los tendidos:\n• ${firstTendido} con ${formatThousands(firstPds, 0)} PDS`;
                
                // Insertar tendidos adicionales inmediatamente después de la fila original
                // para que queden contiguos en la vista.
                for (let i = 1; i < pdsValues.length; i++) {
                    const tendidoNum = String(i + 1).padStart(2, '0');
                    const tendido = `${corte}${tendidoNum}`;
                    const pds = pdsValues[i];

                    const newRow = [...originalRow];
                    newRow[corteIdx] = tendido;
                    newRow[pdsIdx] = pds;
                    try { newRow._inserted = Date.now(); } catch(e){}

                    // Insertar en rawData justo después de la fila original y de los tendidos ya insertados
                    const insertAt = rowIndex + i; // i=1 -> after original, i=2 -> after first inserted, etc.
                    rawData.splice(insertAt, 0, newRow);

                    fetch(WEB_APP_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        body: JSON.stringify({
                            action: "duplicateRow",
                            sourceRow: rowIndex,
                            newCorte: tendido,
                            newPds: pds
                        })
                    }).catch(e => console.error(`Error creando tendido ${i + 1}`, e));

                    alertMsg += `\n• ${tendido} con ${formatThousands(pds, 0)} PDS`;
                }

            } catch (e) {
                console.error('Error guardando tendidos:', e);
                alert('Error al guardar los tendidos.');
                return;
            }

            // Registrar la base como creada para que se muestre priorizada
            try { addCreatedTendidoBase(corte); } catch(e) {}

            // Cerrar modal y re-renderizar
            cerrarModalTendido();
            updateCounters();
            renderCorte();

            alert(alertMsg);
        };

        window.guardarModalTendidoEdicion = function(pdsValues) {
            const tendidoRows = modalTendidoData.tendidoRows || [];
            
            if (tendidoRows.length === 0) {
                alert('Error: No se encontraron los tendidos existentes.');
                cerrarModalTendido();
                return;
            }

            const pdsIdx = colMap["PDS GIRADAS"];
            const corteIdx = colMap["CORTE"];
            
            if (pdsIdx === undefined || pdsIdx === -1 || corteIdx === undefined || corteIdx === -1) {
                alert('Error: No se encontró la columna PDS GIRADAS o CORTE.');
                cerrarModalTendido();
                return;
            }

            try {
                let alertMsg = 'Se han actualizado los tendidos:';
                const corte = modalTendidoData.corte;
                
                // Actualizar tendidos existentes
                for (let i = 0; i < Math.min(pdsValues.length, tendidoRows.length); i++) {
                    const rowIdx = tendidoRows[i];
                    const pds = pdsValues[i];
                    const tendidoNum = String(i + 1).padStart(2, '0');
                    const tendido = `${corte}${tendidoNum}`;
                    
                    rawData[rowIdx][pdsIdx] = pds;

                    fetch(WEB_APP_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        body: JSON.stringify({
                            action: "update",
                            row: rowIdx,
                            colName: "PDS GIRADAS",
                            value: pds
                        })
                    }).catch(e => console.error(`Error guardando PDS tendido ${i + 1}`, e));

                    alertMsg += `\n• ${tendido} con ${formatThousands(pds, 0)} PDS`;
                }
                // Registrar la base como creada (en caso de añadir nuevos tendidos)
                try { addCreatedTendidoBase(corte); } catch(e) {}

                // Crear nuevos tendidos si hay más valores que filas existentes
                if (pdsValues.length > tendidoRows.length) {
                    const sourceRowIdx = tendidoRows[0];
                    const sourceRow = rawData[sourceRowIdx];
                    // Insertar nuevos tendidos justo después del último tendido existente
                    const lastExisting = tendidoRows[tendidoRows.length - 1];
                    let inserted = 0;
                    for (let i = tendidoRows.length; i < pdsValues.length; i++) {
                        const pds = pdsValues[i];
                        const tendidoNum = String(i + 1).padStart(2, '0');
                        const tendido = `${corte}${tendidoNum}`;

                        const newRow = [...sourceRow];
                        newRow[corteIdx] = tendido;
                        newRow[pdsIdx] = pds;
                        try { newRow._inserted = Date.now(); } catch(e){}

                        const insertAt = lastExisting + 1 + inserted; // place after last existing, account inserted
                        rawData.splice(insertAt, 0, newRow);
                        inserted++;

                        fetch(WEB_APP_URL, {
                            method: 'POST',
                            mode: 'no-cors',
                            body: JSON.stringify({
                                action: "duplicateRow",
                                sourceRow: sourceRowIdx,
                                newCorte: tendido,
                                newPds: pds
                            })
                        }).catch(e => console.error(`Error creando tendido ${i + 1}`, e));

                        alertMsg += `\n• ${tendido} con ${formatThousands(pds, 0)} PDS`;
                    }
                }

            } catch (e) {
                console.error('Error guardando cambios de tendidos:', e);
                alert('Error al guardar los cambios.');
                return;
            }

            // Cerrar modal y re-renderizar
            cerrarModalTendido();
            updateCounters();
            renderCorte();

            alert(alertMsg);
        };

        // ===============================
        // FUNCIONES DEL MODAL EQ_CORTE
        // ===============================

        let equiposCorteData = [];

        window.abrirModalEQCorte = function() {
            // Cargar datos de la hoja EQ_Corte
            cargarEquiposCorte();
        };

        function cargarEquiposCorteBackground() {
            // Cargar equipos sin mostrar el modal (para uso en select)
            const script = document.createElement('script');
            script.src = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=responseHandler:loadEQCorteCallback&sheet=EQ_Corte`;
            script.onerror = () => {
                console.error("Error cargando hoja EQ_Corte en background");
                // Datos por defecto en caso de error
                equiposCorteData = [{eq: 1, nombre: "Mesa 1"}, {eq: 2, nombre: "Mesa 2"}];
            };
            document.body.appendChild(script);
        }

        function cargarEquiposCorte() {
            // Mostrar loading en modal
            document.getElementById('modal-eq-corte-tbody').innerHTML = '<tr><td colspan="2" style="text-align:center;padding:20px;">Cargando equipos...</td></tr>';
            document.getElementById('modal-eq-corte').classList.add('active');

            // Usar el mismo método que funciona para los datos principales
            const script = document.createElement('script');
            script.src = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=responseHandler:loadEQCorteCallback&sheet=EQ_Corte`;
            script.onerror = () => {
                console.error("Error cargando hoja EQ_Corte");
                // Datos por defecto en caso de error
                equiposCorteData = [
                    {eq: 1, nombre: "Mesa 1"},
                    {eq: 2, nombre: "Mesa 2"}
                ];
                renderModalEQCorte();
            };
            document.body.appendChild(script);
        }

        // Callback para recibir los datos de la hoja EQ_Corte
        window.loadEQCorteCallback = function(jsonResponse) {
            try {
                if (!jsonResponse || !jsonResponse.table) {
                    throw new Error("Datos inválidos de EQ_Corte");
                }
                
                const rows = jsonResponse.table.rows;
                equiposCorteData = [];
                
                // Procesar las filas (saltar el header)
                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    if (row && row.c && row.c.length >= 2) {
                        const eqValue = row.c[0] ? (row.c[0].v || row.c[0].f || "") : "";
                        const nombreValue = row.c[1] ? (row.c[1].v || row.c[1].f || "") : "";
                        
                        // Solo agregar si tiene datos válidos
                        if (eqValue && nombreValue) {
                            equiposCorteData.push({
                                eq: parseInt(eqValue) || eqValue,
                                nombre: String(nombreValue)
                            });
                        }
                    }
                }
                
                // Si no hay datos, usar valores por defecto
                if (equiposCorteData.length === 0) {
                    equiposCorteData = [
                        {eq: 1, nombre: "Mesa 1"},
                        {eq: 2, nombre: "Mesa 2"}
                    ];
                }
                
                renderModalEQCorte();
                
            } catch (error) {
                console.error("Error procesando datos EQ_Corte:", error);
                // Datos por defecto en caso de error
                equiposCorteData = [
                    {eq: 1, nombre: "Mesa 1"},
                    {eq: 2, nombre: "Mesa 2"}
                ];
                renderModalEQCorte();
            }
        };

        function renderModalEQCorte() {
            const tbody = document.getElementById('modal-eq-corte-tbody');
            let html = '';
            
            equiposCorteData.forEach((equipo, index) => {
                const isLast = (index === equiposCorteData.length - 1);
                const btnHTML = isLast ? '<button class="btn-tendido" onclick="agregarEquipoCorte()" style="margin-right: 6px;" title="Agregar equipo">+</button>' : '';
                html += `
                    <tr>
                        <td style="text-align: center; font-weight: 600;">${btnHTML}${equipo.eq}</td>
                        <td><input type="text" value="${equipo.nombre}" onchange="equiposCorteData[${index}].nombre = this.value" style="width: 100%; padding: 6px; border: 1px solid var(--gray-300); border-radius: 4px;"></td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
        }

        window.agregarEquipoCorte = function() {
            // Calcular el siguiente número EQ basado en los datos existentes
            let nextEQ = 1;
            if (equiposCorteData.length > 0) {
                const maxEQ = Math.max(...equiposCorteData.map(e => parseInt(e.eq) || 0));
                nextEQ = maxEQ + 1;
            }
            
            equiposCorteData.push({
                eq: nextEQ,
                nombre: `Equipo ${nextEQ}`
            });
            renderModalEQCorte();
        };

        window.cerrarModalEQCorte = function() {
            document.getElementById('modal-eq-corte').classList.remove('active');
        };

        window.guardarModalEQCorte = function() {
            // Validar que todos los nombres estén completos
            const nombresVacios = equiposCorteData.some(e => !e.nombre || e.nombre.trim() === '');
            if (nombresVacios) {
                alert('Por favor complete todos los nombres de equipos.');
                return;
            }

            try {
                // Enviar cada equipo al backend
                equiposCorteData.forEach((equipo, index) => {
                    fetch(WEB_APP_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        body: JSON.stringify({
                            action: "updateEQCorte",
                            eq: equipo.eq,
                            nombre: equipo.nombre,
                            row: index + 1 // +1 para header
                        })
                    }).catch(e => console.error(`Error guardando equipo ${equipo.eq}`, e));
                });

                alert(`Se han guardado ${equiposCorteData.length} equipos de corte.`);
                cerrarModalEQCorte();
                
            } catch (e) {
                console.error('Error guardando equipos:', e);
                alert('Error al guardar los equipos.');
            }
        };
    </script>

    <script>
        (function(){
            // Stock funnel: código de visualización removido.
            // Se mantiene una función de cierre mínima para compatibilidad con el modal HTML.
            window.closeStockFunnelModal = function() {
                const modal = document.getElementById('modal-stock-funnel');
                if (!modal) return;
                modal.classList.remove('active');
            };
        })();
    </script>

    <!-- MENÚ CONTEXTUAL DE FILTRO PARA TABLA HABILITADO -->
    <div id="habilitado-context-menu" class="context-menu">
        <div style="padding: 12px 16px; font-weight: 600; border-bottom: 1px solid var(--gray-100);">
            Filtrar por: <span id="habilitado-filter-field">Campo</span>
        </div>
        <div class="context-menu-input">
            <input type="text" id="habilitado-filter-input" placeholder="Ingrese valor a filtrar..." autocomplete="off" style="display: none;">
            <select id="habilitado-filter-select" style="display: none; width: 100%; padding: 8px; border: 1px solid var(--gray-300); border-radius: 4px; font-size: 12px; box-sizing: border-box;">
                <option value="">-- Seleccione un valor --</option>
            </select>
        </div>
        <div class="context-menu-buttons">
            <button class="context-menu-btn cancel" onclick="hideHabilitadoContextMenu()">Cancelar</button>
            <button class="context-menu-btn cancel" onclick="clearHabilitadoFilter()" style="background: #ef4444; color: white;">Limpiar</button>
            <button class="context-menu-btn apply" onclick="applyHabilitadoFilter()">Aplicar</button>
        </div>
    </div>

    <!-- MENÚ CONTEXTUAL DE FILTRO PARA TABLA BLOQUEO -->
    <div id="bloqueo-context-menu" class="context-menu">
        <div style="padding: 12px 16px; font-weight: 600; border-bottom: 1px solid var(--gray-100);">
            Filtrar por: <span id="bloqueo-filter-field">Campo</span>
        </div>
        <div class="context-menu-input">
            <input type="text" id="bloqueo-filter-input" placeholder="Ingrese valor a filtrar..." autocomplete="off" style="display: none;">
            <select id="bloqueo-filter-select" style="display: none; width: 100%; padding: 8px; border: 1px solid var(--gray-300); border-radius: 4px; font-size: 12px; box-sizing: border-box;">
                <option value="">-- Seleccione un valor --</option>
            </select>
        </div>
        <div class="context-menu-buttons">
            <button class="context-menu-btn cancel" onclick="hideBloqueoContextMenu()">Cancelar</button>
            <button class="context-menu-btn cancel" onclick="clearBloqueoFilter()" style="background: #ef4444; color: white;">Limpiar</button>
            <button class="context-menu-btn apply" onclick="applyBloqueoFilter()">Aplicar</button>
        </div>
    </div>

    <!-- MENÚ CONTEXTUAL DE FILTRO PARA TABLA CORTE -->
    <div id="corte-context-menu" class="context-menu">
        <div style="padding: 12px 16px; font-weight: 600; border-bottom: 1px solid var(--gray-100);">
            Filtrar por: <span id="corte-filter-field">Campo</span>
        </div>
        <div class="context-menu-input">
            <input type="text" id="corte-filter-input" placeholder="Ingrese valor a filtrar..." autocomplete="off" style="display: none;">
            <select id="corte-filter-select" style="display: none; width: 100%; padding: 8px; border: 1px solid var(--gray-300); border-radius: 4px; font-size: 12px; box-sizing: border-box;">
                <option value="">-- Seleccione un valor --</option>
            </select>
        </div>
        <div class="context-menu-buttons">
            <button class="context-menu-btn cancel" onclick="hideCorteContextMenu()">Cancelar</button>
            <button class="context-menu-btn cancel" onclick="clearCorteFilter()" style="background: #ef4444; color: white;">Limpiar</button>
            <button class="context-menu-btn apply" onclick="applyCorteFilter()">Aplicar</button>
        </div>
    </div>

    <!-- MENÚ CONTEXTUAL DE FILTRO PARA TABLA ENUMERADO -->
    <div id="enumerado-context-menu" class="context-menu">
        <div style="padding: 12px 16px; font-weight: 600; border-bottom: 1px solid var(--gray-100);">
            Filtrar por: <span id="enumerado-filter-field">Campo</span>
        </div>
        <div class="context-menu-input">
            <input type="text" id="enumerado-filter-input" placeholder="Ingrese valor a filtrar..." autocomplete="off" style="display: none;">
            <select id="enumerado-filter-select" style="display: none; width: 100%; padding: 8px; border: 1px solid var(--gray-300); border-radius: 4px; font-size: 12px; box-sizing: border-box;">
                <option value="">-- Seleccione un valor --</option>
            </select>
        </div>
        <div class="context-menu-buttons">
            <button class="context-menu-btn cancel" onclick="hideEnumeradoContextMenu()">Cancelar</button>
            <button class="context-menu-btn cancel" onclick="clearEnumeradoFilter()" style="background: #ef4444; color: white;">Limpiar</button>
            <button class="context-menu-btn apply" onclick="applyEnumeradoFilter()">Aplicar</button>
        </div>
    </div>

    </body>
    </html>
