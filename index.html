<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tablero de Control de Producción</title>
    <!-- Fuentes e Iconos -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    
    <style>
        :root {
            --primary: #2563eb;
            --primary-light: #eff6ff;
            --success: #10b981;
            --success-light: #ecfdf5;
            --warning: #f59e0b;
            --warning-light: #fffbeb;
            --danger: #ef4444;
            --gray-50: #f8fafc;
            --gray-100: #f1f5f9;
            --gray-200: #e2e8f0;
            --white: #ffffff;
            --gray-300: #cbd5e1;
            --gray-500: #64748b;
            --gray-800: #1e293b;
            --row-group-a: #ffffff;          /* Blanco para grupos alternados */
            --row-group-b: #fffbeb;          /* Amarillo muy claro */
        }

        body {
            font-family: 'Calibri', 'Inter', sans-serif;
            background-color: var(--gray-50);
            color: var(--gray-800);
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: 12px; 
        }

        /* --- HEADER --- */
        header {
            background-color: var(--white);
            border-bottom: 1px solid var(--gray-200);
            padding: 0 30px; 
            height: 55px;    
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .brand {
            font-size: 16px; 
            font-weight: 700;
            color: var(--gray-800);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .brand i { color: var(--primary); font-size: 20px; }

        .nav-tabs { display: flex; gap: 20px; height: 100%; }

        .nav-tab {
            background: none; border: none; height: 100%; padding: 0 8px;
            font-size: 13px; 
            font-weight: 500; color: var(--gray-500);
            cursor: pointer; position: relative; transition: color 0.2s;
            display: flex; align-items: center; gap: 6px;
            font-family: 'Calibri', sans-serif;
        }

        .nav-tab:hover { color: var(--primary); }
        .nav-tab.active { color: var(--primary); font-weight: 600; }
        .nav-tab.active::after {
            content: ''; position: absolute; bottom: 0; left: 0; width: 100%;
            height: 3px; background-color: var(--primary); border-radius: 3px 3px 0 0;
        }

        .badge {
            background-color: var(--gray-200); color: var(--gray-800);
            padding: 1px 6px; border-radius: 10px; font-size: 10px; font-weight: 600;
        }
        .nav-tab.active .badge { background-color: var(--primary-light); color: var(--primary); }

        /* --- CONTENIDO --- */
        main { padding: 20px; flex: 1; overflow-y: auto; overflow-x: hidden; }

        .view-section { display: none; animation: fadeIn 0.4s ease; height: 100%; display: flex; flex-direction: column;}
        .view-section.active { display: flex; } 
        .view-section:not(.active) { display: none; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* --- SUB TABS --- */
        .sub-nav {
            background-color: var(--white); padding: 3px; border-radius: 6px;
            display: inline-flex; gap: 3px; margin-bottom: 15px;
            border: 1px solid var(--gray-200); box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            align-self: flex-start;
        }

        /* Contenedor para filtros (switches) a la derecha de los sub-tabs */
        .sub-filters {
            margin-left: auto; display: flex; gap: 10px; align-items: center;
        }

        .filter-item { display: inline-flex; align-items: center; gap: 8px; font-weight:600; color:var(--gray-600); font-size:12px; }
        .filter-item input[type="checkbox"] { width: 36px; height: 20px; appearance: none; -webkit-appearance:none; border-radius: 999px; background: #e5e7eb; position: relative; cursor: pointer; outline: none; transition: background 0.15s ease; }
        .filter-item input[type="checkbox"]::before { content: ''; position: absolute; top: 3px; left: 4px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: transform 0.15s ease; box-shadow: 0 1px 2px rgba(0,0,0,0.12); }
        .filter-item input[type="checkbox"]:checked { background: var(--primary); }
        .filter-item input[type="checkbox"]:checked::before { transform: translateX(16px); }

        /* Reducir tamaño del switch y etiqueta 'Normal' en 40% */
        .filter-item input#flt-normal { width: 22px; height: 12px; }
        .filter-item input#flt-normal::before { top: 2px; left: 2px; width: 8px; height: 8px; }
        .filter-item input#flt-normal:checked::before { transform: translateX(9px); }
        .filter-item input#flt-normal + span { font-size: 7.2px; }

        .sub-tab {
            border: none; background: none; padding: 5px 12px; border-radius: 5px;
            font-size: 15.5px; 
            font-weight: 500; color: var(--gray-500); cursor: pointer; transition: all 0.2s;
            display: flex; align-items: center; gap: 5px;
            font-family: 'Calibri', sans-serif;
        }
        .sub-tab:hover { background-color: var(--gray-50); }
        .sub-tab.active { background-color: var(--primary-light); color: var(--primary); font-weight: 600; }

        .kg-badge {
            font-size: 12px;
            background-color: rgba(0,0,0,0.05);
            padding: 1px 5px;
            border-radius: 3px;
            color: inherit;
        }
        .sub-tab.active .kg-badge { background-color: rgba(37, 99, 235, 0.1); color: var(--primary); }

        /* --- TABLA MODERNIZADA Y COMPACTA --- */
        .table-container {
            background: var(--white);
            border-radius: 10px;
            border: 1px solid var(--gray-200);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow: auto;
            flex: 1;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px; 
            min-width: 1200px; 
            table-layout: fixed;
        }

        thead th {
            background-color: rgb(0,112,192);
            color: #ffffff;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 13px; 
            letter-spacing: 0.5px;
            padding: 8px 6px; 
            text-align: left;
            border-bottom: 1px solid var(--gray-200);
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        tbody td {
            padding: 5px 6px; 
            border-bottom: 1px solid var(--gray-100);
            vertical-align: middle;
            color: var(--gray-800);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2; 
        }

        /* --- ESTILOS DE FILAS AGRUPADAS --- */
        tr.group-a { background-color: var(--row-group-a); }
        tr.group-b { background-color: var(--row-group-b); }

        /* HOVER: Sombreado oscuro (aprox 30% visual) */
        tr.group-a:hover, tr.group-b:hover { 
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.15) !important; 
        }

        tbody tr:last-child td { border-bottom: none; }

        /* --- ESTILOS DE CELDA --- */
        .op-cell { font-weight: 600; color: var(--gray-800); }
        .kg-cell { font-family: 'Calibri', 'Inter', sans-serif; font-weight: 600; font-size: 11px; }
        .date-cell { color: var(--gray-800); font-size: 11px; }

        /* --- SELECTS COMPACTOS --- */
        select.table-select {
            appearance: none;
            padding: 3px 6px; 
            padding-right: 18px; 
            border-radius: 4px;
            border: 1px solid var(--gray-300);
            background-color: var(--white);
            font-size: 11px; 
            font-weight: 500;
            cursor: pointer;
            width: 100%;
            min-width: 80px; 
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' fill='%2364748b' viewBox='0 0 16 16'%3E%3Cpath d='M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 4px center;
            transition: all 0.2s;
            height: 24px; 
            font-family: 'Calibri', sans-serif;
        }

        select.table-select:disabled {
            background-color: var(--gray-100); color: var(--gray-400); border-color: var(--gray-200);
            cursor: not-allowed; background-image: none;
        }

        select.table-select:focus { outline: none; border-color: var(--primary); }

        .sel-PROG { border-color: var(--warning) !important; color: #b45309; background-color: var(--warning-light); }
        .sel-OK { border-color: var(--success) !important; color: #047857; font-weight: 600; background-color: var(--success-light); }
        .sel-ENLAV { border-color: #6366f1 !important; color: #4338ca; background-color: #e0e7ff; }

        /* Tags de estado */
        .status-tag {
            display: inline-flex; align-items: center; gap: 4px; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 600;
        }
        .tag-success { background-color: var(--success-light); color: var(--success); }
        .tag-neutral { background-color: var(--gray-100); color: var(--gray-600); }

        /* Loader & Error */
        #loader, #error-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000;
        }
        #error-screen { display: none; z-index: 1001; }
        .spinner {
            width: 30px; height: 30px; border: 3px solid var(--gray-200);
            border-top: 3px solid var(--primary); border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .error-box {
            background: #fff; padding: 20px; border-radius: 10px; 
            border: 1px solid #fee2e2; box-shadow: 0 5px 10px -3px rgba(0,0,0,0.1);
            max-width: 400px; text-align: center;
        }
        .btn-retry {
            background-color: var(--gray-800); color: white; border: none; padding: 8px 16px;
            border-radius: 5px; cursor: pointer; font-weight: 600; margin-top: 10px; font-size: 12px;
        }
        /* Agrega esto al final de tu CSS */
        .wrap-text {
        white-space: normal !important; /* Permite que el texto baje de linea */
        overflow: visible !important;   /* Muestra todo el contenido */
        text-overflow: clip !important; /* Quita los puntos suspensivos (...) */
        line-height: 1.1 !important;    /* Ajusta la altura de linea para que no ocupe tanto */
        font-size: 10px !important;     /* Reduce un poco la letra para que quepa mejor */
    }
    /* RIB highlight: verde transparente para 'SI LLEVA' */
    .rib-si-lleva {
        background-color: rgba(16,185,129,0.12);
        color: #065f46;
        padding: 3px 8px;
        border-radius: 6px;
        display: inline-block;
        font-weight: 700;
        font-size: 11px;
        line-height: 1;
    }
    .rib-text { display: inline-block; padding: 2px 6px; border-radius: 4px; }
    .rib-danger {
        background-color: rgba(239,68,68,0.10);
        color: #7f1d1d;
        padding: 3px 8px;
        border-radius: 6px;
        display: inline-block;
        font-weight: 700;
        font-size: 11px;
        line-height: 1;
    }
    </style>
    <style>
        /* RUTA badges: small rounded squares with translucent backgrounds */
        .route-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 700;
            font-size: 11px;
            line-height: 1;
            white-space: nowrap;
            vertical-align: middle;
        }
        .route-ac {
            color: #2563eb; /* primary */
            background: rgba(37,99,235,0.08);
            border: 1px solid rgba(37,99,235,0.12);
        }
        .route-lv {
            color: #0ea5a0; /* teal/green-ish */
            background: rgba(16,185,129,0.08);
            border: 1px solid rgba(16,185,129,0.12);
        }
        .route-bloq {
            color: #92400e; /* amber/dark */
            background: rgba(245,158,11,0.08);
            border: 1px solid rgba(245,158,11,0.12);
        }
        .route-xlav {
            color: #6d28d9; /* violet */
            background: rgba(124,58,237,0.06);
            border: 1px solid rgba(124,58,237,0.10);
        }

        /* --- MODAL TENDIDO --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-overlay.active {
            display: flex;
        }
        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            /* Reduce modal width to ~60% of previous default */
            width: 60%;
            min-width: 260px;
            max-width: 500px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            animation: modalSlideIn 0.3s ease;
        }
        .modal-content { box-sizing: border-box; }
        @keyframes modalSlideIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--gray-200);
        }
        .modal-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--gray-800);
        }
        .modal-subtitle {
            font-size: 13px;
            color: var(--gray-500);
            margin-top: 4px;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--gray-500);
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .modal-close:hover {
            background: var(--gray-100);
            color: var(--gray-800);
        }
        /* Ensure modal tables don't inherit the global min-width
           and make the table 80% of the modal width, centered.
           Add border so the right edge is visible even if table is centered. */
        .modal-table {
            width: 90%;
            border-collapse: collapse;
            margin: 0 auto 20px auto;
            min-width: 0 !important;
            table-layout: fixed;
            word-break: break-word;
            border: 1px solid var(--gray-200);
            border-radius: 6px;
            overflow: hidden;
            background: white;
        }
        .modal-table th {
            background: var(--gray-100);
            padding: 10px 12px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: var(--gray-600);
            border-bottom: 1px solid var(--gray-200);
        }
        .modal-table td {
            padding: 10px 12px;
            border-bottom: 1px solid var(--gray-100);
            font-size: 13px;
        }

        /* Vertical separators so the right border is visible when table is centered */
        .modal-table th:not(:last-child),
        .modal-table td:not(:last-child) {
            border-right: 1px solid var(--gray-100);
        }
        .modal-table input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }
        .modal-table input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }
        .modal-table input:disabled {
            background: var(--gray-50);
            color: var(--gray-600);
        }
        .oc-link { cursor: pointer; color: var(--primary); font-weight:700; }
        .oc-link:hover { text-decoration: underline; }
        /* In Corte Pzas view OC should not look clickable */
        #view-corte .oc-link {
            color: inherit !important;
            cursor: default !important;
            text-decoration: none !important;
            font-weight: 600 !important;
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .btn-modal {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }
        .btn-limpiar {
            background: var(--gray-100);
            color: var(--gray-700);
        }
        .btn-limpiar:hover {
            background: var(--gray-200);
        }
        .btn-guardar {
            background: var(--primary);
            color: white;
        }
        .btn-guardar:hover {
            background: #1d4ed8;
        }

        /* Botón de más para tendido */
        .btn-tendido {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background: var(--primary-light);
            color: var(--primary);
            border: 1px solid var(--primary);
            border-radius: 3px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            margin-right: 6px;
            transition: all 0.2s;
            line-height: 1;
        }
        .btn-tendido:hover {
            background: var(--primary);
            color: white;
        }
        /* Botón pequeño de lavadora (icono) junto a OP-PTDA */
        .btn-washer {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background: #eef2ff;
            color: #4338ca;
            border: 1px solid rgba(67,56,202,0.18);
            border-radius: 3px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            margin-right: 0.5px;
            transition: all 0.12s;
            line-height: 1;
        }
        .btn-washer:hover { background: #4338ca; color: white; }
    </style>
    <style>
        /* Estilos para botón flotante del embudo */
        #stock-funnel-button {
            position: fixed;
            top: 38px;
            right: 12px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--white);
            border: 2px solid var(--primary);
            color: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 18px rgba(16,24,40,0.12);
            z-index: 2200;
            cursor: pointer;
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }
        #stock-funnel-button:hover { transform: translateY(-2px); box-shadow: 0 10px 24px rgba(16,24,40,0.16); }

        /* Contenedor del gráfico (ahora barras horizontales) */
        #funnel-chart { min-height: 220px; display: flex; flex-direction: column; gap: 10px; align-items: stretch; }
        .funnel-block {
            display: flex;
            gap: 4px; /* reducido para acercar label/bar/valor */
            align-items: center;
            padding: 1px 2px; /* menos padding vertical/horizontal */
            border-radius: 6px;
            background: transparent;
            box-shadow: 0 4px 12px rgba(2,6,23,0.04);
        }
        .funnel-label { width: 120px; font-size: 13px; font-weight: 700; color: #374151; padding-left:6px; }
        .funnel-bar {
            height: 28px;
            flex: 1;
            background: rgba(15,23,42,0.06);
            border-radius: 999px;
            overflow: hidden;
            display: flex;
            align-items: center;
        }
        .bar-fill {
            height: 100%;
            border-radius: 999px;
            display: block;
            transition: width 350ms ease;
        }
        .funnel-value {
            width: 90px;
            text-align: right;
            font-weight: 800;
            color: #374151;
            padding-left: 12px;
            font-size: 13px;
        }
        /* Adjust label/value contrast for specific color classes (use on .bar-fill) */
        .c-bloqueo { background: #f59e0b; }
        .c-lavanderia { background: #10b981; }
        .c-corte-pzas { background: #2563eb; }
        .c-corte-bloques { background: #f97316; }
        .c-enumerado { background: #fb923c; }
        .c-transfer { background: #f59e0b; }
        .c-bordado { background: #fbbf24; }
        .c-estampado { background: #059669; }
        .c-habilitado { background: #6b7280; }

        /* Colores aproximados a los de la imagen referencial */
        .c-bloqueo { background: #fef3c7; color: #92400e; }
        .c-lavanderia { background: #dcfce7; color: #064e3b; }
        .c-corte-pzas { background: #dbeafe; color: #1e3a8a; }
        .c-corte-bloques { background: #fef3e2; color: #92400e; }
        .c-enumerado { background: #fff7ed; color: #92400e; }
        .c-transfer { background: #fff4e6; color: #92400e; }
        .c-bordado { background: #fff7cc; color: #92400e; }
        .c-estampado { background: #ecfdf5; color: #065f46; }
        .c-habilitado { background: #f3f4f6; color: #111827; }
    </style>
    <style>
        /* Auto-reload timer badge next to title */
        .reload-timer {
            display: inline-block;
            margin-left: 8px;
            padding: 2px 8px;
            border-radius: 12px;
            background: var(--primary-light);
            color: var(--primary);
            font-weight: 700;
            font-size: 12px;
            vertical-align: middle;
        }
    </style>
    <style>
        /* Vista Habilitado: hacer que la tabla ocupe todo el ancho disponible (full-bleed) */
        #view-habilitado .table-container {
            position: relative;
            left: 50%;
            right: 50%;
            margin-left: -50vw; /* empuja hasta el borde izquierdo de la ventana */
            margin-right: -50vw; /* empuja hasta el borde derecho de la ventana */
            width: 100vw;        /* ocupa todo el ancho de la ventana */
            box-sizing: border-box;
            padding: 0;          /* quitar padding para evitar huecos a la derecha */
            max-width: none;
            border-radius: 10px;
            background: transparent;
            overflow: auto;
        }
        #view-habilitado .table-container table {
            min-width: 0 !important;
            width: 100%;
            table-layout: auto; /* permite que las columnas se expandan y ocupen el espacio disponible */
        }
        /* Permitir que los encabezados sean flexibles y que la última columna tome el espacio restante */
        #view-habilitado .table-container thead th {
            width: auto !important;
        }
        #view-habilitado .table-container thead th:last-child {
            width: 100% !important;
        }
    </style>
</head>
<body>

    <!-- LOADER -->
    <div id="loader">
        <div class="spinner"></div>
        <p style="margin-top: 10px; font-weight: 500; color: var(--gray-500); font-size: 12px;">Cargando tabla...</p>
    </div>

    <!-- ERROR SCREEN -->
    <div id="error-screen">
        <div class="error-box">
            <div style="color: var(--danger); font-size: 16px; font-weight: 700; margin-bottom: 8px;"><i class="ph ph-warning-circle"></i> Error</div>
            <div id="error-details" style="color: var(--gray-500); font-size: 12px; line-height: 1.4;"></div>
            <button class="btn-retry" onclick="location.reload()">Reintentar</button>
        </div>
    </div>

    <!-- MODAL TENDIDO -->
    <div id="modal-tendido" class="modal-overlay" onclick="if(event.target === this) cerrarModalTendido()">
        <div class="modal-content">
            <div class="modal-header">
                <div>
                    <div class="modal-title" id="modal-tendido-title">OC: ---</div>
                    <div class="modal-subtitle" id="modal-tendido-subtitle">COLOR: --- | PDS: ---</div>
            </html>
                </div>
                <button class="modal-close" onclick="cerrarModalTendido()">&times;</button>
            </div>
            <table class="modal-table">
                <thead>
                    <tr>
                        <th style="width: 50%;">TENDIDO</th>
                        <th style="width: 50%;">PDS</th>
                    </tr>
                </thead>
                <tbody id="modal-tendido-tbody">
                    <!-- Filas dinámicas -->
                </tbody>
            </table>
            <div class="modal-buttons">
                <button class="btn-modal btn-limpiar" onclick="limpiarModalTendido()">Limpiar</button>
                <button class="btn-modal btn-guardar" onclick="guardarModalTendido()">Guardar</button>
            </div>
        </div>
    </div>

    <!-- MODAL EQ_CORTE -->
    <div id="modal-eq-corte" class="modal-overlay" onclick="if(event.target === this) cerrarModalEQCorte()">
        <div class="modal-content" style="width: 70%; max-width: 600px;">
            <div class="modal-header">
                <div>
                    <div class="modal-title">Equipos de Corte</div>
                    <div class="modal-subtitle">Gestionar lista de equipos</div>
                </div>
                <button class="modal-close" onclick="cerrarModalEQCorte()">&times;</button>
            </div>
            <table class="modal-table">
                <thead>
                    <tr>
                        <th style="width: 30%;">EQ_Corte</th>
                        <th style="width: 70%;">Nombre</th>
                    </tr>
                </thead>
                <tbody id="modal-eq-corte-tbody">
                    <!-- Filas dinámicas -->
                </tbody>
            </table>
            <div class="modal-buttons">
                <button class="btn-modal btn-limpiar" onclick="cerrarModalEQCorte()">Cancelar</button>
                <button class="btn-modal btn-guardar" onclick="guardarModalEQCorte()">Guardar</button>
            </div>
        </div>
    </div>

    <!-- MODAL OC INFO -->
    <div id="modal-oc" class="modal-overlay" onclick="if(event.target === this) cerrarModalOC()">
        <div class="modal-content" style="max-width:420px; width:50%">
            <div class="modal-header">
                <div>
                    <div class="modal-title" id="modal-oc-title">OC COLOR</div>
                    <div class="modal-subtitle" id="modal-oc-subtitle"></div>
                </div>
                <button class="modal-close" onclick="cerrarModalOC()">&times;</button>
            </div>
            <table class="modal-table">
                <tbody id="modal-oc-tbody">
                </tbody>
            </table>
            <div class="modal-buttons">
                <button class="btn-modal btn-limpiar" onclick="cerrarModalOC()">Cerrar</button>
            </div>
        </div>
    </div>

    <!-- BOTÓN FLOTANTE: Stock (embudo) -->
    <div id="stock-funnel-button" title="Ver stock" onclick="window.location.href='stock.html'" aria-label="Ver stock">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 4h18v2H3V4zM6 10h12v2H6v-2zM10 16h4v2h-4v-2z" fill="currentColor"/>
        </svg>
    </div>

    <!-- MODAL STOCK FUNNEL -->
    <div id="modal-stock-funnel" class="modal-overlay" onclick="if(event.target === this) closeStockFunnelModal()">
        <div class="modal-content" style="max-width:480px; width:56%;">
            <div class="modal-header">
                <div>
                    <div class="modal-title">Stock por Estado</div>
                    <div class="modal-subtitle">Visualización tipo embudo - tamaños proporcionales a PDS</div>
                </div>
                <button class="modal-close" onclick="closeStockFunnelModal()">&times;</button>
            </div>
            <div id="funnel-chart" style="padding:8px 6px 16px 6px;">Cargando...</div>
            <div style="display:flex; justify-content:flex-end; gap:8px;">
                <button class="btn-modal btn-limpiar" onclick="closeStockFunnelModal()">Cerrar</button>
            </div>
        </div>
    </div>

    <!-- MODAL CONFIRMACIÓN BLOQUEO -->
    <div id="modal-confirm-bloqueo" class="modal-overlay" onclick="if(event.target === this) cerrarModalConfirmBloq()">
        <div class="modal-content" style="max-width:380px; width:44%;">
            <div class="modal-header">
                <div>
                    <div class="modal-title">¿Está seguro?</div>
                    <div class="modal-subtitle">Confirma cambiar Bloqueo a OK</div>
                </div>
                <button class="modal-close" onclick="cerrarModalConfirmBloq()">&times;</button>
            </div>
            <div style="padding:12px 4px 18px 4px; text-align:center; font-size:13px; color:var(--gray-700);">Esta acción marcará la fila como <strong>OK</strong>.</div>
            <div style="display:flex; justify-content:center; gap:12px; padding-top:6px;">
                <button id="confirm-bloq-no" class="btn-modal btn-limpiar" onclick="handleConfirmBloq(false)">No</button>
                <button id="confirm-bloq-yes" class="btn-modal btn-guardar" onclick="handleConfirmBloq(true)">Si</button>
            </div>
        </div>
    </div>

    <!-- MODAL CONFIRMACIÓN CORTE -->
    <div id="modal-confirm-corte" class="modal-overlay" onclick="if(event.target === this) cerrarModalConfirmCorte()">
        <div class="modal-content" style="max-width:420px; width:46%;">
            <div class="modal-header">
                <div>
                    <div class="modal-title">¿Está seguro?</div>
                    <div class="modal-subtitle">Confirma marcar STATUS_CORTE como <strong>OK</strong>?</div>
                </div>
                <button class="modal-close" onclick="cerrarModalConfirmCorte()">&times;</button>
            </div>
            <div style="padding:12px 8px; text-align:center; font-size:13px; color:var(--gray-700);">Al confirmar se aplicará la lógica habitual para cambios a OK en Corte.</div>
            <div style="display:flex; justify-content:center; gap:12px; padding-top:6px;">
                <button id="confirm-corte-no" class="btn-modal btn-limpiar" onclick="handleConfirmCorte(false)">No</button>
                <button id="confirm-corte-yes" class="btn-modal btn-guardar" onclick="handleConfirmCorte(true)">Si</button>
            </div>
        </div>
    </div>

    <!-- MODAL CONFIRMACIÓN ENUMERADO -->
    <div id="modal-confirm-enumerado" class="modal-overlay" onclick="if(event.target === this) cerrarModalConfirmEnumerado()">
        <div class="modal-content" style="max-width:380px; width:44%;">
            <div class="modal-header">
                <div>
                    <div class="modal-title">¿Está seguro?</div>
                    <div class="modal-subtitle">Confirma cambiar estado de Enumerado a OK ENM / OK Paqueteo</div>
                </div>
                <button class="modal-close" onclick="cerrarModalConfirmEnumerado()">&times;</button>
            </div>
            <div style="padding:12px 6px; text-align:center; font-size:13px; color:var(--gray-700);">Esta acción aplicará la lógica habitual para `estado_enumerado`.</div>
            <div style="display:flex; justify-content:center; gap:12px; padding-top:6px;">
                <button id="confirm-enm-no" class="btn-modal btn-limpiar" onclick="handleConfirmEnumerado(false)">No</button>
                <button id="confirm-enm-yes" class="btn-modal btn-guardar" onclick="handleConfirmEnumerado(true)">Si</button>
            </div>
        </div>
    </div>

    <!-- MODAL LAVADORA (Abrir desde Corte PROG 1T/2T/3T) -->
    <div id="modal-lavadora" class="modal-overlay" onclick="if(event.target === this) cerrarModalLavado()">
        <div class="modal-content" style="max-width:420px; width:46%;">
            <div class="modal-header">
                <div>
                    <div class="modal-title" id="modal-lavadora-title">Lavado</div>
                    <div class="modal-subtitle" id="modal-lavadora-sub">Estado actual: -</div>
                </div>
                <button class="modal-close" onclick="cerrarModalLavado()">&times;</button>
            </div>
            <div style="padding:8px 6px; font-size:13px; color:var(--gray-700);">
                <div style="margin-bottom:10px;"><strong>RUTA TELA:</strong> <span id="modal-lavadora-ruta">-</span></div>
                <div style="margin-bottom:12px;">Seleccione acción:</div>
                <div style="display:flex; gap:10px; align-items:center;">
                    <select id="modal-lavadora-select" class="table-select">
                        <option value="">-- Seleccione --</option>
                        <option value="EN LAV">EN LAV (devolución)</option>
                    </select>
                </div>
            </div>
            <div style="display:flex; justify-content:flex-end; gap:8px; padding-top:8px;">
                <button class="btn-modal btn-limpiar" onclick="cerrarModalLavado()">Cancelar</button>
                <button class="btn-modal btn-guardar" onclick="onModalLavadoraApply()">Aplicar</button>
            </div>
        </div>
    </div>

    <!-- MODAL CONFIRMACIÓN LAVADORA -->
    <div id="modal-confirm-washer" class="modal-overlay" onclick="if(event.target === this) cerrarModalConfirmWasher()">
        <div class="modal-content" style="max-width:360px; width:40%;">
            <div class="modal-header">
                <div>
                    <div class="modal-title">¿Está seguro?</div>
                    <div class="modal-subtitle">Confirma marcar estado_lavada como <strong>EN LAV</strong>?</div>
                </div>
                <button class="modal-close" onclick="cerrarModalConfirmWasher()">&times;</button>
            </div>
            <div style="padding:12px 6px; text-align:center; font-size:13px; color:var(--gray-700);">Al confirmar se escribirá el valor en la columna <strong>estado_lavada</strong>.</div>
            <div style="display:flex; justify-content:center; gap:12px; padding-top:6px;">
                <button id="confirm-wash-no" class="btn-modal btn-limpiar" onclick="handleConfirmWasher(false)">No</button>
                <button id="confirm-wash-yes" class="btn-modal btn-guardar" onclick="handleConfirmWasher(true)">Si</button>
            </div>
        </div>
    </div>

    <!-- HEADER -->
    <header>
        <div class="brand"><span class="icon-link disabled" title="Cargar giros" style="color:inherit;text-decoration:none;display:inline-flex;align-items:center;" aria-disabled="true"><i class="ph ph-table"></i></span> Prog Corte/Habilitado <span id="auto-reload-timer" class="reload-timer" title="Auto-reload cada 10 minutos">--</span></div>
        <nav class="nav-tabs">
            <button class="nav-tab active" onclick="switchView('bloqueo', this)">
                <i class="ph ph-lock-key"></i> Bloqueo <span class="badge" id="count-bloqueo">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('lavado', this)">
                <i class="ph ph-drop"></i> Lavanderia <span class="badge" id="count-lavado">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('corte', this)">
                <i class="ph ph-scissors"></i> Corte Pzas <span class="badge" id="count-corte">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('corte-bloques', this)">
                <i class="ph ph-stack"></i> Corte Bloques <span class="badge" id="count-corte-bloques">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('enumerado', this)">
                <i class="ph ph-list-numbers"></i> Enumerado <span class="badge" id="count-enumerado">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('transfer', this)">
                <i class="ph ph-stamp"></i> Transfer <span class="badge" id="count-transfer">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('artes', this)">
                <i class="ph ph-feather"></i> Artes (Pza) <span class="badge" id="count-artes">0</span>
            </button>
            <button class="nav-tab" onclick="switchView('habilitado', this)">
                <i class="ph ph-check-square"></i> Habilitado <span class="badge" id="count-habilitado">0</span>
            </button>
        </nav>
    </header>

    <main>
        
        <!-- VISTA BLOQUEO (TABLA) -->
        <section id="view-bloqueo" class="view-section active">
            <div class="sub-nav">
                <button id="btn-xprog" class="sub-tab" onclick="filterBloqueo('X PROG', this)">
                    Por Programar <span class="kg-badge" id="kg-xprog">[-]</span>
                </button>
                <button id="btn-prog" class="sub-tab active" onclick="filterBloqueo('PROG', this)">
                    Programado <span class="kg-badge" id="kg-prog">[-]</span>
                </button>
            </div>
            
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 65px;">F. DESPACHO</th>
                            <th style="width: 65px;">F.ING.COST</th>
                            <th style="width: 30px;">CLIENTE</th>
                            
                            <!-- AUMENTADO A 80px PARA VER DATOS LARGOS -->
                            <th style="width: 80px;">OP-PTDA</th>
                            
                            <th style="width: 40px;">OC</th>
                            <th style="width: 65px;">COLOR</th> 
                            <th style="width: 65px; text-align:right;">KG GIRADOS</th>
                            <th style="width: 70px;">ART.</th>
                            <th style="width: 45px;">#MOLDE</th>
                            <th style="width: 65px;">TIPO CERT.</th>
                            <th style="width: 50px;">Bloqueo</th>
                            <th style="width: 50px;">RIB</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-bloqueo"></tbody>
                </table>
            </div>
        </section>

        <!-- VISTA ENUMERADO (FILAS CON STATUS = OK) -->
        <section id="view-enumerado" class="view-section">
            <div class="sub-nav" style="margin-bottom:10px;">
                <button id="enumerado-btn-por" class="sub-tab active">
                    Por enumerar <span class="kg-badge" id="enumerado-pds-por">[-]</span>
                </button>
            </div>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 75px;">F. DESPACHO</th>
                            <th style="width: 75px;">F.ING.COST</th>
                            <th style="width: 40px;">CLIENTE</th>
                            <th style="width: 50px;">RUTA</th>
                            <th style="width: 45px;">OC</th>
                            <th style="width: 80px;">COLOR</th>
                            <th style="width: 80px;">OP-PTDA</th>
                            <th style="width: 45px; text-align:center;">PDS</th>
                            <th style="width: 60px;">PRENDA</th>
                            <th style="width: 70px;">ART.</th>
                            <th style="width: 70px;">TIPO CERT.</th>
                            <th style="width: 85px;">RIB</th>
                            <th style="width: 80px;">equipo_corte</th>
                            <th style="width: 80px;">STATUS_CORTE</th>
                            <th style="width: 80px;">BLOQUES?</th>
                            <th style="width: 80px;">COLL o TAP?</th>
                            <th style="width: 80px;">estado_enumerado</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-enumerado"></tbody>
                </table>
            </div>
        </section>

        <!-- VISTA TRANSFER -->
        <section id="view-transfer" class="view-section">
            <div class="sub-nav">
                <button id="btn-transfer-xprog" class="sub-tab active" onclick="filterTransfer('X PROG', this)">
                    Por Programar <span class="kg-badge" id="transfer-pds-xprog">[-]</span>
                </button>
                <button id="btn-transfer-prog" class="sub-tab" onclick="filterTransfer('PROG', this)">
                    Programado <span class="kg-badge" id="transfer-pds-prog">[-]</span>
                </button>
                <button id="btn-transfer-asignar" class="sub-tab" onclick="filterTransfer('ASIGNAR', this)" style="display:none;">
                    Asignar #Trf
                </button>
            </div>
            
            <!-- Filtros para Asignar #Trf -->
            <div id="transfer-asignar-filters" style="display:none; margin-bottom:15px; gap:10px; align-items:center;">
                <label style="font-weight:600; font-size:12px; color:var(--gray-600);">Filtrar por:</label>
                <!-- Nuevo filtro: Todos / Con dato / Sin dato -->
                <select id="filter-transfer-haydato" style="padding:6px 10px; border-radius:4px; border:1px solid var(--gray-300); font-size:12px;" onchange="renderTransferAsignar()">
                    <option value="">Todos</option>
                    <option value="CON">Con dato</option>
                    <option value="SIN">Sin dato</option>
                </select>
                <select id="filter-transfer-cliente" style="padding:6px 10px; border-radius:4px; border:1px solid var(--gray-300); font-size:12px;" onchange="renderTransferAsignar()">
                    <option value="">Todos los clientes</option>
                </select>
                <select id="filter-transfer-estilo" style="padding:6px 10px; border-radius:4px; border:1px solid var(--gray-300); font-size:12px;" onchange="renderTransferAsignar()">
                    <option value="">Todos los estilos</option>
                </select>
                <button onclick="guardarCambiosAsignarTransfer()" style="padding:6px 16px; background:var(--primary); color:white; border:none; border-radius:4px; font-weight:600; cursor:pointer; font-size:12px;">Guardar</button>
                <label class="filter-item" style="margin-left:8px; font-weight:600; font-size:12px; display:inline-flex; align-items:center; gap:6px;">
                    <input type="checkbox" id="chk-transfer-para-todo" style="width:18px;height:18px;vertical-align:middle;"> Para todo
                </label>
            </div>
            
            <div id="table-container-transfer-normal" class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 75px;">F. DESPACHO</th>
                            <th style="width: 75px;">F.ING.COST</th>
                            <th style="width: 40px;">CLIENTE</th>
                            <th style="width: 50px;">RUTA</th>
                            <th style="width: 45px;">OC</th>
                            <th style="width: 80px;">COLOR</th>
                            <th style="width: 45px; text-align:center;">PDS</th>
                            <th style="width: 60px;">PRENDA</th>
                            <th style="width: 70px;">TIPO CERT.</th>
                            <th style="width: 90px;">n.transfxpda</th>
                                        <th style="width: 90px;">tipo-transfer</th>
                                        <th style="width: 90px;">estado_transfer</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-transfer"></tbody>
                </table>
            </div>
            
            <!-- Tabla para Asignar #Trf -->
            <div id="table-container-transfer-asignar" class="table-container" style="display:none;">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 150px;">CLIENTE</th>
                            <th style="width: 200px;">ESTILO</th>
                            <th style="width: 120px;">tipo-transfer</th>
                            <th style="width: 150px;">n.transfxpda</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-transfer-asignar"></tbody>
                </table>
            </div>
        </section>
        
        <!-- VISTA ARTES (Pza) -->
        <section id="view-artes" class="view-section">
            <div class="sub-nav">
                <button id="btn-artes-bordado" class="sub-tab active" onclick="filterArtes('BORDADO', this)">
                    Bordado <span class="kg-badge" id="artes-pds-bordado">[-]</span>
                </button>
                <button id="btn-artes-estampado" class="sub-tab" onclick="filterArtes('ESTAMPADO', this)">
                    Estampado <span class="kg-badge" id="artes-pds-estampado">[-]</span>
                </button>
                <button id="btn-artes-asignar" class="sub-tab" onclick="filterArtes('ASIGNAR', this)" style="display:none;">
                    Asginar Artes
                </button>
            </div>

            <!-- Sub-tabs específicos para Bordado: X PROG / PROG -->
            <div id="bordado-subtabs" style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
                <button id="btn-bordado-xprog" class="sub-tab active" onclick="filterBordado('X PROG', this)">X PROG <span class="kg-badge" id="artes-bordado-xprog-count">[-]</span></button>
                <button id="btn-bordado-prog" class="sub-tab" onclick="filterBordado('PROG', this)">PROG <span class="kg-badge" id="artes-bordado-prog-count">[-]</span></button>
            </div>

            <!-- Sub-tabs específicos para Estampado: X PROG / PROG (oculto hasta activar Estampado) -->
            <div id="estampado-subtabs" style="display:none; gap:8px; align-items:center; margin-bottom:10px;">
                <button id="btn-estampado-xprog" class="sub-tab active" onclick="filterEstampado('X PROG', this)">X PROG <span class="kg-badge" id="artes-estampado-xprog-count">[-]</span></button>
                <button id="btn-estampado-prog" class="sub-tab" onclick="filterEstampado('PROG', this)">PROG <span class="kg-badge" id="artes-estampado-prog-count">[-]</span></button>
            </div>

            <!-- Filtros para Asignar Artes -->
            <div id="artes-asignar-filters" style="display:none; margin-bottom:15px; gap:10px; align-items:center;">
                <label style="font-weight:600; font-size:12px; color:var(--gray-600);">Filtrar por:</label>
                <select id="filter-artes-haydato" style="padding:6px 10px; border-radius:4px; border:1px solid var(--gray-300); font-size:12px;" onchange="renderArtesAsignar()">
                    <option value="">Todos</option>
                    <option value="CON">Con dato</option>
                    <option value="SIN">Sin dato</option>
                </select>
                <select id="filter-artes-cliente" style="padding:6px 10px; border-radius:4px; border:1px solid var(--gray-300); font-size:12px;" onchange="renderArtesAsignar()">
                    <option value="">Todos los clientes</option>
                </select>
                <select id="filter-artes-estilo" style="padding:6px 10px; border-radius:4px; border:1px solid var(--gray-300); font-size:12px;" onchange="renderArtesAsignar()">
                    <option value="">Todos los estilos</option>
                </select>
                <button onclick="guardarCambiosAsignarArtes()" style="padding:6px 16px; background:var(--primary); color:white; border:none; border-radius:4px; font-weight:600; cursor:pointer; font-size:12px;">Guardar</button>
                <label class="filter-item" style="margin-left:8px; font-weight:600; font-size:12px; display:inline-flex; align-items:center; gap:6px;">
                    <input type="checkbox" id="chk-artes-para-todo" style="width:18px;height:18px;vertical-align:middle;"> Para todo
                </label>
            </div>

            <!-- Tabla Bordado -->
            <div id="table-container-artes-bordado" class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 75px;">F. DESPACHO</th>
                            <th style="width: 75px;">F.ING.COST</th>
                            <th style="width: 40px;">CLIENTE</th>
                            <th style="width: 45px;">OC</th>
                            <th style="width: 80px;">COLOR</th>
                            <th style="width: 45px; text-align:center;">PDS</th>
                            <th style="width: 60px;">PRENDA</th>
                            <th style="width: 70px;">TIPO CERT.</th>
                            <th style="width: 80px;">n.BDxpda</th>
                            <th style="width: 100px;">estado_bordado</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-artes-bordado"></tbody>
                </table>
            </div>

            <!-- Tabla Estampado -->
            <div id="table-container-artes-estampado" class="table-container" style="display:none;">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 75px;">F. DESPACHO</th>
                            <th style="width: 75px;">F.ING.COST</th>
                            <th style="width: 40px;">CLIENTE</th>
                            <th style="width: 45px;">OC</th>
                            <th style="width: 80px;">COLOR</th>
                            <th style="width: 45px; text-align:center;">PDS</th>
                            <th style="width: 60px;">PRENDA</th>
                            <th style="width: 70px;">TIPO CERT.</th>
                            <th style="width: 80px;">n.ESTAMPxpda</th>
                            <th style="width: 100px;">estado_estampado</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-artes-estampado"></tbody>
                </table>
            </div>

            <!-- Tabla para Asignar Artes -->
            <div id="table-container-artes-asignar" class="table-container" style="display:none;">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 150px;">CLIENTE</th>
                            <th style="width: 200px;">ESTILO</th>
                            <th style="width: 140px;">n.BDxpda</th>
                            <th style="width: 140px;">n.ESTAMPxpda</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-artes-asignar"></tbody>
                </table>
            </div>
        </section>

                <!-- VISTA HABILITADO (Filtrado de Enumerado con estado_enumerado = OK ENM / OK S/ENM) -->
                <section id="view-habilitado" class="view-section">
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th style="width: 75px;">F. DESPACHO</th>
                                    <th style="width: 75px;">F.ING.COST</th>
                                    <th style="width: 40px;">CLIENTE</th>
                                    <th style="width: 50px;">RUTA</th>
                                    <th style="width: 45px;">OC</th>
                                    <th style="width: 80px;">COLOR</th>
                                    <th style="width: 80px;">OP-PTDA</th>
                                    <th style="width: 45px; text-align:center;">PDS</th>
                                    <th style="width: 60px;">PRENDA</th>
                                    <th style="width: 70px;">ART.</th>
                                    <th style="width: 70px;">TIPO CERT.</th>
                                    <th style="width: 85px;">RIB</th>
                                    <th style="width: 80px;">equipo_corte</th>
                                    <th style="width: 80px;">STATUS_CORTE</th>
                                    <th style="width: 80px;">BLOQUES?</th>
                                    <th style="width: 80px;">ESTADO_BLOQS</th>
                                    <th style="width: 80px;">COLL o TAP?</th>
                                    <th style="width: 100px;">estado_corte_bloques</th>
                                    <th style="width: 60px; text-align:center;">TRSF</th>
                                    <th style="width: 100px;">estado_bordado</th>
                                    <th style="width: 100px;">estado_estampado</th>
                                    <th style="width: 100px;">estado_habilitado</th>
                                    <th style="width: 80px;">estado_enumerado</th>
                                </tr>
                            </thead>
                            <tbody id="tbody-habilitado"></tbody>
                        </table>
                    </div>
                </section>

        <!-- VISTA LAVADO (TABLA DETALLADA) -->
        <section id="view-lavado" class="view-section">
            <div class="sub-nav">
                <!-- Solo un botón "Por Lavar" -->
                <button id="btn-enlav" class="sub-tab active" onclick="filterLavado('EN LAV', this)">
                    Por Lavar <span class="kg-badge" id="kg-enlav">[-]</span>
                </button>
            </div>

            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 65px;">F. DESPACHO</th>
                            <th style="width: 65px;">F.ING.COST</th>
                            <th style="width: 30px;">CLIENTE</th>
                            
                            <!-- AUMENTADO A 80px -->
                            <th style="width: 80px;">OP-PTDA</th>
                            
                            <th style="width: 40px;">OC</th>
                            <th style="width: 65px;">COLOR</th> 
                            <th style="width: 65px; text-align:right;">KG GIRADOS</th>
                            <th style="width: 70px;">ART.</th>
                            <th style="width: 65px;">TIPO CERT.</th>
                            <th style="width: 100px;">Lavado</th>
                            <th style="width: 85px;">RIB</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-lavado"></tbody>
                </table>
            </div>
        </section>

        <!-- VISTA CORTE (TABLA) -->
        <section id="view-corte" class="view-section">
            <div class="sub-nav" style="margin-bottom:10px;">
                <button id="corte-btn-xprog" class="sub-tab active" onclick="filterCorte('X PROG', this)">
                    Por Programar <span class="kg-badge" id="corte-pds-xprog">[-]</span>
                </button>
                <button id="corte-btn-1t" class="sub-tab" onclick="filterCorte('PROG 1T', this)">
                    PROG 1T <span class="kg-badge" id="corte-pds-1t">[-]</span>
                </button>
                <button id="corte-btn-2t" class="sub-tab" onclick="filterCorte('PROG 2T', this)">
                    PROG 2T <span class="kg-badge" id="corte-pds-2t">[-]</span>
                </button>
                <button id="corte-btn-3t" class="sub-tab" onclick="filterCorte('PROG 3T', this)">
                    PROG 3T <span class="kg-badge" id="corte-pds-3t">[-]</span>
                </button>
                
                    <!-- Filtros por RUTA a la derecha -->
                    <div class="sub-filters" id="corte-route-filters" style="display:flex;">
                        <label class="filter-item"><input type="checkbox" id="flt-lv" onchange="onRouteFilterChange('LV-ok', this.checked)"><span>LV-ok</span></label>
                        <label class="filter-item"><input type="checkbox" id="flt-ac" onchange="onRouteFilterChange('AC', this.checked)"><span>AC</span></label>
                        <label class="filter-item"><input type="checkbox" id="flt-xl" onchange="onRouteFilterChange('x lavar', this.checked)"><span>x lavar</span></label>
                        <label class="filter-item"><input type="checkbox" id="flt-xb" onchange="onRouteFilterChange('x bloq', this.checked)"><span>x bloq</span></label>
                        <label class="filter-item" style="display:none;"><input type="checkbox" id="flt-normal" onchange="onRouteFilterChange('NORMAL', this.checked)"><span>Normal</span></label>
                    </div>
            </div>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 75px;">F. DESPACHO</th>
                            <th style="width: 75px;">F.ING.COST</th>
                            <th style="width: 40px;">CLIENTE</th>
                            <th style="width: 50px;">RUTA</th>
                            <th style="width: 60px;">OC</th>
                            <th style="width: 80px;">COLOR</th>
                            <th style="width: 80px;">OP-PTDA</th>
                            <th style="width: 45px; text-align:center;">PDS</th>
                            <th style="width: 60px;">PRENDA</th>
                            <th style="width: 70px;">ART.</th>
                            <th style="width: 70px;">TIPO CERT.</th>
                            <th style="width: 72px;">RIB</th>
                            <th style="width: 80px;">equipo_corte</th>
                            <th style="width: 80px;">STATUS_CORTE</th>
                            <th style="width: 72px;">estado_bloques</th>
                            <th style="width: 72px;">estado_coll_tap</th>
                    </thead>
                    <tbody id="tbody-corte"></tbody>
                </table>
            </div>
        </section>

        <!-- VISTA CORTE BLOQUES -->
        <section id="view-corte-bloques" class="view-section">
            <div class="sub-nav" style="margin-bottom:10px;">
                <button id="corte-bloques-btn-xprog" class="sub-tab active" onclick="filterCorteBloques('X PROG', this)">
                    Por Programar <span class="kg-badge" id="corte-bloques-pds-xprog">[-]</span>
                </button>
                <button id="corte-bloques-btn-prog" class="sub-tab" onclick="filterCorteBloques('PROG', this)">
                    Programado <span class="kg-badge" id="corte-bloques-pds-prog">[-]</span>
                </button>
            </div>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 75px;">F. DESPACHO</th>
                            <th style="width: 75px;">F.ING.COST</th>
                            <th style="width: 40px;">CLIENTE</th>
                            <th style="width: 50px;">RUTA</th>
                            <th style="width: 60px;">OC</th>
                            <th style="width: 80px;">COLOR</th>
                            <th style="width: 80px;">OP-PTDA</th>
                            <th style="width: 45px; text-align:center;">PDS</th>
                            <th style="width: 60px;">PRENDA</th>
                            <th style="width: 70px;">ART.</th>
                            <th style="width: 70px;">TIPO CERT.</th>
                            <!-- RIB removed -->
                            <th style="width: 85px;">equipo_corte</th>
                            <th style="width: 80px;">STATUS_CORTE</th>
                            <th style="width: 80px;">BLOQUES?</th>
                            <!-- COLL/TAP removed -->
                            <th style="width: 120px;">ESTADO_BLOQS</th>
                        </tr>
                    </thead>
                    <tbody id="tbody-corte-bloques"></tbody>
                </table>
            </div>
        </section>

    </main>

    <script>
        // --- CONFIGURACIÓN ---
        const WEB_APP_URL = "https://script.google.com/macros/s/AKfycbzqWCBDNYhBDPmGUJiFC4v1trfzFt823BYi5HUvSquPuvA9QPgeADn58u1nLm-vTfPivQ/exec"; 
        const SHEET_ID = "18cQuwqerdMggAeJ8TCUKA7-gujXsA91-CRMUTNpr8aQ";

        let rawData = [];
        let colMap = {};
        let currentBloqueoFilter = 'PROG';
        // Filtro aplicado desde el encabezado de Bloqueo (campo + valor)
        let bloqueoHeaderFilter = null; // { field: 'CLIENTE', value: 'ABC' }
        let currentLavadoFilter = 'EN LAV';
        let currentCorteFilter = 'X PROG';
        let currentCorteBloquesFilter = 'X PROG';
        let currentTransferFilter = 'X PROG';

        // Bases de tendidos creadas en esta sesión / previamente: persistidas en localStorage
        try {
            const saved = localStorage.getItem('createdTendidoBases');
            window._createdTendidoBases = new Set(saved ? JSON.parse(saved) : []);
        } catch (e) { window._createdTendidoBases = new Set(); }

        function addCreatedTendidoBase(base) {
            if (!base) return;
            try {
                window._createdTendidoBases.add(base);
                localStorage.setItem('createdTendidoBases', JSON.stringify(Array.from(window._createdTendidoBases)));
            } catch (e) { console.error('Error saving created tendido base', e); }
        }

        // Variables para el modal de tendido
        let modalTendidoData = {
            rowIndex: null,
            oc: '',
            op: '',
            corte: '',
            color: '',
            pdsTotal: 0
        };

        // Maneja cambios en el select de n.transfxpda; si está marcado 'Para todo'
        // aplica el mismo valor a todos los grupos visibles y dispara el guardado.
        window.handleNTransfChange = function(selectElement) {
            const chk = document.getElementById('chk-transfer-para-todo');
            const val = selectElement.value;
            if (chk && chk.checked) {
                const all = Array.from(document.querySelectorAll('#tbody-transfer-asignar select.sel-ntransf-transfer'));
                all.forEach((s, i) => {
                    setTimeout(() => {
                        try {
                            s.disabled = true;
                            s.value = val;
                            updateClienteEstiloTransfer(s.dataset.cliente, s.dataset.estilo, val, s);
                        } catch (e) { console.error('Error aplicando n.transfxpda masivo', e); }
                    }, i * 120);
                });
                chk.checked = false;
            } else {
                updateClienteEstiloTransfer(selectElement.dataset.cliente, selectElement.dataset.estilo, selectElement.value, selectElement);
            }
        };

        // Maneja cambios en el select de tipo-transfer; si está marcado 'Para todo'
        // aplica el mismo valor a todos los grupos visibles y dispara el guardado.
        window.handleTipoTransferChange = function(selectElement) {
            const chk = document.getElementById('chk-transfer-para-todo');
            const val = selectElement.value;
            if (chk && chk.checked) {
                const all = Array.from(document.querySelectorAll('#tbody-transfer-asignar select.sel-tipo-transfer'));
                all.forEach((s, i) => {
                    setTimeout(() => {
                        try {
                            s.disabled = true;
                            s.value = val;
                            updateClienteEstiloTipoTransfer(s.dataset.cliente, s.dataset.estilo, val, s);
                        } catch (e) { console.error('Error aplicando tipo-transfer masivo', e); }
                    }, i * 120);
                });
                // Limpiar el check inmediatamente (se limpiará visualmente);
                // las llamadas de guardado siguen ejecutándose en background.
                chk.checked = false;
            } else {
                updateClienteEstiloTipoTransfer(selectElement.dataset.cliente, selectElement.dataset.estilo, selectElement.value, selectElement);
            }
        };

        // Maneja cambios en n.BDxpda para Asignar Artes. Si 'Para todo' está marcado,
        // aplica el mismo valor a todos los selects visibles en '#tbody-artes-asignar'.
        window.handleNBDChange = function(selectElement) {
            const chk = document.getElementById('chk-artes-para-todo');
            const val = selectElement.value;
            if (chk && chk.checked) {
                const all = Array.from(document.querySelectorAll('#tbody-artes-asignar select.sel-nbd-artes'));
                all.forEach((s, i) => {
                    setTimeout(() => {
                        try {
                            s.disabled = true;
                            s.value = val;
                            updateClienteEstiloArtes(s.dataset.cliente, s.dataset.estilo, val, 'n.BDxpda', s);
                        } catch (e) { console.error('Error aplicando n.BDxpda masivo', e); }
                    }, i * 120);
                });
                chk.checked = false;
            } else {
                updateClienteEstiloArtes(selectElement.getAttribute('data-cliente'), selectElement.getAttribute('data-estilo'), selectElement.value, 'n.BDxpda', selectElement);
            }
        };

        // Maneja cambios en n.ESTAMPxpda para Asignar Artes. Si 'Para todo' está marcado,
        // aplica el mismo valor a todos los selects visibles en '#tbody-artes-asignar'.
        window.handleNESTChange = function(selectElement) {
            const chk = document.getElementById('chk-artes-para-todo');
            const val = selectElement.value;
            if (chk && chk.checked) {
                const all = Array.from(document.querySelectorAll('#tbody-artes-asignar select.sel-nest-artes'));
                all.forEach((s, i) => {
                    setTimeout(() => {
                        try {
                            s.disabled = true;
                            s.value = val;
                            updateClienteEstiloArtes(s.dataset.cliente, s.dataset.estilo, val, 'n.ESTAMPxpda', s);
                        } catch (e) { console.error('Error aplicando n.ESTAMPxpda masivo', e); }
                    }, i * 120);
                });
                chk.checked = false;
            } else {
                updateClienteEstiloArtes(selectElement.getAttribute('data-cliente'), selectElement.getAttribute('data-estilo'), selectElement.value, 'n.ESTAMPxpda', selectElement);
            }
        };

        // Función para actualizar la columna 'tipo-transfer' en todas las filas de un CLIENTE + ESTILO
        window.updateClienteEstiloTipoTransfer = function(cliente, estilo, value, selectElement) {
            if (!cliente || !estilo) return;

            // Buscar índice de tipo-transfer de forma flexible
            let idx = findHeaderIndexCaseInsensitive('tipo-transfer');
            if (idx === -1) idx = findHeaderIndexCaseInsensitive('tipo_transfer');
            if (idx === -1) idx = findHeaderIndexCaseInsensitive('tipotransfer');
            if (idx === -1) idx = colMap['tipo-transfer'] || colMap['tipo_transfer'] || -1;
            if (idx === -1) idx = getColIndex('tipo-transfer');

            if (idx === -1 || idx === undefined) {
                alert('Error: No se encontró la columna tipo-transfer');
                return;
            }

            // Recopilar filas a actualizar
            const rowsToUpdate = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const rowClienteRaw = getVal(row, 'CLIENTE') || '';
                const rowCliente = normalizeClientForTransfer(rowClienteRaw);
                const rowEstilo = getVal(row, 'ESTILO');
                if (rowCliente === cliente && rowEstilo === estilo) {
                    rowsToUpdate.push(i);
                    rawData[i][idx] = value;
                }
            }

            if (rowsToUpdate.length === 0) {
                alert('No se encontraron filas para actualizar');
                return;
            }

            if (selectElement) selectElement.disabled = true;

            let completedCount = 0;
            const totalCount = rowsToUpdate.length;

            rowsToUpdate.forEach((rowIndex, i) => {
                setTimeout(() => {
                    // Determinar nombre exacto de encabezado para enviar al backend
                    let sendColName = (rawData[0] && rawData[0][idx]) ? rawData[0][idx] : 'tipo-transfer';
                    fetch(WEB_APP_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: 'update', row: rowIndex, colName: sendColName, value: value })
                    }).then(() => {
                        completedCount++;
                        if (completedCount === totalCount) {
                            if (selectElement) selectElement.disabled = false;
                            updateCounters();
                            renderTransferAsignar();
                            renderTransfer();
                        }
                    }).catch(err => {
                        console.error('Error al guardar tipo-transfer fila', rowIndex, err);
                        completedCount++;
                        if (completedCount === totalCount) {
                            if (selectElement) selectElement.disabled = false;
                        }
                    });
                }, i * 100);
            });
        };

        // Filtros por RUTA (por defecto todos desactivados -> sin filtrado)
        const routeFilters = {
            'LV-ok': false,
            'AC': false,
            'x lavar': false,
            'x bloq': false,
            'NORMAL': false
        };

        function onRouteFilterChange(key, checked) {
            if (routeFilters.hasOwnProperty(key)) routeFilters[key] = !!checked;
            // Si estamos en Corte y en el sub-tab X PROG, re-renderizar para aplicar filtros
            try { if (document.getElementById('view-corte').classList.contains('active') && currentCorteFilter === 'X PROG') renderCorte(); } catch(e){}
        }

        // Determina la clave simple de RUTA para una fila (debe coincidir con las keys de routeFilters)
        function getRouteKeyForRow(row) {
            const rutaVal = getVal(row, "RUTA TELA") || getVal(row, "RUTA") || "";
            const rutaKey = String(rutaVal || "").toUpperCase().trim();
            if (rutaKey.indexOf('NORMAL') !== -1) return 'NORMAL';
            if (rutaKey === 'ACABADA') return 'AC';
            if (rutaKey === 'LAVADA') {
                const estadoBloqRaw = getVal(row, "estado_bloqueo");
                const estadoBloq = (!estadoBloqRaw || estadoBloqRaw === "") ? "X PROG" : String(estadoBloqRaw).toUpperCase().trim();
                const estadoLavRaw = getVal(row, "estado_lavada");
                const estadoLav = (!estadoLavRaw || estadoLavRaw === "") ? "" : String(estadoLavRaw).toUpperCase().trim();

                if (estadoBloq.includes('PROG')) return 'x bloq';
                if (estadoBloq === 'OK' && (estadoLav === '' || estadoLav === 'EN LAV')) return 'x lavar';
                if (estadoLav === 'OK') return 'LV-ok';
                return 'LV-ok';
            }
            return String(rutaVal || '').trim();
        }

        document.addEventListener('DOMContentLoaded', initApp);

        function initApp() {
            const script = document.createElement('script');
            script.src = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=responseHandler:loadDataCallback`;
            script.onerror = () => showError("Error de conexión con Google Sheets.");
            document.body.appendChild(script);
            
            // Cargar equipos de corte en segundo plano
            cargarEquiposCorteBackground();
            // Configurar menú contextual del encabezado de Bloqueo
            try { setupBloqueoHeaderFilterMenu(); } catch(e) { console.error('setupBloqueoHeaderFilterMenu error', e); }
        }

        window.loadDataCallback = function(jsonResponse) {
            try {
                if (!jsonResponse || !jsonResponse.table) throw new Error("Datos inválidos.");
                
                let headerRowIndex = -1;
                const rowsRaw = jsonResponse.table.rows.map(r => r.c.map(cell => (cell && cell.v !== null) ? cell.v : ""));
                
                const gvizHeaders = jsonResponse.table.cols.map(col => col.label || col.id);
                
                // DEBUG: Ver los headers que vienen del gviz
                console.log('=== DEBUG GVIZ DATA ===');
                console.log('gvizHeaders:', gvizHeaders);
                console.log('Total columnas:', gvizHeaders.length);
                console.log('Columna 20 (n.transfxpda):', gvizHeaders[20]);
                
                // DEBUG: Ver primera fila de ATHLETA
                rowsRaw.forEach((row, idx) => {
                    if (row[3] && row[3].toString().toUpperCase().includes('ATHLETA')) {
                        console.log('ATHLETA Fila', idx, '| Col 20 (n.transfxpda):', row[20]);
                    }
                });
                console.log('========================');
                
                if (gvizHeaders.includes("OP TELA")) {
                    rawData = [gvizHeaders, ...rowsRaw];
                } else {
                    for(let i=0; i<rowsRaw.length; i++) {
                        if (rowsRaw[i].includes("OP TELA")) {
                            headerRowIndex = i;
                            break;
                        }
                    }
                    if (headerRowIndex !== -1) {
                        rawData = rowsRaw.slice(headerRowIndex);
                    } else {
                        rawData = [gvizHeaders, ...rowsRaw];
                    }
                }
                
                // Limpieza de nombres de cabecera (trim)
                if (rawData.length > 0) {
                    rawData[0] = rawData[0].map(h => h ? h.toString().trim() : "");
                }

                mapColumns();
                renderAllViews();
                // EQ_Corte button removed; no DOM update needed here.
                document.getElementById('loader').style.display = 'none';
                // Forzar un re-render breve después de ocultar el loader
                try { setTimeout(function(){ try { renderArtes(); } catch(e) {} }, 200); } catch(e) {}
            } catch (error) {
                console.error(error);
                showError("Error procesando datos: " + error.message);
            }
        };

        function showError(msg) {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('error-screen').style.display = 'flex';
            document.getElementById('error-details').innerText = msg;
        }

        // Búsqueda de columnas insensible a mayúsculas/minúsculas
        function getColIndex(name) {
            if (!rawData || rawData.length === 0) return -1;
            const headers = rawData[0];
            const target = name.toLowerCase().trim();
            return headers.findIndex(h => h.toLowerCase().trim() === target);
        }

        function mapColumns() {
            if (!rawData || rawData.length === 0) return;
            // Reconstruimos colMap usando búsqueda flexible
            colMap = {};
            const knownColumns = [
                "F. DESPACHO", "F.ING.COST", "CLIENTE", "OP TELA", "PARTIDA", 
                "OP", "CORTE", "COLOR", "KG GIRADOS", "PDS GIRADAS", "ARTÍCULO", 
                "NRO. MOLDE", "TIPO CERTIFICADO", "estado_bloqueo", "estado_rib", 
                "estado_lavada", "RUTA TELA", "ESTILO", "PRENDA", "F. GIRADO", "RIB",
                /* Posibles columnas adicionales para Corte */
                "EQUIPO CORTE", "EQUIPO_CORTE", "EQUIPO_CORTE", "equipo_corte",
                /* Nuevo nombre solicitado: STATUS_CORTE. Mantener variantes antiguas por compatibilidad */
                "STATUS_CORTE", "STATUS", "status", "ESTADO CORTE", "ESTADO_CORTE", "estado_corte",
                "ESTADO BLOQUES", "ESTADO_BLOQUES", "ESTADO_BLOQUES", "estado_bloques",
                "ESTADO COLL TAP", "ESTADO_COLL_TAP", "ESTADO_COLL_TAP", "estado_coll_tap",
                /* Columnas para Transfer */
                    "n.transfxpda", "N.TRANSFXPDA", "estado_transfer", "ESTADO_TRANSFER",
                    /* Columnas nuevas para Artes asignar */
                        "n.BDxpda", "n.BDxpda", "n.ESTAMPxpda", "n.ESTAMPxpda",
                    /* Estado de artes */
                        "estado_bordado", "ESTADO_BORDADO", "estado_estampado", "ESTADO_ESTAMPADO"
                , "tipo-transfer", "TIPO-TRANSFER", "tipo_transfer"
            ];
            
            knownColumns.forEach(col => {
                const idx = getColIndex(col);
                if (idx !== -1) colMap[col] = idx;
            });
        }

        function renderAllViews() {
            renderBloqueo();
            renderLavado();
            renderCorte();
            renderCorteBloques();
            renderEnumerado();
            renderTransfer();
            // Inicializar vistas y badges de Artes (Bordado/Estampado/Asignar)
            try { renderArtes(); } catch(e) {}
            try { if (typeof updateArtesBadges === 'function') updateArtesBadges(); } catch(e) {}
            renderHabilitado();
            updateCounters();
        }

        // Calcula y actualiza los badges (subtabs y padre) para Bordado y Estampado
        window.updateArtesBadges = function() {
            if (!rawData || rawData.length <= 1) return;
            let b_pdsX = 0, b_pdsProg = 0;
            let e_pdsX = 0, e_pdsProg = 0;
            const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');

            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                let ev = '';
                try {
                    if (idxEv !== -1 && row && row[idxEv] !== undefined) ev = row[idxEv];
                    else ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO ENUMERADO') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || ''; }
                const evNorm = (ev || '').toString().toUpperCase().trim();
                if (!(evNorm === 'OK PAQUETEO' || evNorm === 'OK ENM' || evNorm === 'OK S/ENM')) continue;

                // Bordado
                try {
                    const rawNbd = getVal(row, 'n.BDxpda') || getVal(row, 'N.BDXPDA') || getVal(row, 'n.BDxpda ') || '';
                    const nbdNorm = (rawNbd || '').toString().toUpperCase().trim();
                    if (nbdNorm.indexOf('NO LLEVA') === -1) {
                        if (nbdNorm === '' || ['1','2','3','4'].indexOf(nbdNorm) !== -1) {
                            let rawEstadoB = getVal(row, 'estado_bordado') || '';
                            let estadoBNorm = (rawEstadoB || '').toString().trim();
                            if (estadoBNorm === '') estadoBNorm = 'X PROG';
                            const pdsVal = parseFloat(getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || 0) || 0;
                            if (estadoBNorm.toUpperCase().indexOf('PROG') !== -1 && estadoBNorm.toUpperCase() !== 'X PROG') b_pdsProg += pdsVal;
                            else b_pdsX += pdsVal;
                        }
                    }
                } catch(e) {}

                // Estampado
                try {
                    const rawNest = getVal(row, 'n.ESTAMPxpda') || getVal(row, 'N.ESTAMPXPDA') || getVal(row, 'n.ESTAMP xpda') || '';
                    const nestNorm = (rawNest || '').toString().toUpperCase().trim();
                    if (nestNorm.indexOf('NO LLEVA') === -1) {
                        if (nestNorm === '' || ['1','2','3','4'].indexOf(nestNorm) !== -1) {
                            let rawEstadoE = getVal(row, 'estado_estampado') || '';
                            let estadoENorm = (rawEstadoE || '').toString().trim();
                            if (estadoENorm === '') estadoENorm = 'X PROG';
                            const pdsVal2 = parseFloat(getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || 0) || 0;
                            if (estadoENorm.toUpperCase().indexOf('PROG') !== -1 && estadoENorm.toUpperCase() !== 'X PROG') e_pdsProg += pdsVal2;
                            else e_pdsX += pdsVal2;
                        }
                    }
                } catch(e) {}
            }

            try { document.getElementById('artes-bordado-xprog-count').innerText = `[${formatThousands(b_pdsX||0,0)}pds]`; } catch(e){}
            try { document.getElementById('artes-bordado-prog-count').innerText = `[${formatThousands(b_pdsProg||0,0)}pds]`; } catch(e){}
            try { document.getElementById('artes-pds-bordado').innerText = `[${formatThousands((b_pdsX||0)+(b_pdsProg||0),0)}pds]`; } catch(e){}

            try { document.getElementById('artes-estampado-xprog-count').innerText = `[${formatThousands(e_pdsX||0,0)}pds]`; } catch(e){}
            try { document.getElementById('artes-estampado-prog-count').innerText = `[${formatThousands(e_pdsProg||0,0)}pds]`; } catch(e){}
            try { document.getElementById('artes-pds-estampado').innerText = `[${formatThousands((e_pdsX||0)+(e_pdsProg||0),0)}pds]`; } catch(e){}
        };
        
        function updateCounters() {
            let b_kgX = 0, b_pdsX = 0; 
            let b_kgP = 0, b_pdsP = 0; 
            let l_kgEnLav = 0, l_pdsEnLav = 0; 
            // Corte sub-tabs pds counters
            let corte_pds = {
                'X PROG': 0,
                'PROG 1T': 0,
                'PROG 2T': 0,
                'PROG 3T': 0
            };
            let corte_bloques_count = 0;
            
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const ruta = row[colMap["RUTA TELA"]];

                const kgVal = parseFloat(row[colMap["KG GIRADOS"]]) || 0;
                const pdsVal = parseFloat(row[colMap["PDS GIRADAS"]]) || 0;

                // Contadores de Bloqueo: solo se cuentan para filas cuya ruta sea LAVADA
                if (ruta === "LAVADA") {
                    const estBloq = row[colMap["estado_bloqueo"]] || "X PROG";
                    const estBloqNorm = (estBloq === "" || estBloq === undefined) ? "X PROG" : estBloq;

                    if (estBloqNorm === "X PROG") { b_kgX += kgVal; b_pdsX += pdsVal; }
                    else if (estBloqNorm === "PROG") { b_kgP += kgVal; b_pdsP += pdsVal; }
                }

                // Contador de Lavandería: incluir todas las filas cuyo estado_bloqueo sea OK,
                // independientemente de la columna RUTA TELA
                const estBloqAll = row[colMap["estado_bloqueo"]];
                const estBloqAllNorm = (!estBloqAll || estBloqAll === "") ? "X PROG" : estBloqAll;
                if (estBloqAllNorm === "OK") {
                    const estLav = row[colMap["estado_lavada"]];
                    const estLavNorm = (!estLav || estLav === "" || estLav === "EN LAV") ? "EN LAV" : estLav;
                    if (estLavNorm === "EN LAV") { l_kgEnLav += kgVal; l_pdsEnLav += pdsVal; }
                }

                // Contadores para sub-tabs de Corte: tomar STATUS / estado_corte (normalizar vacíos a 'X PROG')
                    const estadoCorteRaw = row[colMap["STATUS_CORTE"]] || row[colMap["STATUS"]] || row[colMap["status"]] || row[colMap["estado_corte"]] || row[colMap["ESTADO CORTE"]] || row[colMap["ESTADO_CORTE"]];
                    const estadoCorteNorm = (!estadoCorteRaw || estadoCorteRaw === "") ? 'X PROG' : String(estadoCorteRaw);
                    const isCorteOk = String(estadoCorteRaw).toUpperCase() === 'OK';
                    if (corte_pds.hasOwnProperty(estadoCorteNorm)) {
                        corte_pds[estadoCorteNorm] += pdsVal;
                    }
                    // contador específico para Corte Bloques: filas cuyo estado_bloques == 'OK CORTE'
                    try {
                        const estadoBloquesRaw = row[colMap["ESTADO BLOQUES"]] || row[colMap["ESTADO_BLOQUES"]] || row[colMap["estado_bloques"]] || '';
                        const estadoBloquesNorm = (estadoBloquesRaw || '').toString().toUpperCase().trim();
                        if (estadoBloquesNorm === 'OK CORTE') {
                            corte_bloques_count = (corte_bloques_count || 0) + 1;
                        }
                    } catch (e) { }
            }
            
            // Formatea números en miles para las prendas (pds)
            document.getElementById('kg-xprog').innerText = `[${b_kgX.toFixed(1)}kg - ${formatThousands(b_pdsX, 0)}pds]`;
            document.getElementById('kg-prog').innerText = `[${b_kgP.toFixed(1)}kg - ${formatThousands(b_pdsP, 0)}pds]`;
            const lblEnLav = document.getElementById('kg-enlav');
            if(lblEnLav) lblEnLav.innerText = `[${l_kgEnLav.toFixed(1)}kg - ${formatThousands(l_pdsEnLav, 0)}pds]`;

            // Actualizar badges de Corte
            const elX = document.getElementById('corte-pds-xprog');
            if (elX) elX.innerText = `[${formatThousands(corte_pds['X PROG'],0)}pds]`;
            const el1 = document.getElementById('corte-pds-1t');
            if (el1) el1.innerText = `[${formatThousands(corte_pds['PROG 1T'],0)}pds]`;
            const el2 = document.getElementById('corte-pds-2t');
            if (el2) el2.innerText = `[${formatThousands(corte_pds['PROG 2T'],0)}pds]`;
            const el3 = document.getElementById('corte-pds-3t');
            if (el3) el3.innerText = `[${formatThousands(corte_pds['PROG 3T'],0)}pds]`;

            // Contador para Transfer: sumar pds según estado_transfer
            let transfer_pds = {
                'X PROG': 0,
                'PROG': 0
            };
            let transferCount = 0;
            
            // Contador para Habilitado: filas con estado_enumerado = 'OK ENM' o 'OK S/ENM'
            let habilitadoCount = 0;
            // Mostrar contador para Corte Bloques (PROG 1T)
            try {
                const elCb = document.getElementById('count-corte-bloques');
                if (elCb) elCb.innerText = (typeof corte_bloques_count !== 'undefined') ? corte_bloques_count : 0;
            } catch (e) {}
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const ev = (row && (row[ findHeaderIndexCaseInsensitive('estado_enumerado') ])) || '';
                const evNorm = (ev || '').toString().toUpperCase().trim();

                // Contar Habilitado y Transfer: ambos usan el mismo criterio base
                if (evNorm === 'OK ENM' || evNorm === 'OK S/ENM' || evNorm === 'OK PAQUETEO') {
                    habilitadoCount++;

                    // Si n.transfxpda indica NO LLEVA no considerar la fila en el contador/badges de Transfer
                    const rawNTrans = getVal(row, 'n.transfxpda');
                    let nTransfValCheck = '';
                    if (rawNTrans !== undefined && rawNTrans !== null && rawNTrans.toString().trim() !== '') {
                        nTransfValCheck = rawNTrans.toString();
                    } else {
                        const clienteChk = (getVal(row, 'CLIENTE') || '').toString().trim();
                        const estiloChk = (getVal(row, 'ESTILO') || '').toString().trim();
                        const avgChk = avgTransfByClienteEstilo(clienteChk, estiloChk);
                        nTransfValCheck = (avgChk !== null) ? avgChk : '';
                    }
                    nTransfValCheck = nTransfValCheck.toUpperCase().trim();
                    if (nTransfValCheck === 'NO LLEVA') {
                        // skip counting for Transfer
                        continue;
                    }

                    transferCount++;

                    // Sumar pds para Transfer según estado_transfer
                    const estadoTransfer = (row && (row[ findHeaderIndexCaseInsensitive('estado_transfer') ])) || 'X PROG';
                    const estadoTransferNorm = (!estadoTransfer || estadoTransfer === '') ? 'X PROG' : estadoTransfer;
                    if (transfer_pds.hasOwnProperty(estadoTransferNorm)) {
                        const pds = parseFloat(row[colMap["PDS GIRADAS"]]) || 0;
                        transfer_pds[estadoTransferNorm] += pds;
                    }
                }
            }
            const elH = document.getElementById('count-habilitado');
            if (elH) elH.innerText = habilitadoCount;
            
            // Actualizar contador y badges de Transfer
            const elT = document.getElementById('count-transfer');
            if (elT) elT.innerText = transferCount;
            const elTX = document.getElementById('transfer-pds-xprog');
            if (elTX) elTX.innerText = `[${formatThousands(transfer_pds['X PROG'],0)}pds]`;
            const elTP = document.getElementById('transfer-pds-prog');
            if (elTP) elTP.innerText = `[${formatThousands(transfer_pds['PROG'],0)}pds]`;
        }

        // helper para buscar índice de encabezado de forma case-insensitive y sin símbolos
        function findHeaderIndexCaseInsensitive(name) {
            if (!rawData || rawData.length === 0) return -1;
            const headers = rawData[0];
            const norm = s => String(s || '').toLowerCase().replace(/[^a-z0-9]/g, '');
            const target = norm(name);
            for (let i = 0; i < headers.length; i++) {
                if (norm(headers[i]) === target) return i;
            }
                    return -1;
                }

                // Calcula promedio de n.transfxpda para un par CLIENTE+ESTILO
                function avgTransfByClienteEstilo(cliente, estilo) {
                    if (!cliente && !estilo) return null;
                    const vals = [];
                    let hasNoLleva = false;
                    
                    // Buscar índice de n.transfxpda de forma flexible
                    let idxTransf = findHeaderIndexCaseInsensitive('n.transfxpda');
                    if (idxTransf === -1) idxTransf = colMap['n.transfxpda'];
                    if (idxTransf === -1 || idxTransf === undefined) idxTransf = getColIndex('n.transfxpda');
                    
                    for (let i = 1; i < rawData.length; i++) {
                        const r = rawData[i];
                        const c = normalizeClientForTransfer(getVal(r, 'CLIENTE') || '');
                        const e = (getVal(r, 'ESTILO') || '').toString().trim();
                        if (c === cliente && e === estilo) {
                            // Obtener valor usando el índice encontrado
                            let v = (idxTransf !== -1 && idxTransf !== undefined) ? r[idxTransf] : getVal(r, 'n.transfxpda');
                            if (v === undefined || v === null) continue;
                            const s = v.toString().trim();
                            const sUpper = s.toUpperCase();
                            // Detectar "NO LLEVA" con variaciones (puede tener espacios extra, etc)
                            if (sUpper === 'NO LLEVA' || sUpper.includes('NO LLEVA')) { 
                                hasNoLleva = true; 
                                continue; 
                            }
                            if (s === '' || sUpper === 'LLEVA?' || sUpper === 'LLEVA') continue;
                            const n = parseFloat(s);
                            if (!isNaN(n)) vals.push(n);
                        }
                    }
                    // Prioridad: si hay "NO LLEVA", retornarlo primero (antes que valores numéricos)
                    // Esto porque "NO LLEVA" indica que el estilo no necesita transfer
                    if (hasNoLleva && vals.length === 0) return 'NO LLEVA';
                    if (vals.length > 0) {
                        const sum = vals.reduce((a,b) => a + b, 0);
                        const avg = sum / vals.length;
                        return Math.round(avg).toString();
                    }
                    if (hasNoLleva) return 'NO LLEVA';
                    return null;
                }

        // --- LÓGICA DE ORDENAMIENTO ---
        function sortBloqueoData(indices) {
            return indices.sort((a, b) => {
                const rowA = rawData[a];
                const rowB = rawData[b];
                
                // --- SIN LIMPIEZA AGRESIVA ---
                const opTelaA = String(rowA[colMap["OP TELA"]] || "").trim();
                const partidaA = String(rowA[colMap["PARTIDA"]] || "").trim();
                const opPtdaA = (opTelaA + "-" + partidaA).toLowerCase();

                const opTelaB = String(rowB[colMap["OP TELA"]] || "").trim();
                const partidaB = String(rowB[colMap["PARTIDA"]] || "").trim();
                const opPtdaB = (opTelaB + "-" + partidaB).toLowerCase();
                
                const cmp = opPtdaA.localeCompare(opPtdaB, undefined, { numeric: true, sensitivity: 'base' });
                if (cmp !== 0) return cmp;
                
                const dateA = rowA[colMap["F. DESPACHO"]] || 0;
                const dateB = rowB[colMap["F. DESPACHO"]] || 0;
                return dateB - dateA;
            });
        }

        function sortCorteData(indices) {
            return indices.sort((a, b) => {
                const rowA = rawData[a];
                const rowB = rawData[b];
                
                // Ordenar primero por OP-PTDA para agrupar filas con mismo valor
                const opTelaA = String(rowA[colMap["OP TELA"]] || "").trim();
                const partidaA = String(rowA[colMap["PARTIDA"]] || "").trim();
                const opPtdaA = (opTelaA + "-" + partidaA).toLowerCase();

                const opTelaB = String(rowB[colMap["OP TELA"]] || "").trim();
                const partidaB = String(rowB[colMap["PARTIDA"]] || "").trim();
                const opPtdaB = (opTelaB + "-" + partidaB).toLowerCase();
                
                const cmpOpPtda = opPtdaA.localeCompare(opPtdaB, undefined, { numeric: true, sensitivity: 'base' });
                if (cmpOpPtda !== 0) return cmpOpPtda;
                
                // Si OP-PTDA es igual, ordenar por fecha de despacho
                const dateA = rowA[colMap["F. DESPACHO"]] || 0;
                const dateB = rowB[colMap["F. DESPACHO"]] || 0;
                return dateB - dateA;
            });
        }

        function renderBloqueo() {
            const tbody = document.getElementById('tbody-bloqueo');
            tbody.innerHTML = "";
            let count = 0;
            
            let validIndices = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const ruta = row[colMap["RUTA TELA"]];
                if (ruta !== "LAVADA") continue;

                const estadoBloq = row[colMap["estado_bloqueo"]] || "X PROG";
                const estadoBloqNorm = (estadoBloq === "" || estadoBloq === undefined) ? "X PROG" : estadoBloq;

                if (estadoBloqNorm === currentBloqueoFilter) {
                    // Si estamos en 'Por Programar' (X PROG), excluir filas cuyo CORTE (parte entera antes de '-')
                    // sea numérico y mayor o igual a 9000
                    try {
                        if (currentBloqueoFilter === 'X PROG') {
                            const corteRaw = String(row[colMap["CORTE"]] || '').trim();
                            const corteBase = parseInt((corteRaw.split('-')[0] || '').trim());
                            if (!isNaN(corteBase) && corteBase >= 9000) {
                                continue; // omitir esta fila en X PROG
                            }
                        }
                    } catch (e) { /* ignore parsing issues */ }
                    validIndices.push(i);
                }
            }

            validIndices = sortBloqueoData(validIndices);

            // Aplicar filtro de encabezado si existe
            try {
                if (bloqueoHeaderFilter && bloqueoHeaderFilter.field && bloqueoHeaderFilter.value !== undefined && bloqueoHeaderFilter.value !== null && String(bloqueoHeaderFilter.value).trim() !== '') {
                    const f = bloqueoHeaderFilter.field;
                    const v = String(bloqueoHeaderFilter.value).toUpperCase().trim();
                    validIndices = validIndices.filter(idx => {
                        const r = rawData[idx] || [];
                        try {
                            if (f === 'F. DESPACHO') {
                                const cell = formatValue(getVal(r, 'F. DESPACHO'), 'date') || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'F.ING.COST') {
                                const cell = formatValue(getVal(r, 'F.ING.COST'), 'date') || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'CLIENTE') {
                                const cell = normalizeClientName(getVal(r, 'CLIENTE')) || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'OP-PTDA') {
                                const opTela = String(getVal(r, 'OP TELA') || '').trim();
                                const partida = String(getVal(r, 'PARTIDA') || '').trim();
                                const cell = (opTela + '-' + partida) || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'OC') {
                                const op = String(getVal(r, 'OP') || '').trim();
                                const corte = String(getVal(r, 'CORTE') || '').trim();
                                const cell = (op + '-' + corte) || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                            if (f === 'COLOR') {
                                const cell = String(getVal(r, 'COLOR') || '') || '';
                                return String(cell).toUpperCase().indexOf(v) !== -1;
                            }
                        } catch (e) { return false; }
                        return false;
                    });
                }
            } catch (e) { console.error('Error applying bloqueoHeaderFilter', e); }

            let lastOpPtda = null;
            let currentGroup = 'a'; 

            validIndices.forEach(i => {
                count++;
                const row = rawData[i];
                
                // --- AGRUPAMIENTO SIN LIMPIEZA ---
                const opTela = String(row[colMap["OP TELA"]] || "").trim();
                const partida = String(row[colMap["PARTIDA"]] || "").trim();
                const currentOpPtda = opTela + "-" + partida;
                
                if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                    currentGroup = (currentGroup === 'a') ? 'b' : 'a';
                }
                lastOpPtda = currentOpPtda;

                const tr = createRow(row, i, "bloqueo", currentGroup);
                tbody.appendChild(tr);
            });
            
            document.getElementById('count-bloqueo').innerText = count;
        }

        // Configura menú contextual en el encabezado de la vista Bloqueo
        function setupBloqueoHeaderFilterMenu() {
            const view = document.getElementById('view-bloqueo');
            if (!view) return;
            const thead = view.querySelector('thead');
            if (!thead) return;

            // Crear contenedor de menú si no existe
            let menu = document.getElementById('bloq-header-filter-menu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'bloq-header-filter-menu';
                menu.style.position = 'absolute';
                menu.style.zIndex = 9999;
                menu.style.background = '#fff';
                menu.style.border = '1px solid #ccc';
                menu.style.padding = '6px';
                menu.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
                menu.style.display = 'none';
                document.body.appendChild(menu);
            }

            const fields = ['F. DESPACHO','F.ING.COST','CLIENTE','OP-PTDA','OC','COLOR'];

            const buildMenu = () => {
                menu.innerHTML = '';
                const title = document.createElement('div');
                title.style.fontWeight = '600';
                title.style.marginBottom = '6px';
                title.innerText = 'Filtrar por (Bloqueo)';
                menu.appendChild(title);

                // helper: obtener valores únicos de una columna (formateados para fechas)
                const getUniqueValues = (colName, formatAsDate) => {
                    const map = new Map(); // display -> timestamp
                    const mesesEs = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'];

                    const parseToTimestamp = (raw) => {
                        if (raw === undefined || raw === null || raw === '') return NaN;
                        // number (Excel serial)
                        if (typeof raw === 'number' && raw > 30000) {
                            const d = new Date(Math.round((raw - 25569) * 86400 * 1000));
                            return d.getTime();
                        }
                        if (typeof raw === 'string') {
                            const s = raw.trim();
                            // Date(yyyy,mm,dd)
                            const m = s.match(/Date\((\d+),(\d+),(\d+)\)/);
                            if (m) {
                                const y = parseInt(m[1],10);
                                const mo = parseInt(m[2],10);
                                const day = parseInt(m[3],10);
                                return new Date(y, mo, day).getTime();
                            }
                            // Formato dd/Mon/yy o dd/Mon/yyyy (Mon en español abreviado como Ene,Feb,...)
                            const m2 = s.match(/(\d{1,2})\/([A-Za-z]{3})\/(\d{2,4})/);
                            if (m2) {
                                const day = parseInt(m2[1],10);
                                const monAbbr = m2[2].slice(0,3);
                                const yearRaw = m2[3];
                                const monthIdx = mesesEs.findIndex(x => x.toLowerCase() === monAbbr.toLowerCase());
                                let year = parseInt(yearRaw,10);
                                if (yearRaw.length === 2) {
                                    year = 2000 + year;
                                }
                                if (monthIdx !== -1) return new Date(year, monthIdx, day).getTime();
                            }
                            // Try ISO parse
                            const tryIso = Date.parse(s);
                            if (!isNaN(tryIso)) return tryIso;
                        }
                        return NaN;
                    };

                    try {
                        for (let i = 1; i < rawData.length; i++) {
                            const row = rawData[i];
                            if (!row) continue;
                            const rawVal = getVal(row, colName);
                            const display = formatAsDate ? String(formatValue(rawVal, 'date')) : String(rawVal);
                            if (display === 'undefined' || display === 'null' || String(display).trim() === '') continue;
                            if (!map.has(display)) {
                                const ts = parseToTimestamp(rawVal);
                                map.set(display, isNaN(ts) ? null : ts);
                            }
                        }
                    } catch (e) { /* ignore */ }

                    // Convert map to array and sort by timestamp (nulls last), then by display
                    const arr = Array.from(map.entries()).map(([display, ts]) => ({ display, ts }));
                    arr.sort((a,b) => {
                        if (a.ts === null && b.ts === null) return a.display.localeCompare(b.display);
                        if (a.ts === null) return 1;
                        if (b.ts === null) return -1;
                        return a.ts - b.ts;
                    });
                    return arr.map(x => x.display);
                };

                fields.forEach(f => {
                    const btn = document.createElement('div');
                    btn.style.cursor = 'pointer';
                    btn.style.padding = '4px 6px';
                    btn.innerText = f;
                    btn.onclick = () => {
                        // Si es campo fecha, mostrar lista de fechas únicas en lugar de prompt
                        if (f === 'F. DESPACHO' || f === 'F.ING.COST') {
                            const colName = (f === 'F. DESPACHO') ? 'F. DESPACHO' : 'F.ING.COST';
                            const vals = getUniqueValues(colName, true);
                            // construir sub-lista
                            if (vals.length === 0) {
                                alert('No hay valores de fecha disponibles en la columna.');
                                hideMenu();
                                return;
                            }
                            menu.innerHTML = '';
                            const back = document.createElement('div');
                            back.style.cursor = 'pointer';
                            back.style.padding = '4px 6px';
                            back.style.fontWeight = '600';
                            back.innerText = '< Volver';
                            back.onclick = () => { buildMenu(); };
                            menu.appendChild(back);

                            const list = document.createElement('div');
                            list.style.maxHeight = '220px';
                            list.style.overflow = 'auto';
                            list.style.marginTop = '6px';
                            vals.forEach(v => {
                                const item = document.createElement('div');
                                item.style.cursor = 'pointer';
                                item.style.padding = '4px 6px';
                                item.innerText = v;
                                item.onclick = () => {
                                    bloqueoHeaderFilter = { field: f, value: v };
                                    renderBloqueo();
                                    hideMenu();
                                };
                                list.appendChild(item);
                            });
                            menu.appendChild(list);
                            return;
                        }

                        // campos no fecha: usar prompt simple
                        const val = prompt(`Valor para filtrar ${f}:`, '');
                        if (val !== null) {
                            bloqueoHeaderFilter = { field: f, value: val };
                            renderBloqueo();
                        }
                        hideMenu();
                    };
                    menu.appendChild(btn);
                });

                const clear = document.createElement('div');
                clear.style.cursor = 'pointer';
                clear.style.padding = '6px 4px';
                clear.style.borderTop = '1px solid #eee';
                clear.style.marginTop = '6px';
                clear.innerText = 'Limpiar filtro';
                clear.onclick = () => {
                    bloqueoHeaderFilter = null;
                    renderBloqueo();
                    hideMenu();
                };
                menu.appendChild(clear);
            };

            const hideMenu = () => { menu.style.display = 'none'; };

            buildMenu();

            // Mostrar menú al hacer click derecho en la fila de encabezado
            thead.addEventListener('contextmenu', function(e) {
                // Solo en sub-tab 'Por Programar'
                const btnX = document.getElementById('btn-xprog');
                const isXProgActive = btnX && btnX.classList.contains('active');
                if (!isXProgActive) return; // no mostrar menú si no está en Por Programar

                e.preventDefault();
                menu.style.left = (e.pageX + 2) + 'px';
                menu.style.top = (e.pageY + 2) + 'px';
                menu.style.display = 'block';
            });

            // Ocultar al click fuera
            document.addEventListener('click', function(e) {
                if (!menu) return;
                if (e.target && menu.contains(e.target)) return;
                hideMenu();
            });
        }

        function renderLavado() {
            const tbody = document.getElementById('tbody-lavado');
            tbody.innerHTML = "";
            let count = 0;
            // Recolectar índices válidos y ordenarlos por OP-PTDA (y fecha)
            let validIndices = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const estadoBloq = row[colMap["estado_bloqueo"]];
                const estadoBloqNorm = (!estadoBloq || estadoBloq === "") ? "X PROG" : estadoBloq;

                // Mostrar solo filas cuyo estado_bloqueo sea OK
                if (estadoBloqNorm !== 'OK') continue;

                const estadoLav = row[colMap["estado_lavada"]];
                const estadoLavNorm = (!estadoLav || estadoLav === "" ) ? "EN LAV" : estadoLav;
                if (estadoLavNorm !== currentLavadoFilter) continue;

                validIndices.push(i);
            }

            validIndices = sortBloqueoData(validIndices);

            // Agrupar por OP-PTDA alternando clases para sombreado
            let lastOpPtda = null;
            let currentGroup = 'a';

            validIndices.forEach(i => {
                count++;
                const row = rawData[i];
                const opTela = String(row[colMap["OP TELA"]] || "").trim();
                const partida = String(row[colMap["PARTIDA"]] || "").trim();
                const currentOpPtda = opTela + "-" + partida;

                if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                    currentGroup = (currentGroup === 'a') ? 'b' : 'a';
                }
                lastOpPtda = currentOpPtda;

                tbody.appendChild(createRow(row, i, "lavado", currentGroup));
            });
            document.getElementById('count-lavado').innerText = count;
        }

        function renderCorte() {
            const tbody = document.getElementById('tbody-corte');
            tbody.innerHTML = "";
            let count = 0;
            // Control de columnas finales (estado_bloques, estado_coll_tap)
            // - Si estamos en X PROG, ocultarlas.
            // - Si estamos en un sub-tab PROG (1T/2T/3T), mostrarlas y renombrarlas.
            const hideExtra = (currentCorteFilter === 'X PROG');
            const showAsProg = (currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG');
            const ths = document.querySelectorAll('#view-corte thead th');
            if (ths && ths.length >= 2) {
                // Últimas dos columnas de la tabla de Corte
                const thBloques = ths[ths.length - 2];
                const thCollTap = ths[ths.length - 1];
                thBloques.style.display = hideExtra ? 'none' : '';
                thCollTap.style.display = hideExtra ? 'none' : '';
                if (!hideExtra && showAsProg) {
                    thBloques.innerText = 'BLOQUES?';
                    thCollTap.innerText = 'COLL o TAP?';
                } else if (!hideExtra) {
                    thBloques.innerText = 'estado_bloques';
                    thCollTap.innerText = 'estado_coll_tap';
                }

                // Ajustar anchos de columnas OC y OP-PTDA cuando estamos en sub-tabs PROG
                // y ocultar columna EQUIPO_CORTE en PROG
                try {
                    let ocTh = null;
                    let opPtdaTh = null;
                    let equipoCorteTh = null;
                    ths.forEach(th => {
                        const txt = (th.textContent || '').toString().trim().toUpperCase();
                        if (txt === 'OC') ocTh = th;
                        if (txt === 'OP-PTDA' || txt === 'OP-PTDA') opPtdaTh = th;
                        if (txt === 'EQUIPO_CORTE') equipoCorteTh = th;
                    });

                    if (showAsProg) {
                        if (ocTh) ocTh.style.width = '120px';
                        if (opPtdaTh) opPtdaTh.style.width = '60px';
                        if (equipoCorteTh) equipoCorteTh.style.display = 'none';
                    } else {
                        // valores por defecto cuando no es PROG (X PROG u otras vistas)
                        if (ocTh) ocTh.style.width = '60px';
                        if (opPtdaTh) opPtdaTh.style.width = '80px';
                        if (equipoCorteTh) equipoCorteTh.style.display = '';
                    }
                } catch (e) { /* ignore */ }
            }

            // Recolectar índices válidos según filtro de Corte (excluir OK)
            let validIndices = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const estadoCorteVal = (row[colMap["STATUS_CORTE"]] || row[colMap["STATUS"]] || row[colMap["status"]] || row[colMap["estado_corte"]] || row[colMap["ESTADO CORTE"]] || row[colMap["ESTADO_CORTE"]]) || "";
                const isCorteOk = String(estadoCorteVal).toUpperCase() === 'OK';
                const estadoCorteNorm = (!estadoCorteVal || estadoCorteVal === '') ? 'X PROG' : String(estadoCorteVal);

                if (!isCorteOk && estadoCorteNorm === currentCorteFilter) {
                    // Si estamos en el sub-tab 'X PROG' y hay filtros por RUTA activos,
                    // aplicar filtrado: incluir la fila solo si su clave RUTA coincide
                    try {
                        if (currentCorteFilter === 'X PROG') {
                            const anyChecked = Object.values(routeFilters).some(v => v);
                            if (anyChecked) {
                                const routeKey = getRouteKeyForRow(row);
                                if (!routeFilters.hasOwnProperty(routeKey) || !routeFilters[routeKey]) {
                                    continue; // no coincide con filtros activos
                                }
                            }
                            // Además: excluir filas cuyo CORTE (parte base antes de '-')
                            // sea numérico y mayor o igual a 9000 cuando estamos en X PROG
                            try {
                                const corteRaw = String(row[colMap["CORTE"]] || '').trim();
                                const corteBase = parseInt((corteRaw.split('-')[0] || '').trim());
                                if (!isNaN(corteBase) && corteBase >= 9000) {
                                    continue; // omitir esta fila en X PROG
                                }
                            } catch(e) { /* ignore parsing issues */ }
                        }
                    } catch (e) { /* silent */ }

                    validIndices.push(i);
                }
            }

            // Para 'X PROG' en Corte, ordenar por OP-PTDA (consistentemente con bloqueo/lavado)
            if (currentCorteFilter === 'X PROG') {
                try { validIndices = sortBloqueoData(validIndices); } catch(e) { /* ignore */ }
            }

            // Si estamos en PROG 1T/2T/3T, agrupar por EQUIPO_CORTE
            const isProgSubtab = showAsProg && (currentCorteFilter === 'PROG 1T' || currentCorteFilter === 'PROG 2T' || currentCorteFilter === 'PROG 3T');
            
            if (isProgSubtab) {
                // Ordenar validIndices por equipo_corte (según orden EQ de equiposCorteData)
                // Antes de ordenar, detectar si alguna base de CORTE tiene tendidos creados
                // Use localStorage-backed set of created bases to prioritize them
                const corteIdxForMap = colMap["CORTE"];
                const baseHasInserted = {};
                try {
                    validIndices.forEach(idx => {
                        const val = String(rawData[idx][corteIdxForMap] || '').trim();
                        const base = (/\d{2}$/.test(val.slice(-2)) ? val.slice(0, -2) : val) || '';
                        if (base) {
                            baseHasInserted[base] = baseHasInserted[base] || (window._createdTendidoBases && window._createdTendidoBases.has(base));
                        }
                    });

                    // Reordenar globalmente poniendo primero los índices cuyas bases están registradas
                    // en la lista de bases creadas. Esto hace que esas OC/bases aparezcan en primer lugar
                    // en todo el tbody, antes de agrupar por equipo.
                    const top = [];
                    const rest = [];
                    validIndices.forEach(idx => {
                        try {
                            const val = String(rawData[idx][corteIdxForMap] || '').trim();
                            const base = (/\d{2}$/.test(val.slice(-2)) ? val.slice(0, -2) : val) || '';
                            if (base && window._createdTendidoBases && window._createdTendidoBases.has(base)) top.push(idx);
                            else rest.push(idx);
                        } catch (e) { rest.push(idx); }
                    });
                    validIndices = top.concat(rest);
                } catch (e) { /* ignore */ }

                validIndices.sort((a, b) => {
                    const equipoA = String(rawData[a][colMap["EQUIPO CORTE"]] || rawData[a][colMap["EQUIPO_CORTE"]] || rawData[a][colMap["equipo_corte"]] || "").trim();
                    const equipoB = String(rawData[b][colMap["EQUIPO CORTE"]] || rawData[b][colMap["EQUIPO_CORTE"]] || rawData[b][colMap["equipo_corte"]] || "").trim();

                    // Encontrar el orden EQ de cada equipo
                    const findEqOrder = (nombre) => {
                        const equipo = equiposCorteData.find(eq => eq.nombre === nombre);
                        return equipo ? (parseInt(equipo.eq) || 999) : 999;
                    };

                    const orderA = findEqOrder(equipoA);
                    const orderB = findEqOrder(equipoB);
                    if (orderA !== orderB) return orderA - orderB;

                    // Si pertenecen al mismo equipo, ordenar por base de CORTE y sufijo (tendido)
                    const corteIdx = colMap["CORTE"];
                    const rawA = String(rawData[a][corteIdx] || '').trim();
                    const rawB = String(rawData[b][corteIdx] || '').trim();

                    const parseCorte = (s) => {
                        if (!s) return { base: '', suf: 0 };
                        const last2 = s.slice(-2);
                        if (/^\d{2}$/.test(last2)) {
                            return { base: s.slice(0, -2), suf: parseInt(last2, 10) };
                        }
                        return { base: s, suf: 0 };
                    };

                    const pa = parseCorte(rawA);
                    const pb = parseCorte(rawB);

                    // Priorizar bases que tengan tendidos creados: aparecerán primero dentro del mismo equipo
                    const baseA = pa.base || '';
                    const baseB = pb.base || '';
                    const aHas = baseHasInserted[baseA] || false;
                    const bHas = baseHasInserted[baseB] || false;
                    if (aHas !== bHas) return aHas ? -1 : 1;

                    // Comparar base (numérico si posible)
                    const numA = parseInt(pa.base.replace(/[^0-9]/g, ''), 10);
                    const numB = parseInt(pb.base.replace(/[^0-9]/g, ''), 10);
                    if (!isNaN(numA) && !isNaN(numB)) {
                        if (numA !== numB) return numA - numB;
                    } else {
                        const cmp = (pa.base || '').localeCompare(pb.base || '');
                        if (cmp !== 0) return cmp;
                    }

                    // Finalmente ordenar por sufijo (tendido)
                    return (pa.suf || 0) - (pb.suf || 0);
                });
                
                // Agrupar por equipo y renderizar con headers
                let lastEquipo = null;
                let lastOpPtda = null;
                let currentGroup = 'a';
                
                validIndices.forEach(i => {
                    const row = rawData[i];
                    const equipoCorte = String(row[colMap["EQUIPO CORTE"]] || row[colMap["EQUIPO_CORTE"]] || row[colMap["equipo_corte"]] || "").trim();
                    
                    // Si cambia el equipo, insertar fila de encabezado
                    if (equipoCorte !== lastEquipo) {
                        const headerRow = document.createElement('tr');
                        headerRow.style.backgroundColor = 'rgba(37, 99, 235, 0.12)';
                        headerRow.style.color = '#1e40af';
                        headerRow.style.fontWeight = '700';
                        headerRow.style.fontSize = '13px';
                        
                        // Calcular colspan: en PROG son 15 columnas (sin equipo_corte ni las 2 finales que ya están)
                        const colspan = '15';
                        // Calcular suma de PDS para este equipo dentro del conjunto filtrado (validIndices)
                        let pdsEquipo = 0;
                        try {
                            pdsEquipo = validIndices.reduce((acc, idx2) => {
                                try {
                                    const r = rawData[idx2];
                                    const eq = String(r[colMap["EQUIPO CORTE"]] || r[colMap["EQUIPO_CORTE"]] || r[colMap["equipo_corte"]] || "").trim();
                                    if (eq === equipoCorte) {
                                        const pv = parseFloat(getVal(r, "PDS GIRADAS") || getVal(r, "PDS") || 0) || 0;
                                        return acc + pv;
                                    }
                                } catch(e) { /* ignore row parse errors */ }
                                return acc;
                            }, 0);
                        } catch (e) { pdsEquipo = 0; }

                        headerRow.innerHTML = `<td colspan="${colspan}" style="padding: 8px 12px; text-align: left;">
                            <i class="ph ph-package" style="margin-right: 8px;"></i>${equipoCorte || 'SIN EQUIPO ASIGNADO'} [${formatThousands(pdsEquipo,0)}pds]
                        </td>`;
                        tbody.appendChild(headerRow);
                        
                        lastEquipo = equipoCorte;
                        lastOpPtda = null; // Reiniciar al cambiar de equipo
                    }
                    
                    // Pintar por OP-PTDA dentro de cada equipo
                    const opTela = String(row[colMap["OP TELA"]] || "").trim();
                    const partida = String(row[colMap["PARTIDA"]] || "").trim();
                    const currentOpPtda = `${opTela}-${partida}`;
                    
                    if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                        currentGroup = (currentGroup === 'a') ? 'b' : 'a';
                    }
                    lastOpPtda = currentOpPtda;
                    
                    count++;
                    const tr = createRow(row, i, "corte", currentGroup);
                    // En sub-tabs PROG, eliminar celda de equipo_corte (posición 12) y las 2 últimas
                    const tds = tr.querySelectorAll('td');
                    if (tds && tds.length >= 13) {
                        // Eliminar celda equipo_corte (índice 12, antes de STATUS_CORTE)
                        tds[12].remove();
                    }
                    tbody.appendChild(tr);
                });
            } else {
                // Comportamiento original para X PROG: agrupar por OP-PTDA
                validIndices = sortCorteData(validIndices);
                let lastOpPtda = null;
                let currentGroup = 'a';

                validIndices.forEach(i => {
                    count++;
                    const row = rawData[i];
                    const opTela = String(row[colMap["OP TELA"]] || "").trim();
                    const partida = String(row[colMap["PARTIDA"]] || "").trim();
                    const currentOpPtda = `${opTela}-${partida}`;
                    
                    if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                        currentGroup = (currentGroup === 'a') ? 'b' : 'a';
                    }
                    lastOpPtda = currentOpPtda;

                    const tr = createRow(row, i, "corte", currentGroup);
                    if (hideExtra) {
                        for (let k = 0; k < 2; k++) {
                            const tds = tr.querySelectorAll('td');
                            if (tds && tds.length) tds[tds.length - 1].remove();
                        }
                    }
                    tbody.appendChild(tr);
                });
            }

            document.getElementById('count-corte').innerText = count;
        }

        function renderEnumerado() {
            const tbody = document.getElementById('tbody-enumerado');
            if (!tbody) return;
            tbody.innerHTML = "";
            let count = 0;
            let pds_total = 0;
            // Ocultar las columnas OP-PTDA y ART. en el encabezado de Enumerado
            try {
                const thsEnum = document.querySelectorAll('#view-enumerado thead th');
                thsEnum.forEach(th => {
                    const txt = (th.textContent || '').toString().trim().toUpperCase();
                    if (txt === 'OP-PTDA' || txt === 'ART.' || txt === 'ART') th.style.display = 'none';
                    // Ocultar columna COLL/TAP en la vista Enumerado
                    if (txt.indexOf('COLL') !== -1 || txt.indexOf('COLL O TAP') !== -1 || txt.indexOf('ESTADO_COLL_TAP') !== -1 || txt.indexOf('ESTADO COLL TAP') !== -1) th.style.display = 'none';
                });
            } catch (e) {}

            // Enumerado: coleccionar filas cuyo estado_corte = 'OK' y estado_enumerado != 'OK ENM'/'OK S/ENM'
            const items = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const estadoCorteVal = (row[colMap["STATUS_CORTE"]] || row[colMap["STATUS"]] || row[colMap["status"]] || row[colMap["estado_corte"]] || row[colMap["ESTADO CORTE"]] || row[colMap["ESTADO_CORTE"]]) || "";
                const isCorteOk = String(estadoCorteVal).toUpperCase() === 'OK';

                if (!isCorteOk) continue;

                // Intentar localizar la columna estado_enumerado de forma robusta
                let ev = '';
                try {
                    const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
                    if (idxEv !== -1 && rawData[i] && rawData[i][idxEv] !== undefined) ev = rawData[i][idxEv];
                    else ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO_ENumerado') || getVal(row, 'ESTADO ENUMERADO') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO_ENumerado') || getVal(row, 'ESTADO ENUMERADO') || ''; }

                const evNorm = (ev || '').toString().toUpperCase().trim();
                // Excluir filas ya enumeradas
                if (evNorm === 'OK ENM' || evNorm === 'OK S/ENM' || evNorm === 'OK PAQUETEO') continue;

                // sumar prendas (PDS) para el badge
                const pdsVal = parseFloat(getVal(row, "PDS GIRADAS")) || 0;
                pds_total += pdsVal;

                // Obtener valor OC para ordenar y agrupar
                let ocVal = '';
                try {
                    const idxOc = findHeaderIndexCaseInsensitive('OC');
                    if (idxOc !== -1 && rawData[i] && rawData[i][idxOc] !== undefined) ocVal = String(rawData[i][idxOc]);
                    else ocVal = (getVal(row, 'OC') || '').toString();
                } catch (e) { ocVal = (getVal(row, 'OC') || '').toString(); }

                items.push({ row, i, oc: (ocVal || '').toString().trim() });
                count++;
            }

            // Ordenar por OC (comparación natural numérica si aplica)
            items.sort((a, b) => (a.oc || '').localeCompare(b.oc || '', undefined, { numeric: true, sensitivity: 'base' }));

            // Pintar filas alternando por grupos de OC (cada vez que cambia OC se invierte color)
            let lastOc = null;
            let groupToggle = false;
            items.forEach(item => {
                const tr = createRow(item.row, item.i, "corte");
                // Quitar el botón de tendido ('+') en la columna OC para la vista Enumerado
                try {
                    const tendidoBtn = tr.querySelector('button.btn-tendido');
                    if (tendidoBtn) tendidoBtn.remove();
                } catch (e) {}
                try {
                    const tds = tr.querySelectorAll('td');
                    // Eliminar ART primero (índice 9) luego OP-PTDA (índice 6)
                    if (tds.length > 9) tds[9].remove();
                    if (tds.length > 6) tds[6].remove();
                } catch (e) {}

                const ocNow = (item.oc || '').toString();
                if (ocNow !== lastOc) {
                    groupToggle = !groupToggle;
                    lastOc = ocNow;
                }
                tr.classList.add(groupToggle ? 'group-a' : 'group-b');
                tbody.appendChild(tr);
            });
            document.getElementById('count-enumerado').innerText = count;
            try {
                const el = document.getElementById('enumerado-pds-por');
                if (el) el.innerText = `[${formatThousands(pds_total,0)}pds]`;
            } catch (e) {}
        }

        function renderTransfer() {
            const tbody = document.getElementById('tbody-transfer');
            if (!tbody) return;
            tbody.innerHTML = "";
            let count = 0;

            // Transfer muestra filas cuyo estado_enumerado = 'OK ENM' o 'OK S/ENM'
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                
                // Obtener estado_enumerado
                let ev = '';
                try {
                    const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
                    if (idxEv !== -1 && rawData[i] && rawData[i][idxEv] !== undefined) ev = rawData[i][idxEv];
                    else ev = getVal(row, 'estado_enumerado') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || ''; }

                const evNorm = (ev || '').toString().toUpperCase().trim();
                
                // Solo mostrar filas con estado_enumerado = 'OK ENM', 'OK S/ENM' o 'OK PAQUETEO'
                if (evNorm === 'OK ENM' || evNorm === 'OK S/ENM' || evNorm === 'OK PAQUETEO') {
                    // Si la fila indica NO LLEVA en n.transfxpda, no mostrarla en Transfer
                    const rawNTrans = getVal(row, 'n.transfxpda');
                    let nTransfValCheck = '';
                    if (rawNTrans !== undefined && rawNTrans !== null && rawNTrans.toString().trim() !== '') {
                        nTransfValCheck = rawNTrans.toString();
                    } else {
                        const clienteChk = (getVal(row, 'CLIENTE') || '').toString().trim();
                        const estiloChk = (getVal(row, 'ESTILO') || '').toString().trim();
                        const avgChk = avgTransfByClienteEstilo(clienteChk, estiloChk);
                        nTransfValCheck = (avgChk !== null) ? avgChk : '';
                    }
                    nTransfValCheck = nTransfValCheck.toUpperCase().trim();
                    if (nTransfValCheck === 'NO LLEVA') continue;
                    // Obtener estado_transfer (por defecto 'X PROG' si está vacío)
                    let estadoTransfer = getVal(row, 'estado_transfer') || 'X PROG';
                    estadoTransfer = (!estadoTransfer || estadoTransfer === '') ? 'X PROG' : estadoTransfer;
                    
                    // Filtrar según el sub-tab activo
                    if (estadoTransfer === currentTransferFilter) {
                        count++;
                        
                        // Crear fila
                        const tr = document.createElement('tr');
                        
                        // F. DESPACHO
                        const tdFDesp = document.createElement('td');
                        tdFDesp.className = 'date-cell';
                        tdFDesp.innerText = formatValue(getVal(row, 'F. DESPACHO') || getVal(row, 'F DESPACHO') || '', 'date');
                        tr.appendChild(tdFDesp);
                        
                        // F.ING.COST
                        const tdFCost = document.createElement('td');
                        tdFCost.className = 'date-cell';
                        tdFCost.innerText = formatValue(getVal(row, 'F. ING COST') || getVal(row, 'F ING COST') || '', 'date');
                        tr.appendChild(tdFCost);
                        
                        // CLIENTE (normalizado para la vista Transfer)
                        const tdCliente = document.createElement('td');
                        tdCliente.innerText = normalizeClientForTransfer(getVal(row, 'CLIENTE') || '');
                        tr.appendChild(tdCliente);
                        
                        // RUTA
                        const tdRuta = document.createElement('td');
                        const rutaVal = getVal(row, 'RUTA TELA') || getVal(row, 'RUTA') || '';
                        tdRuta.innerHTML = renderRutaBadge(rutaVal, row);
                        tr.appendChild(tdRuta);
                        
                        // OC: usar columna OC si existe, sino concatenar OP y CORTE (ej: 39579-29)
                        const tdOC = document.createElement('td');
                        let ocVal = getVal(row, 'OC') || '';
                        if ((!ocVal || String(ocVal).trim() === '')) {
                            const opVal = getVal(row, 'OP') || getVal(row, 'OP TELA') || getVal(row, 'OP-PTDA') || '';
                            const corteVal = getVal(row, 'CORTE') || getVal(row, 'PARTIDA') || '';
                            if (opVal && corteVal) ocVal = `${String(opVal).trim()}-${String(corteVal).trim()}`;
                            else if (opVal) ocVal = String(opVal).trim();
                            else ocVal = '';
                        }
                        tdOC.innerText = ocVal;
                        tr.appendChild(tdOC);
                        
                        // COLOR
                        const tdColor = document.createElement('td');
                        tdColor.innerText = getVal(row, 'COLOR') || '';
                        tr.appendChild(tdColor);
                        
                        // PDS
                        const tdPds = document.createElement('td');
                        tdPds.style.textAlign = 'center';
                        const pdsVal = parseFloat(getVal(row, 'PDS GIRADAS') || getVal(row, 'PDS') || 0);
                        tdPds.innerText = formatThousands(pdsVal, 0);
                        tr.appendChild(tdPds);
                        
                        // PRENDA
                        const tdPrenda = document.createElement('td');
                        tdPrenda.innerText = getVal(row, 'PRENDA') || '';
                        tr.appendChild(tdPrenda);
                        
                        // TIPO CERT.
                        const tdCert = document.createElement('td');
                        tdCert.innerText = getVal(row, 'TIPO CERT') || getVal(row, 'TIPO CERT.') || '';
                        tr.appendChild(tdCert);
                        
                        // n.transfxpda: en sub-tabs 'Por Programar' (X PROG) y 'Programado' (PROG)
                        // mostrar solo el dato (sin desplegable). En otros casos podría seguir siendo editable.
                        const tdTransfxpda = document.createElement('td');
                        const rawNTrans = getVal(row, 'n.transfxpda');
                        let nTransfVal;
                        if (rawNTrans !== undefined && rawNTrans !== null && rawNTrans.toString().trim() !== '') {
                            nTransfVal = rawNTrans.toString().trim();
                        } else {
                            const clienteCur = (getVal(row, 'CLIENTE') || '').toString().trim();
                            const estiloCur = (getVal(row, 'ESTILO') || '').toString().trim();
                            const avgCur = avgTransfByClienteEstilo(clienteCur, estiloCur);
                            nTransfVal = (avgCur !== null) ? avgCur : 'LLEVA?';
                        }
                        // Normalize nTransf and tipo-transfer to detect 'NO LLEVA' values
                        const nTransfNormForCheck = (nTransfVal || '').toString().toUpperCase().trim();
                        const tipoTransferRaw = getVal(row, 'tipo-transfer') || getVal(row, 'tipo_transfer') || getVal(row, 'TIPO-TRANSFER') || '';
                        const tipoTransferNorm = (tipoTransferRaw || '').toString().toUpperCase().trim();

                        // If either n.transfxpda or tipo-transfer indicate NO LLEVA, skip this row
                        if (nTransfNormForCheck.indexOf('NO LLEVA') !== -1 || tipoTransferNorm.indexOf('NO LLEVA') !== -1) {
                            continue;
                        }

                        // Si estamos en los sub-tabs normales de Transfer (X PROG o PROG), mostrar solo texto
                        if (currentTransferFilter === 'X PROG' || currentTransferFilter === 'PROG') {
                            tdTransfxpda.style.textAlign = 'center';
                            tdTransfxpda.innerText = nTransfVal;
                        } else {
                            // Comportamiento por defecto: mostrar select (mantener compatibilidad)
                            const selTransf = document.createElement('select');
                            selTransf.className = 'table-select';
                            selTransf.setAttribute('data-row-index', i);
                            const nSelNorm = (nTransfVal || '').toString().toUpperCase().trim();
                            selTransf.innerHTML = `
                                <option value="LLEVA?" ${(nSelNorm === '' || nSelNorm === 'LLEVA?') ? 'selected' : ''}>LLEVA?</option>
                                <option value="NO LLEVA" ${(nSelNorm.indexOf('NO LLEVA') !== -1) ? 'selected' : ''}>NO LLEVA</option>
                                <option value="1" ${(nSelNorm === '1') ? 'selected' : ''}>1</option>
                                <option value="2" ${(nSelNorm === '2') ? 'selected' : ''}>2</option>
                                <option value="3" ${(nSelNorm === '3') ? 'selected' : ''}>3</option>
                                <option value="4" ${(nSelNorm === '4') ? 'selected' : ''}>4</option>
                                <option value="5" ${(nSelNorm === '5') ? 'selected' : ''}>5</option>
                            `;
                            selTransf.onchange = function() { updateRow(i, 'n.transfxpda', this.value, this); };
                            tdTransfxpda.appendChild(selTransf);
                        }
                        tr.appendChild(tdTransfxpda);

                        // tipo-transfer (columna nueva añadida en la hoja)
                        const tdTipoTransfer = document.createElement('td');
                        tdTipoTransfer.innerText = getVal(row, 'tipo-transfer') || getVal(row, 'tipo_transfer') || '';
                        tr.appendChild(tdTipoTransfer);
                        
                        // estado_transfer: mostrar solo el dato (sin desplegable) en la vista Transfer
                        const tdEstadoTransfer = document.createElement('td');
                        tdEstadoTransfer.innerText = estadoTransfer;
                        tdEstadoTransfer.title = estadoTransfer;
                        tr.appendChild(tdEstadoTransfer);
                        
                        tbody.appendChild(tr);
                    }
                }
            }
            document.getElementById('count-transfer').innerText = count;
        }

        function renderHabilitado() {
            const tbody = document.getElementById('tbody-habilitado');
            if (!tbody) return;
            tbody.innerHTML = "";
            let count = 0;
            // Ocultar las columnas OP-PTDA y ART. en el encabezado de Habilitado
            try {
                const thsHab = document.querySelectorAll('#view-habilitado thead th');
                thsHab.forEach(th => {
                    const txt = (th.textContent || '').toString().trim().toUpperCase();
                    if (txt === 'OP-PTDA' || txt === 'ART.' || txt === 'ART') th.style.display = 'none';
                    // Ocultar columnas que se mostrarán en el modal OC en la vista Habilitado
                    if (txt === 'RUTA' || txt === 'RUTA TELA') th.style.display = 'none';
                    if (txt === 'EQUIPO_CORTE' || txt === 'EQUIPO CORTE' || txt === 'EQUIPO_CORTES' || txt === 'EQUIPO') th.style.display = 'none';
                    if (txt === 'ESTADO_ENUMERADO' || txt === 'ESTADO ENUMERADO' || txt === 'ESTADO_ENUMERADO') th.style.display = 'none';
                    // Ocultar columna ESTADO_CORTE_BLOQUES en vista Habilitado
                    if (txt === 'ESTADO_CORTE_BLOQUES' || txt === 'ESTADO CORTE BLOQUES' || txt === 'ESTADO_BLOQS') th.style.display = 'none';
                    // Ocultar columna STATUS_CORTE solo en vista Habilitado
                    if (txt === 'STATUS_CORTE' || txt === 'STATUS CORTE' || txt === 'STATUS_CORTE') th.style.display = 'none';
                });
            } catch (e) {}
            // localizar índice de columna estado_enumerado de forma robusta
            const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');

            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                // Obtener valor de estado_enumerado preferiblemente desde rawData usando idxEv
                let ev = '';
                try {
                    if (idxEv !== -1 && rawData[i] && rawData[i][idxEv] !== undefined) ev = rawData[i][idxEv];
                    else ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO_ENumerado') || getVal(row, 'ESTADO ENUMERADO') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO_ENumerado') || getVal(row, 'ESTADO ENUMERADO') || ''; }

                const evNorm = (ev || '').toString().toUpperCase().trim();
                if (evNorm === 'OK ENM' || evNorm === 'OK S/ENM') {
                    count++;
                    const tr = createRow(row, i, "corte");
                    try {
                        const tds = tr.querySelectorAll('td');
                        if (tds.length > 9) tds[9].remove();
                        if (tds.length > 6) tds[6].remove();
                    } catch (e) {}
                    // Además eliminar la celda de RUTA, EQUIPO_CORTE y ESTADO_ENUMERADO en Habilitado
                    try {
                        const tds2 = tr.querySelectorAll('td');
                        const rutaVal = getVal(row, 'RUTA TELA') || getVal(row, 'RUTA') || '';
                        const equipoVal = getVal(row, 'EQUIPO CORTE') || getVal(row, 'EQUIPO_CORTE') || getVal(row, 'equipo_corte') || '';
                        // eliminar celda que contiene badge de ruta o texto de ruta
                        for (let j = 0; j < tds2.length; j++) {
                            try {
                                const td = tds2[j];
                                const span = td.querySelector && td.querySelector('.route-badge');
                                const txt = (td.textContent || '').toString().trim();
                                if (span || (rutaVal && txt === rutaVal)) { td.remove(); break; }
                            } catch(e) {}
                        }
                        // eliminar celda de equipo_corte (buscar select onchange o texto coincidente)
                        const tds3 = tr.querySelectorAll('td');
                        for (let j = 0; j < tds3.length; j++) {
                            try {
                                const td = tds3[j];
                                const sel = td.querySelector && td.querySelector('select');
                                if (sel && ( (sel.getAttribute('onchange')||'').indexOf("equipo_corte") !== -1 || (sel.getAttribute('onchange')||'').indexOf("'equipo_corte'") !== -1 )) { td.remove(); break; }
                                const txt = (td.textContent || '').toString().trim();
                                if (equipoVal && txt === equipoVal) { td.remove(); break; }
                            } catch(e) {}
                        }
                        // eliminar celda de estado_enumerado (buscar select onchange que actualiza estado_enumerado)
                        const tds4 = tr.querySelectorAll('td');
                        for (let j = 0; j < tds4.length; j++) {
                            try {
                                const td = tds4[j];
                                const sel = td.querySelector && td.querySelector('select');
                                if (sel && ( (sel.getAttribute('onchange')||'').indexOf("estado_enumerado") !== -1 )) { td.remove(); break; }
                            } catch(e) {}
                        }

                        // eliminar celdas de: COLL O TAP?, estado_transfer, estado_bordado, estado_estampado, estado_habilitado
                        const tds5 = tr.querySelectorAll('td');
                        for (let j = 0; j < tds5.length; j++) {
                            try {
                                const td = tds5[j];
                                const sel = td.querySelector && td.querySelector('select');
                                const onchange = (sel && (sel.getAttribute('onchange')||'').toString()) || '';
                                const txt = (td.textContent || '').toString().trim();
                                if (onchange.indexOf('ESTADO_COLL_TAP') !== -1 || onchange.indexOf('ESTADO_COLL') !== -1 || (txt.toUpperCase().indexOf('COLL')!==-1 && txt.toUpperCase().indexOf('TAP')!==-1)) { td.remove(); continue; }
                                if (onchange.indexOf('estado_transfer') !== -1 || onchange.indexOf('ESTADO_TRANSFER') !== -1) { td.remove(); continue; }
                                if (onchange.indexOf('estado_bordado') !== -1 || onchange.indexOf('ESTADO_BORDADO') !== -1) { td.remove(); continue; }
                                if (onchange.indexOf('estado_estampado') !== -1 || onchange.indexOf('ESTADO_ESTAMPADO') !== -1) { td.remove(); continue; }
                                if (onchange.indexOf('estado_habilitado') !== -1 || onchange.indexOf('ESTADO_HABILITADO') !== -1) { td.remove(); continue; }
                            } catch(e) {}
                        }
                    } catch (e) {}
                    // Además eliminar la celda de STATUS_CORTE en la vista Habilitado
                    try {
                        const selects = tr.querySelectorAll('select');
                        for (let s of selects) {
                            const oc = s.getAttribute('onchange') || '';
                            const on = oc.toString().toLowerCase();
                            if (on.indexOf("status_corte") !== -1 || on.indexOf("estado_corte") !== -1 || on.indexOf("', 'status'") !== -1 || on.indexOf("', 'STATUS'") !== -1) {
                                const td = s.closest('td');
                                if (td) td.remove();
                                break;
                            }
                        }
                    } catch (e) {}

                    // Añadir celdas específicas para la vista Habilitado: estado_corte_bloques, estado_transfer,
                    // estado_bordado, estado_estampado, estado_habilitado
                    try {
                        // No incluir 'estado_corte_bloques' aquí (columna removida en Habilitado)
                        const fields = [
                            ['estado_transfer','ESTADO_TRANSFER','ESTADO TRANSFER'],
                            ['estado_bordado','ESTADO_BORDADO','ESTADO BORDADO'],
                            ['estado_estampado','ESTADO_ESTAMPADO','ESTADO ESTAMPADO'],
                            ['estado_habilitado','ESTADO_HABILITADO','ESTADO HABILITADO']
                        ];
                        for (let f of fields) {
                            const val = getVal(row, f[0]) || getVal(row, f[1]) || getVal(row, f[2]) || '';
                            const td = document.createElement('td');
                            td.title = val;
                            td.innerText = val;
                            tr.appendChild(td);
                        }
                    } catch (e) {}

                    tbody.appendChild(tr);
                }
            }
            document.getElementById('count-habilitado').innerText = count;
        }

        // Función para formatear fechas al estilo: 04/Nov/25, 13/Ene/26, etc.
        function formatDateCustom(val) {
            // Meses abreviados en español (primeras 3 letras capitalizadas)
            const mesesEs = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 
                            'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
            
            // Caso 1: Si es un string tipo "Date(2026,1,13)" extraer los números
            if (typeof val === 'string' && val.includes('Date(')) {
                const match = val.match(/Date\((\d+),(\d+),(\d+)\)/);
                if (match) {
                    const year = match[1];
                    const month = parseInt(match[2]); // JavaScript usa 0-11 para meses
                    const day = String(match[3]).padStart(2, '0');
                    const yearShort = year.slice(-2);
                    
                    return `${day}/${mesesEs[month]}/${yearShort}`;
                }
            }
            
            // Caso 2: Si es un número de serie de Excel (número > 30000)
            if (typeof val === 'number' && val > 30000) {
                const date = new Date(Math.round((val - 25569) * 86400 * 1000));
                const day = String(date.getDate()).padStart(2, '0');
                const year = String(date.getFullYear()).slice(-2);
                const month = mesesEs[date.getMonth()];
                
                return `${day}/${month}/${year}`;
            }
            
            return val;
        }

        function formatValue(val, type) {
            if (type === 'date') {
                return formatDateCustom(val);
            }
            return val;
        }
        
        // Formatea números con separador de miles (reutilizable)
        function formatThousands(val, decimals = 0) {
            if (val === null || val === undefined || isNaN(val)) return val;
            if (decimals > 0) {
                return Number(val).toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
            }
            return Math.round(val).toLocaleString('en-US');
        }

        // Helper: indica si estamos en la vista Corte y en un sub-tab PROG (1T/2T/3T)
        function isCorteProgSubtab() {
            try {
                return document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active')
                    && currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG';
            } catch (e) { return false; }
        }
        
        // Helper: indica si estamos en la vista Enumerado
        function isEnumeradoView() {
            try {
                return document.getElementById('view-enumerado') && document.getElementById('view-enumerado').classList.contains('active');
            } catch (e) { return false; }
        }

        // Helper: indica si estamos en la vista Habilitado
        function isHabilitadoView() {
            try {
                return document.getElementById('view-habilitado') && document.getElementById('view-habilitado').classList.contains('active');
            } catch (e) { return false; }
        }
        
        function normalizeClientName(clientName) {
            if (!clientName) return "";
            const name = clientName.toString().toUpperCase();
            // Normalizaciones rápidas
            if (name.includes("LACOSTE")) return "LAC";
            if (name.includes("ATHLETA, INC.")) return "ATH";
            if (name.includes("BANANA REPUBLIC, LLC")) return "BNN";
            if (name.includes("THEORY LLC,")) return "THE";
            if (name.includes("DISH & DUER")) return "DDU";
            if (name.includes("SKECHERS PERFORMANCE")) return "SKE";
            if (name.includes("LULULEMON ATHLETICA CANADA INC")) return "LLL";
            if (name.includes("AM RETAIL S.A.C.")) return "AMR";
            return clientName;
        }

        // Normalización específica para la vista Transfer -> Asignar #Trf
        function normalizeClientForTransfer(clientName) {
            if (!clientName && clientName !== 0) return '';
            const s = String(clientName).trim();
            const up = s.toUpperCase();
            if (up.includes('LACOSTE - AMERICAS OPERATIONS PLATFORM')) return 'LACOSTE';
            if (up.includes('LULULEMON ATHLETICA CANADA INC')) return 'LULULEMON';
            if (up.includes('SKECHERS PERFORMANCE')) return 'SKECHERS';
            if (up.includes('ATHLETA, INC.')) return 'ATHLETA';
            if (up.includes('BANANA REPUBLIC, LLC')) return 'BANANA';
            if (up.includes('THEORY LLC,')) return 'THEORY';
            // Normalizaciones adicionales comunes
            if (up.includes('LACOSTE')) return 'LACOSTE';
            if (up.includes('LULULEMON')) return 'LULULEMON';
            if (up.includes('SKECHERS')) return 'SKECHERS';
            if (up.includes('ATHLETA')) return 'ATHLETA';
            if (up.includes('BANANA')) return 'BANANA';
            if (up.includes('THEORY')) return 'THEORY';
            return s;
        }

        // Abreviar 'HEATHER' o 'HEATHERED' -> 'HTR' en nombres de color (case-insensitive)
        function abbreviateHeather(colorName) {
            if (!colorName && colorName !== 0) return colorName;
            try {
                // Reemplaza 'HEATHER' o 'HEATHERED' por 'HTR', p. ej. 'HEATHER GREY' -> 'HTR GREY'
                return String(colorName).replace(/\bHEATHER(?:ED)?\b/ig, 'HTR');
            } catch (e) {
                return colorName;
            }
        }

        // Normaliza la descripción de PRENDA: elimina 'T-SHIRT' y quita '/' (ej. 'T-SHIRT M/L' -> 'ML')
        function normalizePrenda(prenda) {
            if (!prenda && prenda !== 0) return prenda || "";
            try {
                let s = String(prenda).toUpperCase().trim();
                // Eliminar variantes de T-SHIRT (T-SHIRT, T SHIRT, TSHIRT)
                s = s.replace(/\bT[- ]?SHIRT\b\s*/ig, '');
                // Si al eliminar 'T-SHIRT' queda vacío, devolver el valor original (mostrar 'T-SHIRT')
                if (s === '') return String(prenda).toUpperCase().trim();
                // Quitar espacios innecesarios
                s = s.replace(/\s+/g, '');
                // Reemplazar barras S/M -> SM, M/L -> ML
                s = s.replace(/\//g, '');
                return s;
            } catch (e) {
                return prenda;
            }
        }

        // Normaliza el campo TIPO CERT.: elimina espacios alrededor de '|' -> 'A | B | C' -> 'A|B|C'
        function normalizeTipoCert(tipoCert) {
            if (tipoCert === undefined || tipoCert === null) return '';
            try {
                return String(tipoCert).replace(/\s*\|\s*/g, '|').trim();
            } catch (e) { return tipoCert; }
        }

        function getVal(row, colName) {
            const idx = colMap[colName];
            return (idx !== undefined && idx !== -1) ? row[idx] : "";
        }

        function renderRutaBadge(rutaVal, row = null, rowIndex = null) {
            const rutaKey = String(rutaVal || "").toUpperCase().trim();
            let rutaDisplay = rutaVal;

            // Si la ruta contiene NORMAL y estamos en Corte X PROG, mostrar select con opciones
            try {
                const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                if (rutaKey.indexOf('NORMAL') !== -1 && onCorteView && currentCorteFilter === 'X PROG') {
                    const current = String(rutaVal || '').toUpperCase().trim();
                    const opts = ['LAVADA','ACABADA'];
                    let optionsHtml = '';
                    let matched = false;
                    for (const o of opts) {
                        const sel = (current === o) ? 'selected' : '';
                        if (sel) matched = true;
                        optionsHtml += `<option value="${o}" ${sel}>${o}</option>`;
                    }
                    if (current && !matched) {
                        optionsHtml = `<option value="${current}" selected>${current}</option>` + optionsHtml;
                    }
                    const idx = (rowIndex !== null) ? rowIndex : '';
                    rutaDisplay = `<select class="table-select" onchange="updateRow(${idx}, 'RUTA TELA', this.value, this)">${optionsHtml}</select>`;
                    return rutaDisplay;
                }
            } catch(e) { /* ignore */ }

            if (rutaKey === 'ACABADA') {
                rutaDisplay = `<span class="route-badge route-ac">AC</span>`;
            } else if (rutaKey === 'LAVADA') {
                if (row) {
                    const estadoBloqRaw = getVal(row, "estado_bloqueo");
                    const estadoBloq = (!estadoBloqRaw || estadoBloqRaw === "") ? "X PROG" : String(estadoBloqRaw).toUpperCase().trim();
                    const estadoLavRaw = getVal(row, "estado_lavada");
                    const estadoLav = (!estadoLavRaw || estadoLavRaw === "") ? "" : String(estadoLavRaw).toUpperCase().trim();

                    if (estadoBloq.includes('PROG')) {
                        rutaDisplay = `<span class="route-badge route-bloq">x bloq</span>`;
                    } else if (estadoBloq === 'OK' && (estadoLav === '' || estadoLav === 'EN LAV')) {
                        rutaDisplay = `<span class="route-badge route-xlav">x lavar</span>`;
                    } else if (estadoLav === 'OK') {
                        rutaDisplay = `<span class="route-badge route-lv">LV-ok</span>`;
                    } else {
                        rutaDisplay = `<span class="route-badge route-lv">LV</span>`;
                    }
                } else {
                    rutaDisplay = `<span class="route-badge route-lv">LV</span>`;
                }
            }
            
            return rutaDisplay;
        }

        function createRow(row, rowIndex, type, groupClass = "") {
            const tr = document.createElement('tr');
            if (groupClass) tr.className = `group-${groupClass}`; 
            
            if (type === "bloqueo" || type === "lavado") {
                const fDespacho = formatValue(getVal(row, "F. DESPACHO"), 'date');
                const fIngCost = formatValue(getVal(row, "F.ING.COST"), 'date');
                const cliente = normalizeClientName(getVal(row, "CLIENTE"));
                
                // === VISUALIZACIÓN TAL CUAL VIENE DEL EXCEL ===
                // Usamos la comilla invertida para forzar texto si es necesario, pero
                // con String() y trim() es suficiente. La clave es que no intentamos limpiar "ceros"
                const opTela = String(getVal(row, "OP TELA") || "").trim();
                const partida = String(getVal(row, "PARTIDA") || "").trim();
                
                // Unimos con un caracter visible
                const opPtda = `${opTela}-${partida}`; 
                
                const op = getVal(row, "OP");
                const corte = getVal(row, "CORTE");
                const rawColor = getVal(row, "COLOR");
                const color = abbreviateHeather(rawColor);
                const oc = `${op}-${corte}`;
                
                let kg = "0.00";
                const rawKg = getVal(row, "KG GIRADOS");
                if (rawKg) kg = parseFloat(rawKg).toFixed(2);
                
                const rib = getVal(row, "RIB");
                const articulo = getVal(row, "ARTÍCULO");
                const nroMolde = getVal(row, "NRO. MOLDE");
                const tipoCert = normalizeTipoCert(getVal(row, "TIPO CERTIFICADO"));

                let controlHtml = "";

                if (type === "bloqueo") {
                    const ribOriginal = rib || "NO LLEVA";
                    const ribGuardado = getVal(row, "estado_rib");
                    const ribValue = ribGuardado || (ribOriginal === "NO LLEVA" ? "NO LLEVA" : "SI LLEVA");
                    let ribDisabled = (ribOriginal === "NO LLEVA") ? "disabled" : "";
                    let ribClass = (ribValue === "OK") ? "sel-OK" : "";
                    // Si estamos en la vista Bloqueo y en el sub-tab 'Por Programar' (X PROG),
                    // mostrar solo el dato (sin desplegable). Para el resto de vistas
                    // mantener el select como antes.
                    let ribHtml = '';
                    try {
                        const onBloqView = document.getElementById('view-bloqueo') && document.getElementById('view-bloqueo').classList.contains('active');
                        if (onBloqView && currentBloqueoFilter === 'X PROG') {
                            const spanClass = (ribValue === 'SI LLEVA') ? 'rib-si-lleva' : 'rib-text';
                            ribHtml = `<td title="${ribValue}"><span class="${spanClass}">${ribValue}</span></td>`;
                        } else {
                            const ribSelect = `
                                <select class="table-select ${ribClass}" ${ribDisabled} onchange="updateRow(${rowIndex}, 'estado_rib', this.value, this)">
                                    ${ribOriginal === "NO LLEVA" 
                                        ? `<option>NO LLEVA</option>` 
                                        : `<option value="SI LLEVA" ${ribValue === "SI LLEVA" ? "selected" : ""}>SI LLEVA</option>
                                        <option value="NO PASO" ${ribValue === "NO PASO" ? "selected" : ""}>NO PASO</option>
                                        <option value="EN CORTE" ${ribValue === "EN CORTE" ? "selected" : ""}>EN CORTE</option>
                                        <option value="EN LAV" ${ribValue === "EN LAV" ? "selected" : ""}>EN LAV</option>
                                        <option value="LAV(rep)" ${ribValue === "LAV(rep)" ? "selected" : ""}>LAV(rep)</option>
                                        <option value="EN HAB" ${ribValue === "EN HAB" ? "selected" : ""}>EN HAB</option>`
                                    }
                                </select>`;
                            ribHtml = `<td>${ribSelect}</td>`;
                        }
                    } catch(e) {
                        const ribSelect = `
                            <select class="table-select ${ribClass}" ${ribDisabled} onchange="updateRow(${rowIndex}, 'estado_rib', this.value, this)">
                                ${ribOriginal === "NO LLEVA" 
                                    ? `<option>NO LLEVA</option>` 
                                    : `<option value="SI LLEVA" ${ribValue === "SI LLEVA" ? "selected" : ""}>SI LLEVA</option>
                                    <option value="NO PASO" ${ribValue === "NO PASO" ? "selected" : ""}>NO PASO</option>
                                    <option value="EN CORTE" ${ribValue === "EN CORTE" ? "selected" : ""}>EN CORTE</option>
                                    <option value="EN LAV" ${ribValue === "EN LAV" ? "selected" : ""}>EN LAV</option>
                                    <option value="LAV(rep)" ${ribValue === "LAV(rep)" ? "selected" : ""}>LAV(rep)</option>
                                    <option value="EN HAB" ${ribValue === "EN HAB" ? "selected" : ""}>EN HAB</option>`
                                }
                            </select>`;
                        ribHtml = `<td>${ribSelect}</td>`;
                    }
                    const bloqValue = getVal(row, "estado_bloqueo") || "X PROG";
                    let bloqClass = "";
                    if (bloqValue === "PROG") bloqClass = "sel-PROG";
                    if (bloqValue === "OK") bloqClass = "sel-OK";

                    // Determinar si se deben ocultar opciones en el select de Bloqueo
                    let showOkOption = true;
                    let showXProgOption = true;
                    try {
                        const onBloqView = document.getElementById('view-bloqueo') && document.getElementById('view-bloqueo').classList.contains('active');
                        if (onBloqView && currentBloqueoFilter === 'X PROG') showOkOption = false;
                        if (onBloqView && currentBloqueoFilter === 'PROG') showXProgOption = false;
                    } catch (e) { /* silent */ }

                    // Si ocultamos X PROG pero el valor actual es 'X PROG', forzamos un valor visible
                    const effectiveValue = (bloqValue === 'X PROG' && !showXProgOption) ? 'PROG' : bloqValue;

                    const xProgOptionHtml = showXProgOption ? `<option value="X PROG" ${effectiveValue === "X PROG" ? "selected" : ""}>X PROG</option>` : '';
                    const okOptionHtml = showOkOption ? `<option value="OK" ${effectiveValue === "OK" ? "selected" : ""}>OK</option>` : '';

                    // En la vista Bloqueo->Programado, requerir que el usuario haya seleccionado RIB (estado_rib)
                    // para permitir cambiar el estado de Bloqueo. Si no existe un valor guardado en estado_rib,
                    // deshabilitar el select y mostrar tooltip indicando que primero debe elegir RIB.
                    let requireRibSelection = false;
                    try {
                        const onBloqView = document.getElementById('view-bloqueo') && document.getElementById('view-bloqueo').classList.contains('active');
                        if (onBloqView && currentBloqueoFilter === 'PROG') requireRibSelection = true;
                    } catch (e) { /* ignore */ }

                    // Considerar que si la columna original "RIB" indica "NO LLEVA",
                    // entonces se considera como si ya estuviera seleccionada y por tanto
                    // permitir cambiar el estado de Bloqueo incluso en sub-tab PROG.
                    const hasRibSavedOrNoLleva = !!ribGuardado || (String(ribOriginal).toUpperCase() === "NO LLEVA");
                    const bloqDisabledAttr = (requireRibSelection && !hasRibSavedOrNoLleva) ? 'disabled' : '';
                    const bloqTitle = (requireRibSelection && !hasRibSavedOrNoLleva) ? 'Seleccione RIB primero' : '';

                    const bloqSelect = `
                        <select class="table-select ${bloqClass}" ${bloqDisabledAttr} title="${bloqTitle}" onchange="updateRow(${rowIndex}, 'estado_bloqueo', this.value, this)">
                            ${xProgOptionHtml}
                            <option value="PROG" ${effectiveValue === "PROG" ? "selected" : ""}>PROG</option>
                            ${okOptionHtml}
                        </select>`;

                    // Mostrar solo el dato (sin select) cuando estemos en la vista Bloqueo y en el sub-tab 'Por Programar' (X PROG)
                    let bloqCellHtml = '';
                    try {
                        const onBloqView = document.getElementById('view-bloqueo') && document.getElementById('view-bloqueo').classList.contains('active');
                        if (onBloqView && currentBloqueoFilter === 'X PROG') {
                            const bloqDisplay = bloqValue || '';
                            bloqCellHtml = `<td title="${bloqDisplay}"><span class="bloq-text">${bloqDisplay}</span></td>`;
                        } else {
                            bloqCellHtml = `<td>${bloqSelect}</td>`;
                        }
                    } catch (e) {
                        bloqCellHtml = `<td>${bloqSelect}</td>`;
                    }

                    controlHtml = `<td title="${nroMolde}">${nroMolde}</td><td title="${tipoCert}">${tipoCert}</td>${bloqCellHtml}${ribHtml}`;

                } else if (type === "lavado") {
                    const lavValue = getVal(row, "estado_lavada") || "EN LAV";
                    // Mostrar solo el dato en la vista Lavanderia (sin desplegable)
                    const lavDisplay = `<span class="rib-text">${lavValue}</span>`;

                    const ribOriginal = rib || "NO LLEVA";
                    const ribGuardado = getVal(row, "estado_rib");
                    const ribValue = ribGuardado || (ribOriginal === "NO LLEVA" ? "NO LLEVA" : "SI LLEVA");
                    let ribDisabled = (ribOriginal === "NO LLEVA") ? "disabled" : "";
                    let ribClass = (ribValue === "OK") ? "sel-OK" : "";

                    // En Lavado mostrar sólo las opciones solicitadas. Si es NO LLEVA mantener celda deshabilitada.
                    let ribSelect = '';
                    try {
                        if (ribOriginal === "NO LLEVA") {
                            ribSelect = `<select class="table-select" disabled><option>NO LLEVA</option></select>`;
                        } else {
                            const danger = (String(ribValue).toUpperCase() === 'NO PASO' || String(ribValue).toUpperCase() === 'LAV(REP)');
                            const extraClass = danger ? 'rib-danger' : '';
                            ribSelect = `
                                <select class="table-select ${ribClass} ${extraClass}" onchange="updateRow(${rowIndex}, 'estado_rib', this.value, this)">
                                    <option value="NO PASO" ${ribValue === "NO PASO" ? "selected" : ""}>NO PASO</option>
                                    <option value="EN CORTE" ${ribValue === "EN CORTE" ? "selected" : ""}>EN CORTE</option>
                                    <option value="EN LAV" ${ribValue === "EN LAV" ? "selected" : ""}>EN LAV</option>
                                    <option value="LAV(rep)" ${ribValue === "LAV(rep)" ? "selected" : ""}>LAV(rep)</option>
                                </select>`;
                        }
                    } catch (e) {
                        ribSelect = `<select class="table-select ${ribClass}" ${ribDisabled} onchange="updateRow(${rowIndex}, 'estado_rib', this.value, this)">
                                        <option value="NO PASO" ${ribValue === "NO PASO" ? "selected" : ""}>NO PASO</option>
                                        <option value="EN CORTE" ${ribValue === "EN CORTE" ? "selected" : ""}>EN CORTE</option>
                                        <option value="EN LAV" ${ribValue === "EN LAV" ? "selected" : ""}>EN LAV</option>
                                        <option value="LAV(rep)" ${ribValue === "LAV(rep)" ? "selected" : ""}>LAV(rep)</option>
                                    </select>`;
                    }

                    controlHtml = `<td title="${tipoCert}">${tipoCert}</td><td>${lavDisplay}</td><td>${ribSelect}</td>`;
                }

                // Usamos title para mostrar el dato completo en hover por si acaso
                let html = `
                    <td class="date-cell">${fDespacho}</td>
                    <td class="date-cell">${fIngCost}</td>
                    <td>${cliente}</td>
                    <!-- TOOLTIP TITLE PARA VER TEXTO COMPLETO -->
                    <td class="op-cell wrap-text" title="${opPtda}">${opPtda}</td>
                    <td class="op-cell" title="${oc}">${oc}</td>
                    <td title="${color}">${color}</td>
                    <td class="kg-cell" style="text-align:right;">${kg}</td>
                    <td title="${articulo}">${articulo}</td>
                    ${controlHtml}
                `;
                tr.innerHTML = html;

            } else {
                const fDespacho = formatValue(getVal(row, "F. DESPACHO"), 'date');
                const fIngCost = formatValue(getVal(row, "F.ING.COST"), 'date');
                const cliente = normalizeClientName(getVal(row, "CLIENTE"));

                const op = getVal(row, "OP");
                const corte = getVal(row, "CORTE");
                const oc = (op || corte) ? `${op}-${corte}` : "";

                const rutaVal = getVal(row, "RUTA TELA") || getVal(row, "RUTA") || "";

                const rawColor = getVal(row, "COLOR");
                const color = abbreviateHeather(rawColor);

                const opTela = String(getVal(row, "OP TELA") || "").trim();
                const partida = String(getVal(row, "PARTIDA") || "").trim();
                const opPtda = `${opTela}-${partida}`;

                const pdsRaw = parseFloat(getVal(row, "PDS GIRADAS")) || 0;
                const pdsStr = formatThousands(pdsRaw, 0);

                const prenda = getVal(row, "PRENDA");
                const prendaNorm = normalizePrenda(prenda);
                const articulo = getVal(row, "ARTÍCULO");
                const tipoCert = normalizeTipoCert(getVal(row, "TIPO CERTIFICADO"));
                const rib = getVal(row, "RIB") || getVal(row, "estado_rib") || "";

                const equipoCorte = getVal(row, "EQUIPO CORTE") || getVal(row, "EQUIPO_CORTE") || getVal(row, "equipo_corte") || "";
                const estadoCorte = getVal(row, "STATUS_CORTE") || getVal(row, "STATUS") || getVal(row, "status") || getVal(row, "ESTADO CORTE") || getVal(row, "ESTADO_CORTE") || getVal(row, "estado_corte") || "";
                // Determinar el nombre de columna a usar al guardar: preferir la que exista en colMap
                let updateColName = 'STATUS_CORTE';
                if (colMap[updateColName] === undefined || colMap[updateColName] === -1) {
                    const candidates = ['STATUS','status','estado_corte','ESTADO CORTE','ESTADO_CORTE'];
                    for (let c of candidates) {
                        if (colMap[c] !== undefined && colMap[c] !== -1) { updateColName = c; break; }
                    }
                }
                const estadoBloques = getVal(row, "ESTADO BLOQUES") || getVal(row, "ESTADO_BLOQUES") || getVal(row, "estado_bloques") || "";
                const estadoCollTap = getVal(row, "ESTADO COLL TAP") || getVal(row, "ESTADO_COLL_TAP") || getVal(row, "estado_coll_tap") || "";

                // Determinar si mostrar el botón de tendido (solo en sub-tabs PROG 1T/2T/3T)
                const showTendidoBtn = (currentCorteFilter === 'PROG 1T' || currentCorteFilter === 'PROG 2T' || currentCorteFilter === 'PROG 3T') && !isHabilitadoView();
                const tendidoBtnHtml = showTendidoBtn 
                    ? `<button class="btn-tendido" onclick="abrirModalTendido(${rowIndex}, '${op}', '${corte}', '${String(color).replace(/'/g, "\\'")}', ${pdsRaw})" title="Dividir en tendidos">+</button>` 
                    : '';

                // Determinar si se muestra el botón lavadora junto al OP-PTDA
                const showWasherBtn = (currentCorteFilter === 'PROG 1T' || currentCorteFilter === 'PROG 2T' || currentCorteFilter === 'PROG 3T') && (String(rutaVal || '').toUpperCase().trim() !== 'ACABADA');
                const washerHtml = showWasherBtn ? `<button class="btn-washer" title="Marcar EN LAV" onclick="abrirModalLavado(${rowIndex})"><i class="ph ph-washing-machine" style="font-size:12px;"></i></button>` : '';

                // Usar la función helper para renderizar el badge de RUTA
                const rutaDisplay = renderRutaBadge(rutaVal, row, rowIndex);

                let html = `
                    <td class="date-cell">${fDespacho}</td>
                    <td class="date-cell">${fIngCost}</td>
                    <td title="${cliente}">${cliente}</td>
                    <td title="${rutaVal}">${rutaDisplay}</td>
                    <td class="op-cell" title="${oc}">${tendidoBtnHtml}<span class="oc-link" onclick="if(isHabilitadoView()) abrirModalOC(${rowIndex});">${oc}</span></td>
                    <td title="${color}">${color}</td>
                    <td class="op-cell wrap-text" title="${opPtda}">${washerHtml}${opPtda}</td>
                    <td class="kg-cell" style="text-align:center;">${pdsStr}</td>
                    <td title="${prenda}">${prendaNorm}</td>
                    <td title="${articulo}">${articulo}</td>
                    <td title="${tipoCert}">${tipoCert}</td>
                    <td>
                        ${(() => {
                            const ribOriginal = getVal(row, "RIB") || "NO LLEVA";
                            const ribGuardado = getVal(row, "estado_rib");
                            const ribValue = ribGuardado || (ribOriginal === "NO LLEVA" ? "NO LLEVA" : "SI LLEVA");
                            const ribDisabled = (ribOriginal === "NO LLEVA") ? "disabled" : "";
                            const ribClass = (ribValue === "OK") ? "sel-OK" : "";
                            try {
                                const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                                if (onCorteView && currentCorteFilter === 'X PROG') {
                                    const spanClass = (ribValue === 'SI LLEVA') ? 'rib-si-lleva' : 'rib-text';
                                    return `<span title="${ribValue}" class="${spanClass}">${ribValue}</span>`;
                                }
                            } catch (e) { /* ignore */ }
                            return `
                                <select class="table-select ${ribClass}" ${ribDisabled} onchange="updateRow(${rowIndex}, 'estado_rib', this.value, this)">
                                    ${ribOriginal === "NO LLEVA"
                                        ? `<option>NO LLEVA</option>`
                                        : `<option value="SI LLEVA" ${ribValue === "SI LLEVA" ? "selected" : ""}>SI LLEVA</option>
                                           <option value="NO PASO" ${ribValue === "NO PASO" ? "selected" : ""}>NO PASO</option>
                                           <option value="EN CORTE" ${ribValue === "EN CORTE" ? "selected" : ""}>EN CORTE</option>
                                           <option value="EN LAV" ${ribValue === "EN LAV" ? "selected" : ""}>EN LAV</option>
                                           <option value="LAV(rep)" ${ribValue === "LAV(rep)" ? "selected" : ""}>LAV(rep)</option>
                                           <option value="EN HAB" ${ribValue === "EN HAB" ? "selected" : ""}>EN HAB</option>`}
                                </select>
                            `;
                        })()}
                    </td>
                        <td>
                            ${(() => {
                                // En la vista Enumerado siempre mostrar solo el dato (sin select)
                                try {
                                    if (isEnumeradoView()) return equipoCorte || '';
                                } catch (e) {}

                                // Para la vista Corte Pzas -> Por Programar (X PROG) mostrar solo dato (no select)
                                try {
                                    if (type === 'corte' && currentCorteFilter === 'X PROG') {
                                        return equipoCorte || '';
                                    }
                                } catch (e) {}

                                // En el resto de casos mostrar select para elegir equipo
                                const currentEquipo = equipoCorte || '';
                                let optionsHtml = '<option value="">-- Seleccionar --</option>';
                                equiposCorteData.forEach(eq => {
                                    const selected = (currentEquipo === eq.nombre) ? 'selected' : '';
                                    optionsHtml += `<option value="${eq.nombre}" ${selected}>${eq.nombre}</option>`;
                                });
                                return `
                                    <select class="table-select" onchange="updateRow(${rowIndex}, 'equipo_corte', this.value, this)">
                                        ${optionsHtml}
                                    </select>
                                `;
                            })()}
                        </td>
                        <td>
                            ${(() => {
                                const est = (estadoCorte || '').toString();
                                const estClass = est.toUpperCase().includes('PROG') ? 'sel-PROG' : (est === 'OK' ? 'sel-OK' : '');
                                // Ocultar opción OK sólo cuando estamos en la vista Corte y en el sub-tab 'X PROG'
                                let allowOk = true;
                                // Ocultar opción X PROG cuando estamos en la vista Corte y en un sub-tab PROG (1T/2T/3T)
                                let allowXProg = true;
                                try {
                                    const onCorte = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                                    if (onCorte && currentCorteFilter === 'X PROG') allowOk = false;
                                    if (onCorte && currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG') allowXProg = false;
                                } catch (e) { /* ignore */ }

                                const okOption = allowOk ? `<option value="OK" ${est === 'OK' ? 'selected' : ''}>OK</option>` : '';
                                // Si X PROG está oculto pero el valor actual es 'X PROG', forzar selección por defecto a 'PROG 1T'
                                let effectiveEst = est;
                                if (!allowXProg && est === 'X PROG') effectiveEst = 'PROG 1T';

                                const xProgOption = allowXProg ? `<option value="X PROG" ${(!effectiveEst || effectiveEst === '' || effectiveEst === 'X PROG') ? 'selected' : ''}>X PROG</option>` : '';

                                // Si estamos en la vista Corte Pzas y en el sub-tab "Por Programar" (X PROG)
                                // mostrar solo el dato de STATUS_CORTE (sin desplegable)
                                try {
                                    if (type === 'corte' && currentCorteFilter === 'X PROG') {
                                        return `<span title="${est}">${est}</span>`;
                                    }
                                } catch (e) {}

                                return `
                                    <select class="table-select ${estClass}" onchange="updateRow(${rowIndex}, '${updateColName}', this.value, this)">
                                        ${xProgOption}
                                        <option value="PROG 1T" ${effectiveEst === 'PROG 1T' ? 'selected' : ''}>PROG 1T</option>
                                        <option value="PROG 2T" ${effectiveEst === 'PROG 2T' ? 'selected' : ''}>PROG 2T</option>
                                        <option value="PROG 3T" ${effectiveEst === 'PROG 3T' ? 'selected' : ''}>PROG 3T</option>
                                        ${okOption}
                                    </select>
                                `;
                            })()}
                        </td>
                    ${(() => {
                        // Si estamos en sub-tab PROG (1T/2T/3T) dentro de la vista Corte,
                        // o si estamos en la vista Enumerado, mostramos selects con las opciones solicitadas.
                        if (isCorteProgSubtab() || isEnumeradoView() || isHabilitadoView()) {
                            const bloqVal = (estadoBloques || '').toString();
                            const collVal = (estadoCollTap || '').toString();
                            // Para BLOQUES?: en las vistas Enumerado y Habilitado mostramos el dato (texto),
                            // en otras vistas mostramos el select editable.
                            let bloqCell = '';
                            if (isHabilitadoView() || isEnumeradoView()) {
                                const bloqDisplay = estadoBloques || '';
                                bloqCell = `<td title="${bloqDisplay}">${bloqDisplay}</td>`;
                            } else {
                                bloqCell = `
                                    <td>
                                        <select class="table-select" onchange="updateRow(${rowIndex}, 'ESTADO_BLOQUES', this.value, this)">
                                            <option value="LLEVA?" ${( !bloqVal || bloqVal === 'LLEVA?' ) ? 'selected' : ''}>LLEVA?</option>
                                            <option value="Ok corte" ${bloqVal === 'Ok corte' ? 'selected' : ''}>Ok corte</option>
                                            <option value="NO LLEVA" ${bloqVal === 'NO LLEVA' ? 'selected' : ''}>NO LLEVA</option>
                                        </select>
                                    </td>`;
                            }

                            // Para COLL o TAP?: en Habilitado mostrar select con el dato actual + OK,
                            // en otras vistas mantener las opciones completas. En particular,
                            // para los sub-tabs PROG de la vista Corte queremos el select completo
                            // (igual que Enumerado), así que forzamos ese HTML cuando corresponda.
                            let collSelect = '';
                            const fullCollSelectHtml = `
                                    <td>
                                        <select class="table-select" onchange="updateRow(${rowIndex}, 'ESTADO_COLL_TAP', this.value, this)">
                                            <option value="LLEVA?" ${(!collVal || collVal === 'LLEVA?') ? 'selected' : ''}>LLEVA?</option>
                                            <option value="Coll en Hab" ${collVal === 'Coll en Hab' ? 'selected' : ''}>Coll en Hab</option>
                                            <option value="Tap en Hab" ${collVal === 'Tap en Hab' ? 'selected' : ''}>Tap en Hab</option>
                                            <option value="Coll+Tap en Hab" ${collVal === 'Coll+Tap en Hab' ? 'selected' : ''}>Coll+Tap en Hab</option>
                                            <option value="NO LLEVA" ${collVal === 'NO LLEVA' ? 'selected' : ''}>NO LLEVA</option>
                                        </select>
                                    </td>`;

                            if (isHabilitadoView()) {
                                const currentVal = (collVal || '').toString();
                                const isOk = currentVal === 'OK';
                                // Si está vacío, mostrar 'x llenar'
                                const displayLabel = currentVal === '' ? 'x llenar' : currentVal;
                                const safeVal = (currentVal === '' ? 'x llenar' : currentVal).replace(/\"/g, '&quot;');
                                collSelect = `
                                    <td>
                                        <select class="table-select" onchange="updateRow(${rowIndex}, 'ESTADO_COLL_TAP', this.value, this)">
                                            <option value="${safeVal}" ${!isOk ? 'selected' : ''}>${displayLabel}</option>
                                            <option value="OK" ${isOk ? 'selected' : ''}>OK</option>
                                        </select>
                                    </td>`;
                            } else {
                                collSelect = fullCollSelectHtml;
                            }
                            // Si estamos en un sub-tab PROG dentro de Corte, devolver el select completo
                            // (igual que en Enumerado) y evitar caer en el retorno por defecto.
                            try {
                                if (isCorteProgSubtab()) {
                                    return bloqCell + collSelect;
                                }
                            } catch (e) {}

                                    // Si estamos en Enumerado o Habilitado, también añadir el select

                            // Forzar select completo en los sub-tabs PROG dentro de Corte
                            try {
                                if (isCorteProgSubtab()) collSelect = fullCollSelectHtml;
                            } catch(e){}

                                    // Si estamos en Enumerado o Habilitado, también añadir el select
                                    // para estado_enumerado como última columna
                                    if (isEnumeradoView() || isHabilitadoView()) {
                                        const enmVal = (estadoBloques && estadoBloques.toString()) ? '' : '';
                                        // Buscar valor actual en las variantes de columna
                                        const evCandidates = [ 'estado_enumerado', 'ESTADO_ENumerado', 'ESTADO ENUMERADO' ];
                                        // Intentar recuperar valor real (si existe) desde rawData
                                        let ev = '';
                                        try {
                                            const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
                                            if (idxEv !== -1 && rawData[rowIndex] && rawData[rowIndex][idxEv]) ev = String(rawData[rowIndex][idxEv]);
                                        } catch (e) { ev = ''; }
                                        const evNorm = (ev || '').toString();
                                        // Construir dos variantes del select: una para Enumerado y otra para Habilitado
                                        const enmSelectEnumerado = `
                                            <td>
                                                <select class="table-select" onchange="updateRow(${rowIndex}, 'estado_enumerado', this.value, this)">
                                                    <option value="X ENM" ${(evNorm === '' || evNorm === 'X ENM') ? 'selected' : ''}>X ENM</option>
                                                    <option value="OK ENM" ${evNorm === 'OK ENM' ? 'selected' : ''}>OK ENM</option>
                                                    <option value="OK Paqueteo" ${evNorm === 'OK PAQUETEO' || evNorm === 'OK Paqueteo' ? 'selected' : ''}>OK Paqueteo</option>
                                                </select>
                                            </td>`;

                                        const enmSelectHabilitado = `
                                            <td>
                                                <select class="table-select" onchange="updateRow(${rowIndex}, 'estado_enumerado', this.value, this)">
                                                    <option value="X ENM" ${(evNorm === '' || evNorm === 'X ENM') ? 'selected' : ''}>X ENM</option>
                                                    <option value="OK ENM" ${evNorm === 'OK ENM' ? 'selected' : ''}>OK ENM</option>
                                                    <option value="OK S/ENM" ${evNorm === 'OK S/ENM' ? 'selected' : ''}>OK S/ENM</option>
                                                </select>
                                            </td>`;

                                        // Si estamos en Enumerado, mostrar solo las opciones solicitadas (OK ENM, OK Paqueteo)
                                        if (isEnumeradoView() && !isHabilitadoView()) {
                                            return bloqCell + enmSelectEnumerado;
                                        }

                                        // Para la vista Habilitado añadimos una columna adicional ESTADO_BLOQS
                                        // entre BLOQUES? y COLL o TAP? que muestra el valor sin desplegable.
                                        if (isHabilitadoView()) {
                                            const estBloqsVal = getVal(row, 'estado_corte_bloques') || getVal(row, 'ESTADO_CORTE_BLOQUES') || getVal(row, 'ESTADO CORTE BLOQUES') || getVal(row, 'ESTADO_BLOQS') || '';
                                            const estBloqsTd = `<td title="${estBloqsVal}">${estBloqsVal}</td>`;
                                            return bloqCell + estBloqsTd + collSelect + enmSelectHabilitado;
                                        }

                                        // Comportamiento por defecto (Corte PROG u otros): incluir COLL + el select de Habilitado
                                        return bloqCell + collSelect + enmSelectHabilitado;
                                    }
                        }
                        return `<td title="${estadoBloques}">${estadoBloques}</td>\n                    <td title="${estadoCollTap}">${estadoCollTap}</td>`;
                    })()}
                `;
                tr.innerHTML = html;
            }

            return tr;
        }

        // Función auxiliar para propagar cambios a filas con mismo OP y serie de corte
        function propagateToSameOPAndCorteSeries(rowIndex, colName, value) {
            try {
                console.log('=== INICIANDO PROPAGACIÓN ===');
                console.log('Fila:', rowIndex, 'Columna:', colName, 'Valor:', value);
                
                // Función auxiliar para normalizar nombres de columnas
                const findColIndexNormalized = function(name) {
                    if (!rawData || rawData.length === 0) return -1;
                    const headers = rawData[0];
                    const norm = s => String(s || '').toLowerCase().replace(/[^a-z0-9]/g, '');
                    const target = norm(name);
                    for (let i = 0; i < headers.length; i++) {
                        if (norm(headers[i]) === target) return i;
                    }
                    return -1;
                };

                // Obtener índices de columnas necesarias
                const opIdx = findColIndexNormalized('OP');
                const corteIdx = findColIndexNormalized('CORTE');
                
                // Para la columna objetivo, intentar primero el nombre exacto, luego variantes
                let colIdx = -1;
                
                // Si colName ya está en colMap, usarlo
                if (colMap[colName] !== undefined && colMap[colName] !== -1) {
                    colIdx = colMap[colName];
                    console.log('Usando colIdx desde colMap:', colIdx);
                } else {
                    // Intentar encontrar la columna
                    colIdx = findColIndexNormalized(colName);
                    
                    // Si no encuentra la columna, intentar con variantes según el tipo
                    if (colIdx === -1) {
                        console.log('No se encontró columna con nombre:', colName, '- intentando variantes');
                        
                        if (colName.includes('BLOQUES') || colName.includes('bloques')) {
                            const variants = ['estado_bloques', 'ESTADO_BLOQUES', 'ESTADO BLOQUES'];
                            for (let v of variants) {
                                colIdx = findColIndexNormalized(v);
                                if (colIdx !== -1) {
                                    console.log('Encontrada variante:', v, 'en índice:', colIdx);
                                    break;
                                }
                            }
                        } else if (colName.includes('COLL') || colName.includes('TAP') || colName.includes('coll') || colName.includes('tap')) {
                            const variants = ['estado_coll_tap', 'ESTADO_COLL_TAP', 'ESTADO COLL TAP'];
                            for (let v of variants) {
                                colIdx = findColIndexNormalized(v);
                                if (colIdx !== -1) {
                                    console.log('Encontrada variante:', v, 'en índice:', colIdx);
                                    break;
                                }
                            }
                        } else if (colName.includes('rib') || colName.includes('RIB')) {
                            const variants = ['estado_rib', 'ESTADO_RIB', 'ESTADO RIB'];
                            for (let v of variants) {
                                colIdx = findColIndexNormalized(v);
                                if (colIdx !== -1) {
                                    console.log('Encontrada variante:', v, 'en índice:', colIdx);
                                    break;
                                }
                            }
                        }
                    }
                }

                console.log('Índices encontrados - OP:', opIdx, 'CORTE:', corteIdx, 'Columna objetivo:', colIdx);

                if (opIdx === -1 || corteIdx === -1 || colIdx === -1) {
                    console.warn('No se encontraron columnas necesarias para propagar', {opIdx, corteIdx, colIdx});
                    if (colIdx === -1) {
                        console.warn('Headers disponibles:', rawData[0]);
                    }
                    return;
                }

                // Obtener valores de la fila actual
                const currentOP = String(rawData[rowIndex][opIdx] || '').trim();
                const currentCorte = String(rawData[rowIndex][corteIdx] || '').trim();

                console.log('Valores actuales - OP:', currentOP, 'CORTE:', currentCorte);

                if (!currentOP || !currentCorte) {
                    console.warn('Fila sin OP o CORTE, no se propagará');
                    return;
                }

                // Extraer el número base del corte (todos menos los últimos 2 dígitos)
                // Ejemplos: 101 -> 1, 403 -> 4, 1202 -> 12
                const corteNum = currentCorte.match(/\d+/);
                if (!corteNum) {
                    console.warn('CORTE no contiene números:', currentCorte);
                    return;
                }
                
                const corteNumStr = corteNum[0];
                const corteBase = corteNumStr.slice(0, -2); // Remover últimos 2 dígitos
                
                console.log('Serie de corte identificada:', corteBase + 'xx');
                
                let updatedCount = 0;
                
                // Buscar todas las filas con el mismo OP y mismo corteBase
                for (let j = 1; j < rawData.length; j++) {
                    if (j === rowIndex) continue; // Saltar la fila actual
                    
                    const otherOP = String(rawData[j][opIdx] || '').trim();
                    const otherCorte = String(rawData[j][corteIdx] || '').trim();
                    
                    // Verificar si tiene el mismo OP
                    if (otherOP !== currentOP) continue;
                    
                    // Verificar si el corte pertenece a la misma serie
                    const otherCorteNum = otherCorte.match(/\d+/);
                    if (!otherCorteNum) continue;
                    
                    const otherCorteNumStr = otherCorteNum[0];
                    const otherCorteBase = otherCorteNumStr.slice(0, -2);
                    
                    // Si el corteBase coincide, propagar el cambio
                    if (otherCorteBase === corteBase) {
                        const prevValue = rawData[j][colIdx];
                        console.log(`Fila ${j} (Corte: ${otherCorte}): ${prevValue} -> ${value}`);
                        
                        rawData[j][colIdx] = value;
                        updatedCount++;
                        
                        // Determinar el nombre de columna correcto para enviar al backend
                        const sendColName = (rawData[0] && rawData[0][colIdx]) ? rawData[0][colIdx] : colName;
                        
                        // Guardar cambio en el backend
                        fetch(WEB_APP_URL, {
                            method: 'POST',
                            mode: 'no-cors',
                            body: JSON.stringify({
                                action: "update",
                                row: j,
                                colName: sendColName,
                                value: value
                            })
                        }).catch(e => console.error('Error guardando propagación:', e));
                    }
                }
                
                console.log(`✓ Propagación completada: ${updatedCount} filas actualizadas para ${colName} en OP ${currentOP}, serie ${corteBase}xx`);
            } catch (e) {
                console.error('Error en propagateToSameOPAndCorteSeries:', e);
            }
        }

        window.updateRow = function(rowIndex, colName, value, selectElement) {
            console.log('🔄 updateRow llamado:', { rowIndex, colName, value });
            
            if (colName.includes('estado_') || (typeof colName === 'string' && colName.toUpperCase() === 'STATUS')) {
                selectElement.className = "table-select";
                const v = (value || '').toString();
                // Aplicar clases más flexibles: cualquier variante que contenga 'PROG' se considera programado
                if (v.toUpperCase().includes('PROG')) selectElement.classList.add("sel-PROG");
                if (v === "OK") selectElement.classList.add("sel-OK");
                if (v === "EN LAV") selectElement.classList.add("sel-ENLAV");
            }

            // Asegurar que colMap tiene el índice correcto para colName; intentar variantes normalizadas si es necesario
            function findColIndexNormalized(name) {
                if (!rawData || rawData.length === 0) return -1;
                const headers = rawData[0];
                const norm = s => String(s || '').toLowerCase().replace(/[^a-z0-9]/g, '');
                const target = norm(name);
                for (let i = 0; i < headers.length; i++) {
                    if (norm(headers[i]) === target) return i;
                }
                return -1;
            }

            if (colMap[colName] === undefined || colMap[colName] === -1) {
                const found = findColIndexNormalized(colName);
                if (found !== -1) colMap[colName] = found;
            }

            const writeIdx = colMap[colName];

            // Confirmación: si estamos en la vista Bloqueo -> sub-tab PROG
            // y el usuario intenta cambiar 'estado_bloqueo' a 'OK', mostrar modal.
            try {
                if (colName === 'estado_bloqueo' && (value || '').toString().toUpperCase().trim() === 'OK') {
                    const onBloqView = document.getElementById('view-bloqueo') && document.getElementById('view-bloqueo').classList.contains('active');
                    if (onBloqView && currentBloqueoFilter === 'PROG' && !window._skipBloqueoConfirm) {
                        const prev = (writeIdx !== undefined && writeIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][writeIdx]) ? rawData[rowIndex][writeIdx] : '';
                        window._pendingBloqUpdate = { rowIndex, colName, value, selectElement, prev };
                        const modal = document.getElementById('modal-confirm-bloqueo');
                        if (modal) modal.classList.add('active');
                        return; // esperar confirmación
                    }
                }
            } catch (e) { console.error('Error comprobación confirmación bloqueo', e); }

            // Confirmación: en vista Corte -> sub-tabs PROG (1T/2T/3T) al cambiar STATUS_CORTE a OK
            try {
                const vnorm = (value || '').toString().toUpperCase().trim();
                const onCorteViewCheck = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                const isProgSubtabCheck = (currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG');
                const isStatusColCheck = (colName === 'estado_corte' || (typeof colName === 'string' && colName.toUpperCase() === 'STATUS') || (typeof colName === 'string' && colName.toUpperCase().includes('STATUS_CORTE')));

                if (isStatusColCheck && vnorm === 'OK' && onCorteViewCheck && isProgSubtabCheck && !window._skipCorteConfirm) {
                    const prev = (writeIdx !== undefined && writeIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][writeIdx]) ? rawData[rowIndex][writeIdx] : '';
                    window._pendingCorteUpdate = { rowIndex, colName, value, selectElement, prev };
                    const modal = document.getElementById('modal-confirm-corte');
                    if (modal) modal.classList.add('active');
                    return; // esperar confirmación del usuario
                }
            } catch (e) { console.error('Error comprobación confirmación corte', e); }

            // Confirmación: en vista Enumerado al cambiar 'estado_enumerado' a 'OK ENM' o 'OK PAQUETEO'
            try {
                const vEnum = (value || '').toString().toUpperCase().trim();
                if (colName === 'estado_enumerado' && (vEnum === 'OK ENM' || vEnum === 'OK PAQUETEO' || vEnum === 'OK PAQ' || vEnum === 'OK PAQUETEO')) {
                    const onEnumView = document.getElementById('view-enumerado') && document.getElementById('view-enumerado').classList.contains('active');
                    if (onEnumView && !window._skipEnumeradoConfirm) {
                        const prev = (writeIdx !== undefined && writeIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][writeIdx]) ? rawData[rowIndex][writeIdx] : '';
                        window._pendingEnumeradoUpdate = { rowIndex, colName, value, selectElement, prev };
                        const modal = document.getElementById('modal-confirm-enumerado');
                        if (modal) modal.classList.add('active');
                        return; // esperar confirmación
                    }
                }
            } catch (e) { console.error('Error comprobación confirmación enumerado', e); }

            // Validación específica solicitada:
            // En la vista Corte, cuando estamos en sub-tab PROG (1T/2T/3T) y
            // el usuario intenta marcar STATUS_CORTE = 'OK', validar que
            // tanto 'estado_bloques' como 'estado_coll_tap' NO estén en 'LLEVA?'.
            try {
                const valNorm = (value || '').toString().toUpperCase().trim();
                const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                const isProgSubtab = (currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG');

                const isStatusCol = (colName === 'estado_corte' || (typeof colName === 'string' && colName.toUpperCase() === 'STATUS') || (typeof colName === 'string' && colName.toUpperCase().includes('STATUS_CORTE')));

                    // VALIDACIÓN 1: Verificar que tenga equipo_corte al cambiar de X PROG a PROG 1T/2T/3T
                    if (isStatusCol && (valNorm === 'PROG 1T' || valNorm === 'PROG 2T' || valNorm === 'PROG 3T') && onCorteView && currentCorteFilter === 'X PROG') {
                        const equipoCorteIdx = findColIndexNormalized('equipo_corte');
                        const equipoCorte = (equipoCorteIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][equipoCorteIdx]) ? String(rawData[rowIndex][equipoCorteIdx]).trim() : '';
                        
                        if (!equipoCorte || equipoCorte === '') {
                            // Revertir selección visual al valor anterior
                            const prev = (writeIdx !== undefined && writeIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][writeIdx]) ? rawData[rowIndex][writeIdx] : '';
                            try { if (selectElement) selectElement.value = prev; } catch (e) {}
                            try { if (selectElement) { selectElement.style.border = '2px solid #ef4444'; setTimeout(()=>{ selectElement.style.border=''; }, 1600); } } catch(e){}
                            alert('No ha seleccionado un equipo de corte');
                            return; // cancelar guardado
                        }
                    }

                    // VALIDACIÓN 2: Al marcar STATUS_CORTE = 'OK' en sub-tabs PROG
                    // - Primero: impedir si estado_bloqueo o estado_lavada no son 'OK'
                    if (isStatusCol && valNorm === 'OK' && onCorteView && isProgSubtab) {
                        // Obtener valor de RUTA TELA para excepciones (p.ej. ACABADA)
                        const idxRuta = findColIndexNormalized('RUTA TELA');
                        const rutaRaw = (idxRuta !== -1 && rawData[rowIndex] && rawData[rowIndex][idxRuta]) ? String(rawData[rowIndex][idxRuta]).toUpperCase().trim() : '';

                        // Si la ruta es ACABADA, no requerimos que esté OK en estado_lavada;
                        // en ese caso sólo exigimos que BLOQUES y COLL/TAP estén completados
                        let estBloqRaw = '';
                        let estLavRaw = '';
                        if (rutaRaw !== 'ACABADA') {
                            const idxEstBloq = findColIndexNormalized('estado_bloqueo');
                            const idxEstLav = findColIndexNormalized('estado_lavada');
                            estBloqRaw = (idxEstBloq !== -1 && rawData[rowIndex] && rawData[rowIndex][idxEstBloq]) ? String(rawData[rowIndex][idxEstBloq]).toUpperCase().trim() : '';
                            estLavRaw = (idxEstLav !== -1 && rawData[rowIndex] && rawData[rowIndex][idxEstLav]) ? String(rawData[rowIndex][idxEstLav]).toUpperCase().trim() : '';
                        }

                        const needBloquear = (rutaRaw === 'ACABADA') ? false : (estBloqRaw !== 'OK');
                        const needLavar = (rutaRaw === 'ACABADA') ? false : (estLavRaw !== 'OK');

                        if (needBloquear || needLavar) {
                            // Mensaje específico según el caso
                            let msg = '';
                            if (needBloquear && needLavar) msg = 'Por bloquear y por lavar';
                            else if (needBloquear) msg = 'Por bloquear';
                            else msg = 'Por lavar';

                            // Revertir selección visual al valor anterior
                            const prev = (writeIdx !== undefined && writeIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][writeIdx]) ? rawData[rowIndex][writeIdx] : '';
                            try { if (selectElement) selectElement.value = prev; } catch (e) {}
                            try { if (selectElement) { selectElement.style.border = '2px solid #ef4444'; setTimeout(()=>{ selectElement.style.border=''; }, 1600); } } catch(e){}
                            alert(msg);
                            return; // cancelar guardado
                        }

                        // Si pasa la validación anterior, continuar con la validación existente
                        // localizar índices normalizados para las dos columnas
                        const findBestIndexForRow = function(rIdx, names) {
                            // findColIndexNormalized está definido más arriba en este scope
                            // Priorizar la columna existente cuyo valor en la fila no esté vacía
                            for (let n of names) {
                                const idx = findColIndexNormalized(n);
                                if (idx !== -1) {
                                    const cell = (rawData[rIdx] && rawData[rIdx][idx]) ? String(rawData[rIdx][idx]).trim() : '';
                                    if (cell !== '') return idx;
                                }
                            }
                            // Si no hay ninguna no-vacía, devolver la primera columna existente (si existe)
                            for (let n of names) {
                                const idx = findColIndexNormalized(n);
                                if (idx !== -1) return idx;
                            }
                            return -1;
                        };

                        const bloqCandidates = ['ESTADO BLOQUES','ESTADO_BLOQUES','estado_bloques'];
                        const collCandidates = ['ESTADO COLL TAP','ESTADO_COLL_TAP','estado_coll_tap'];

                        const idxBloqFinal = findBestIndexForRow(rowIndex, bloqCandidates);
                        const idxCollFinal = findBestIndexForRow(rowIndex, collCandidates);

                        const bloqVal = (idxBloqFinal !== -1 && rawData[rowIndex] && rawData[rowIndex][idxBloqFinal]) ? String(rawData[rowIndex][idxBloqFinal]).toUpperCase().trim() : '';
                        const collVal = (idxCollFinal !== -1 && rawData[rowIndex] && rawData[rowIndex][idxCollFinal]) ? String(rawData[rowIndex][idxCollFinal]).toUpperCase().trim() : '';

                        // Validar que no estén en 'LLEVA?' O que no estén vacíos
                        if (bloqVal === 'LLEVA?' || collVal === 'LLEVA?' || bloqVal === '' || collVal === '') {
                            // Revertir selección visual al valor anterior y avisar al usuario
                            const prev = (writeIdx !== undefined && writeIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][writeIdx]) ? rawData[rowIndex][writeIdx] : '';
                            try { if (selectElement) selectElement.value = prev; } catch (e) {}
                            try { if (selectElement) { selectElement.style.border = '2px solid #ef4444'; setTimeout(()=>{ selectElement.style.border=''; }, 1600); } } catch(e){}
                            alert('Completar BLOQUES/COLL/TAP');
                            return; // cancelar guardado y propagación
                        }
                    }
            } catch (e) {
                console.error('Error validación OK Corte:', e);
            }

            if (writeIdx !== undefined && writeIdx !== -1) rawData[rowIndex][writeIdx] = value;
            updateCounters();

            console.log('📊 Después de actualizar rawData:', { rowIndex, writeIdx, colName, value, dataSaved: (writeIdx !== undefined && writeIdx !== -1) });

            // --- FIX: asegurar que columnas específicas se actualizan en rawData aunque colMap falle ---
            try {
                const normKey = (colName || '').toString().toLowerCase().replace(/[^a-z0-9]/g, '');
                
                // Para estado_enumerado
                if (normKey === 'estadoenumerado' || colName === 'estado_enumerado') {
                    const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
                    if (idxEv !== -1) {
                        const vNorm = (value || '').toString().trim();
                        rawData[rowIndex][idxEv] = vNorm;
                        colMap['estado_enumerado'] = idxEv;
                        writeIdx = idxEv;
                    }
                }
                
                // Para ESTADO_BLOQUES
                if (normKey === 'estadobloques' || colName === 'ESTADO_BLOQUES' || colName === 'ESTADO BLOQUES' || colName === 'estado_bloques') {
                    const bloqVariants = ['ESTADO_BLOQUES', 'ESTADO BLOQUES', 'estado_bloques', 'ESTADO BLOQUES'];
                    let foundIdx = -1;
                    for (let variant of bloqVariants) {
                        const idx = findColIndexNormalized(variant);
                        if (idx !== -1) {
                            foundIdx = idx;
                            break;
                        }
                    }
                    if (foundIdx !== -1) {
                        rawData[rowIndex][foundIdx] = value;
                        colMap['ESTADO_BLOQUES'] = foundIdx;
                        colMap['ESTADO BLOQUES'] = foundIdx;
                        colMap['estado_bloques'] = foundIdx;
                        writeIdx = foundIdx;
                    }
                }
                
                // Para ESTADO_COLL_TAP
                if (normKey === 'estadocolltap' || colName === 'ESTADO_COLL_TAP' || colName === 'ESTADO COLL TAP' || colName === 'estado_coll_tap') {
                    const collVariants = ['ESTADO_COLL_TAP', 'ESTADO COLL TAP', 'estado_coll_tap', 'ESTADO_COLL_TAP'];
                    let foundIdx = -1;
                    for (let variant of collVariants) {
                        const idx = findColIndexNormalized(variant);
                        if (idx !== -1) {
                            foundIdx = idx;
                            break;
                        }
                    }
                    if (foundIdx !== -1) {
                        rawData[rowIndex][foundIdx] = value;
                        colMap['ESTADO_COLL_TAP'] = foundIdx;
                        colMap['ESTADO COLL TAP'] = foundIdx;
                        colMap['estado_coll_tap'] = foundIdx;
                        writeIdx = foundIdx;
                    }
                }
            } catch (e) { console.error('Error asegurando rawData para columnas especiales', e); }

            // GUARDAR LA FILA ACTUAL INMEDIATAMENTE (antes de propagación)
            // Esto asegura que el cambio de la fila actual se persista aunque haya errores en la propagación
            try {
                if (!WEB_APP_URL) {
                    console.error('❌ WEB_APP_URL no está definido!');
                    return;
                }
                
                let sendColName = colName;
                console.log(`🔍 Determinando nombre de columna para guardar:`, { colName, writeIdx, headerEnRawData: (writeIdx !== undefined && writeIdx !== -1 && rawData[0]) ? rawData[0][writeIdx] : 'NO ENCONTRADO' });
                
                if (writeIdx !== undefined && writeIdx !== -1 && rawData[0] && rawData[0][writeIdx]) {
                    sendColName = rawData[0][writeIdx];
                    console.log(`✓ Usando nombre del header: "${sendColName}"`);
                } else {
                    console.warn(`⚠ writeIdx no válido (${writeIdx}), intentando resolver por normalización...`);
                    // intentar resolver por normalización
                    const found = (function(name){
                        if (!rawData || rawData.length === 0) return -1;
                        const headers = rawData[0];
                        const norm = s => String(s || '').toLowerCase().replace(/[^a-z0-9]/g, '');
                        const target = norm(name);
                        for (let i = 0; i < headers.length; i++) {
                            if (norm(headers[i]) === target) return i;
                        }
                        return -1;
                    })(colName);
                    if (found !== -1 && rawData[0] && rawData[0][found]) {
                        sendColName = rawData[0][found];
                        console.log(`✓ Encontrado por normalización en índice ${found}: "${sendColName}"`);
                    } else {
                        console.error(`❌ No se pudo encontrar el header para "${colName}"`);
                    }
                }

                const payload = {
                    action: "update",
                    row: rowIndex,
                    colName: sendColName,
                    value: value
                };

                console.log(`💾 Guardando fila actual ${rowIndex}:`, payload);
                console.log(`📡 WEB_APP_URL:`, WEB_APP_URL);
                
                fetch(WEB_APP_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: JSON.stringify(payload)
                }).then(() => {
                    console.log(`  ✓ Fetch completado para fila ${rowIndex} (no-cors no permite ver respuesta)`);
                }).catch(e => {
                    console.error(`  ✗ Error en fetch para fila ${rowIndex}:`, e);
                });
            } catch (e) {
                console.error('❌ Error crítico guardando fila actual:', e);
            }

            // PROPAGACIÓN AUTOMÁTICA usando la función mejorada del script de referencia
            try {
                const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                const isProgSubtab = (currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG');
                
                const isRibCol = (colName === 'estado_rib');
                const isBloqCol = (colName === 'ESTADO_BLOQUES' || colName === 'ESTADO BLOQUES' || colName === 'estado_bloques');
                const isCollTapCol = (colName === 'ESTADO_COLL_TAP' || colName === 'ESTADO COLL TAP' || colName === 'estado_coll_tap');
                
                if (onCorteView && isProgSubtab && (isRibCol || isBloqCol || isCollTapCol)) {
                    console.log('🔄 Iniciando propagación automática para', colName);
                    propagateToSameOPAndCorteSeries(rowIndex, colName, value);
                    
                    // Re-renderizar la vista después de un breve delay
                    setTimeout(() => {
                        console.log('♻️ Re-renderizando vista Corte...');
                        renderCorte();
                    }, 300);
                } else {
                    if (isRibCol || isBloqCol || isCollTapCol) {
                        console.log('ℹ️ Propagación no activada:', {
                            razon: !onCorteView ? 'No está en vista Corte' : !isProgSubtab ? 'No está en sub-tab PROG' : 'Condición no cumplida'
                        });
                    }
                }
            } catch (e) {
                console.error('Error en propagación automática de columnas:', e);
            }

            // Loguear intento de guardado para depuración (ver Network/Console)
            try {
                const payloadPreview = { row: rowIndex, colName: (rawData[0] && rawData[0][writeIdx]) ? rawData[0][writeIdx] : colName, value };
                console.log('Sending update to backend (preview):', payloadPreview);
            } catch (e) { console.log('Preview log failed', e); }

            // Si cambiamos el bloqueo a PROG, propagar a todas las filas
            // que tengan el mismo OP-PTDA (OP TELA + PARTIDA).
            if (colName === 'estado_bloqueo') {
                try {
                    if (value === 'PROG' && colMap["OP TELA"] !== undefined && colMap["PARTIDA"] !== undefined) {
                        const opTela = String(rawData[rowIndex][colMap["OP TELA"]] || "").trim().toLowerCase();
                        const partida = String(rawData[rowIndex][colMap["PARTIDA"]] || "").trim().toLowerCase();
                        const key = opTela + "-" + partida;

                        for (let j = 1; j < rawData.length; j++) {
                            if (j === rowIndex) continue;
                            const otherOpTela = String(rawData[j][colMap["OP TELA"]] || "").trim().toLowerCase();
                            const otherPartida = String(rawData[j][colMap["PARTIDA"]] || "").trim().toLowerCase();
                            if ((otherOpTela + "-" + otherPartida) === key) {
                                const prev = rawData[j][colMap['estado_bloqueo']];
                                if (prev !== 'PROG') {
                                    rawData[j][colMap['estado_bloqueo']] = 'PROG';
                                    // Guardar cada cambio en el backend
                                    fetch(WEB_APP_URL, {
                                        method: 'POST',
                                        mode: 'no-cors',
                                        body: JSON.stringify({
                                            action: "update",
                                            row: j,
                                            colName: 'estado_bloqueo',
                                            value: 'PROG'
                                        })
                                    }).catch(e => console.error('Error guardando', e));
                                }
                            }
                        }
                    }
                } catch (err) {
                    console.error('Error propagando PROG:', err);
                }

                // Volver a renderizar las vistas según el nuevo estado de bloqueo
                // Si es PROG, solo necesitamos actualizar Bloqueo (ya propagado a otras filas).
                if (value === 'PROG') {
                    setTimeout(() => renderBloqueo(), 600);
                } else {
                    // Si cambiamos a OK (u otro estado), actualizar todas las vistas relevantes
                    setTimeout(() => {
                        renderBloqueo();
                        renderLavado();
                        renderCorte();
                    }, 600);
                }
            }

            if (colName === 'estado_lavada') {
                setTimeout(() => {
                    renderLavado();
                    renderCorte();
                }, 600);
            }

            if (colName === 'estado_enumerado') {
                // Si cambiamos estado_enumerado, actualizar Enumerado y Habilitado
                setTimeout(() => {
                    renderEnumerado();
                    renderHabilitado();
                }, 600);
            }
            
            if (colName === 'estado_transfer') {
                // Si cambiamos estado_transfer, actualizar Transfer
                setTimeout(() => {
                    renderTransfer();
                }, 600);
            }

            if (colName === 'estado_rib') {
                // Cuando se cambia RIB, re-renderizar Bloqueo para habilitar/deshabilitar el select
                try { setTimeout(() => { renderBloqueo(); }, 200); } catch(e) {}
            }

            if (colName === 'n.transfxpda') {
                // Si cambi el n.transfxpda (por ejemplo a 'NO LLEVA'), actualizar Transfer
                setTimeout(() => {
                    renderTransfer();
                }, 600);
            }
            
            if (colName === 'estado_corte_bloques') {
                // Si cambiamos estado_corte_bloques: comportamiento línea-a-línea.
                // 1) Reflejar inmediatamente el valor seleccionado en la celda (evita que quede invisible)
                // 2) Actualizar contadores locales
                // 3) Seguir guardando en el sheet (petición se envía más abajo como siempre)
                try {
                    if (selectElement) {
                        const txt = (selectElement.options && selectElement.selectedIndex >= 0 && selectElement.options[selectElement.selectedIndex]) ? selectElement.options[selectElement.selectedIndex].text : String(value);
                        const td = selectElement.closest && selectElement.closest('td');
                        if (td) td.innerText = txt;
                    }
                } catch (e) { console.error('Error actualizando UI estado_corte_bloques:', e); }

                try { updateCorteBloquesCounters(); } catch (e) {}

                // Re-renderizar la vista en breve para mantener consistencia visual
                setTimeout(() => {
                    renderCorteBloques();
                }, 600);
            }

            if (colName === 'estado_corte' || (typeof colName === 'string' && colName.toUpperCase() === 'STATUS')) {
                try {
                    // Normalizar nombre de columna para buscar índices
                    const opTelaIdx = (colMap["OP TELA"] !== undefined) ? colMap["OP TELA"] : findColIndexNormalized('OP TELA');
                    const partidaIdx = (colMap["PARTIDA"] !== undefined) ? colMap["PARTIDA"] : findColIndexNormalized('PARTIDA');

                    // Decidir si debemos propagar el cambio a todas las filas con la misma OP-PTDA.
                    // Nuevo comportamiento: si el nuevo valor es 'OK' y el usuario está en la vista Corte
                    // en uno de los sub-tabs PROG (PROG 1T/2T/3T), NO propagar; solo mover la fila actual.
                    const valNorm = (value || '').toString().toUpperCase().trim();
                    const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                    const isProgSubtab = (currentCorteFilter && currentCorteFilter.toString().toUpperCase().startsWith('PROG ') && currentCorteFilter !== 'X PROG');

                    const shouldPropagate = !(valNorm === 'OK' && onCorteView && isProgSubtab);

                    if (shouldPropagate && opTelaIdx !== -1 && partidaIdx !== -1) {
                        const opTelaBase = String(rawData[rowIndex][opTelaIdx] || '').trim().toLowerCase();
                        const partidaBase = String(rawData[rowIndex][partidaIdx] || '').trim().toLowerCase();
                        const key = opTelaBase + '-' + partidaBase;

                        // Obtener el equipo_corte de la fila actual para propagarlo también
                        const equipoCorteIdx = findColIndexNormalized('equipo_corte');
                        const equipoCorteValue = (equipoCorteIdx !== -1 && rawData[rowIndex] && rawData[rowIndex][equipoCorteIdx]) ? rawData[rowIndex][equipoCorteIdx] : '';

                        for (let j = 1; j < rawData.length; j++) {
                            if (j === rowIndex) continue;
                            const otherOp = String(rawData[j][opTelaIdx] || '').trim().toLowerCase();
                            const otherPart = String(rawData[j][partidaIdx] || '').trim().toLowerCase();
                            if ((otherOp + '-' + otherPart) === key) {
                                const prev = rawData[j][writeIdx];
                                if (prev !== value) {
                                    rawData[j][writeIdx] = value;
                                    // Guardar el cambio en backend (no-cors). Usar colName tal cual fue pasado (STATUS o estado_corte)
                                    fetch(WEB_APP_URL, {
                                        method: 'POST',
                                        mode: 'no-cors',
                                        body: JSON.stringify({ action: 'update', row: j, colName: colName, value: value })
                                    }).catch(e => console.error('Error guardando propagado estado_corte', e));
                                }
                                
                                // Propagar también el equipo_corte si estamos en sub-tab X PROG
                                if (onCorteView && currentCorteFilter === 'X PROG' && equipoCorteIdx !== -1 && equipoCorteValue) {
                                    const prevEquipo = rawData[j][equipoCorteIdx];
                                    if (prevEquipo !== equipoCorteValue) {
                                        rawData[j][equipoCorteIdx] = equipoCorteValue;
                                        // Guardar el cambio de equipo_corte en backend
                                        fetch(WEB_APP_URL, {
                                            method: 'POST',
                                            mode: 'no-cors',
                                            body: JSON.stringify({ action: 'update', row: j, colName: 'equipo_corte', value: equipoCorteValue })
                                        }).catch(e => console.error('Error guardando propagado equipo_corte', e));
                                    }
                                }
                            }
                        }
                    }

                    // Determinar comportamiento según nuevo valor: si es OK -> mostrar Enumerado,
                    // si es un PROG -> ir a Corte y seleccionar sub-tab correspondiente.
                    const tabMap = {
                        'X PROG': 'corte-btn-xprog',
                        'PROG 1T': 'corte-btn-1t',
                        'PROG 2T': 'corte-btn-2t',
                        'PROG 3T': 'corte-btn-3t'
                    };

                    if (valNorm === 'OK') {
                        // Si el cambio a OK se realizó desde un sub-tab de Corte PROG (1T/2T/3T),
                        // mantener la vista y el sub-tab actuales para no desorientar al usuario
                        // y NO propagar (comportamiento aplicado arriba).
                        if (onCorteView && isProgSubtab) {
                            setTimeout(() => { renderEnumerado(); renderCorte(); }, 600);
                        } else {
                            // Seleccionar la vista Enumerado si existe
                            let enumBtn = null;
                            document.querySelectorAll('.nav-tab').forEach(nb => {
                                const onclickAttr = nb.getAttribute('onclick') || '';
                                if (onclickAttr.indexOf("switchView('enumerado'") !== -1) enumBtn = nb;
                            });
                            if (enumBtn) switchView('enumerado', enumBtn);
                            setTimeout(() => { renderEnumerado(); renderCorte(); }, 600);
                        }
                    } else {
                        // Ir a Corte y seleccionar sub-tab correspondiente
                        const btnId = tabMap[valNorm] || tabMap['X PROG'];
                        const subBtn = document.getElementById(btnId);

                        let mainNavBtn = null;
                        document.querySelectorAll('.nav-tab').forEach(nb => {
                            const onclickAttr = nb.getAttribute('onclick') || '';
                            if (onclickAttr.indexOf("switchView('corte'") !== -1) mainNavBtn = nb;
                        });
                        if (mainNavBtn) switchView('corte', mainNavBtn);

                        if (subBtn) {
                            filterCorte(valNorm, subBtn);
                        } else {
                            setTimeout(() => { renderCorte(); }, 600);
                        }
                    }
                } catch (err) {
                    console.error('Error al propagar estado_corte:', err);
                    setTimeout(() => {
                        renderCorte();
                        renderEnumerado();
                    }, 600);
                }
            }

            // Propagar equipo_corte cuando se cambia en sub-tab X PROG
            if (colName === 'equipo_corte') {
                try {
                    const onCorteView = document.getElementById('view-corte') && document.getElementById('view-corte').classList.contains('active');
                    
                    // Solo propagar si estamos en vista Corte y sub-tab X PROG
                    if (onCorteView && currentCorteFilter === 'X PROG') {
                        const opTelaIdx = (colMap["OP TELA"] !== undefined) ? colMap["OP TELA"] : findColIndexNormalized('OP TELA');
                        const partidaIdx = (colMap["PARTIDA"] !== undefined) ? colMap["PARTIDA"] : findColIndexNormalized('PARTIDA');
                        
                        if (opTelaIdx !== -1 && partidaIdx !== -1) {
                            const opTelaBase = String(rawData[rowIndex][opTelaIdx] || '').trim().toLowerCase();
                            const partidaBase = String(rawData[rowIndex][partidaIdx] || '').trim().toLowerCase();
                            const key = opTelaBase + '-' + partidaBase;
                            
                            for (let j = 1; j < rawData.length; j++) {
                                if (j === rowIndex) continue;
                                const otherOp = String(rawData[j][opTelaIdx] || '').trim().toLowerCase();
                                const otherPart = String(rawData[j][partidaIdx] || '').trim().toLowerCase();
                                
                                if ((otherOp + '-' + otherPart) === key) {
                                    const prev = rawData[j][writeIdx];
                                    if (prev !== value) {
                                        rawData[j][writeIdx] = value;
                                        // Guardar el cambio en backend
                                        fetch(WEB_APP_URL, {
                                            method: 'POST',
                                            mode: 'no-cors',
                                            body: JSON.stringify({ action: 'update', row: j, colName: 'equipo_corte', value: value })
                                        }).catch(e => console.error('Error guardando propagado equipo_corte', e));
                                    }
                                }
                            }
                        }
                    }
                    
                    // Re-renderizar la vista Corte después de propagar
                    setTimeout(() => { renderCorte(); }, 600);
                } catch (err) {
                    console.error('Error propagando equipo_corte:', err);
                    setTimeout(() => { renderCorte(); }, 600);
                }
            }

            // El guardado de la fila actual ya se realizó antes de la propagación (arriba)
            // para asegurar que siempre se persista incluso si hay errores en la propagación
        };

        // Estado y handlers para confirmación de Bloqueo->OK en Bloqueo->PROG
        window._pendingBloqUpdate = null;
        window._skipBloqueoConfirm = false;

        function cerrarModalConfirmBloq() {
            const m = document.getElementById('modal-confirm-bloqueo');
            if (m) m.classList.remove('active');
        }

        window.handleConfirmBloq = function(confirmed) {
            const pending = window._pendingBloqUpdate;
            const modal = document.getElementById('modal-confirm-bloqueo');
            if (!pending) { if (modal) modal.classList.remove('active'); return; }

            if (!confirmed) {
                try { if (pending.selectElement) pending.selectElement.value = pending.prev; } catch(e){}
                if (modal) modal.classList.remove('active');
                window._pendingBloqUpdate = null;
                return;
            }

            // Ejecutar la actualización real evitando volver a pedir confirmación
            window._pendingBloqUpdate = null;
            window._skipBloqueoConfirm = true;
            if (modal) modal.classList.remove('active');
            try {
                // Llamar nuevamente a updateRow pero con la bandera para omitir confirmación
                window.updateRow(pending.rowIndex, pending.colName, pending.value, pending.selectElement);
            } catch (e) { console.error('Error aplicando cambio confirmado:', e); }
            setTimeout(() => { window._skipBloqueoConfirm = false; }, 50);
        };

        function cerrarModalConfirmBloqAlias() { cerrarModalConfirmBloq(); }

        // Estado y handlers para confirmación de Corte STATUS->OK en sub-tabs PROG
        window._pendingCorteUpdate = null;
        window._skipCorteConfirm = false;

        // Estado y handlers para confirmación Enumerado
        window._pendingEnumeradoUpdate = null;
        window._skipEnumeradoConfirm = false;

        function cerrarModalConfirmEnumerado() {
            const m = document.getElementById('modal-confirm-enumerado');
            if (m) m.classList.remove('active');
        }

        window.handleConfirmEnumerado = function(confirmed) {
            const pending = window._pendingEnumeradoUpdate;
            const modal = document.getElementById('modal-confirm-enumerado');
            if (!pending) { if (modal) modal.classList.remove('active'); return; }

            if (!confirmed) {
                try { if (pending.selectElement) pending.selectElement.value = pending.prev; } catch(e){}
                if (modal) modal.classList.remove('active');
                window._pendingEnumeradoUpdate = null;
                return;
            }

            // Aplicar cambio confirmado evitando reabrir el modal
            window._pendingEnumeradoUpdate = null;
            window._skipEnumeradoConfirm = true;
            if (modal) modal.classList.remove('active');
            try { window.updateRow(pending.rowIndex, pending.colName, pending.value, pending.selectElement); } catch (e) { console.error('Error aplicando cambio confirmado Enumerado:', e); }
            setTimeout(() => { window._skipEnumeradoConfirm = false; }, 50);
        };

        function cerrarModalConfirmCorte() {
            const m = document.getElementById('modal-confirm-corte');
            if (m) m.classList.remove('active');
        }

        window.handleConfirmCorte = function(confirmed) {
            const pending = window._pendingCorteUpdate;
            const modal = document.getElementById('modal-confirm-corte');
            if (!pending) { if (modal) modal.classList.remove('active'); return; }

            if (!confirmed) {
                try { if (pending.selectElement) pending.selectElement.value = pending.prev; } catch(e){}
                if (modal) modal.classList.remove('active');
                window._pendingCorteUpdate = null;
                return;
            }

            // Aplicar cambio confirmado evitando reabrir el modal
            window._pendingCorteUpdate = null;
            window._skipCorteConfirm = true;
            if (modal) modal.classList.remove('active');
            try { window.updateRow(pending.rowIndex, pending.colName, pending.value, pending.selectElement); } catch (e) { console.error('Error aplicando cambio confirmado Corte:', e); }
            setTimeout(() => { window._skipCorteConfirm = false; }, 50);
        };

        // Estado y handlers para Lavadora (modal + confirm)
        window._pendingWasherUpdate = null;

        function abrirModalLavado(rowIndex) {
            try {
                const row = rawData[rowIndex] || [];
                const estado = getVal(row, 'estado_lavada') || '';
                const ruta = getVal(row, 'RUTA TELA') || getVal(row, 'RUTA') || '';
                const opTela = String(getVal(row, 'OP TELA') || '').trim();
                const partida = String(getVal(row, 'PARTIDA') || '').trim();
                const opPtda = `${opTela}-${partida}`;

                document.getElementById('modal-lavadora-title').innerText = `OP-PTDA: ${opPtda}`;
                document.getElementById('modal-lavadora-sub').innerText = `Estado actual: ${estado || '(vacío)'}`;
                document.getElementById('modal-lavadora-ruta').innerText = ruta || '-';
                const sel = document.getElementById('modal-lavadora-select');
                if (sel) sel.value = '';

                window._pendingWasherUpdate = { rowIndex, prev: estado };
                const m = document.getElementById('modal-lavadora');
                if (m) m.classList.add('active');
            } catch (e) { console.error('Error abriendo modal lavadora', e); }
        }

        function cerrarModalLavado() {
            const m = document.getElementById('modal-lavadora');
            if (m) m.classList.remove('active');
            // limpiar pending
            window._pendingWasherUpdate = null;
        }

        function onModalLavadoraApply() {
            try {
                const sel = document.getElementById('modal-lavadora-select');
                if (!sel) return;
                const val = sel.value || '';
                if (val === '') { alert('Seleccione una opción.'); return; }
                // Abrir modal de confirmación
                const modal = document.getElementById('modal-confirm-washer');
                window._pendingWasherUpdate = window._pendingWasherUpdate || {};
                window._pendingWasherUpdate.value = val;
                if (modal) modal.classList.add('active');
            } catch (e) { console.error('Error aplicando en modal lavadora', e); }
        }

        function cerrarModalConfirmWasher() {
            const m = document.getElementById('modal-confirm-washer');
            if (m) m.classList.remove('active');
        }

        function handleConfirmWasher(confirmed) {
            const pending = window._pendingWasherUpdate;
            const modal = document.getElementById('modal-confirm-washer');
            if (!pending) { if (modal) modal.classList.remove('active'); return; }

            if (!confirmed) {
                if (modal) modal.classList.remove('active');
                // keep modal lavadora open so user can choose again
                return;
            }

            // Confirmado: escribir en estado_lavada
            try {
                if (modal) modal.classList.remove('active');
                const rowIndex = pending.rowIndex;
                const value = pending.value || 'EN LAV';
                // Crear un elemento temporal para pasar como selectElement (updateRow espera un elemento DOM)
                try {
                    const fake = document.createElement('select');
                    fake.className = 'table-select';
                    window.updateRow(rowIndex, 'estado_lavada', value, fake);
                } catch (e) { console.error('Error actualizando estado_lavada', e); }
            } catch (e) { console.error('Error en handleConfirmWasher', e); }
            // Cerrar modal de edición
            cerrarModalLavado();
            window._pendingWasherUpdate = null;
        }

        window.switchView = function(viewName, btn) {
            document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.nav-tab').forEach(el => el.classList.remove('active'));
            document.getElementById(`view-${viewName}`).classList.add('active');
            btn.classList.add('active');
            // Re-render the view we just activated so dynamic row content
            // (selects shown for Enumerado or Corte sub-tabs) is created
            // while the view has the 'active' class.
            try {
                if (viewName === 'bloqueo') renderBloqueo();
                else if (viewName === 'lavado') renderLavado();
                else if (viewName === 'corte') renderCorte();
                else if (viewName === 'corte-bloques') renderCorteBloques();
                else if (viewName === 'enumerado') renderEnumerado();
                else if (viewName === 'transfer') renderTransfer();
                else if (viewName === 'artes') renderArtes();
                else if (viewName === 'habilitado') renderHabilitado();
            } catch (e) { console.error('Error re-rendering view after switch:', e); }
        };

        window.filterBloqueo = function(filterState, btn) {
            currentBloqueoFilter = filterState;
            document.querySelectorAll('#view-bloqueo .sub-tab').forEach(el => el.classList.remove('active'));
            btn.classList.add('active');
            renderBloqueo();
        };

        window.filterLavado = function(filterState, btn) {
            currentLavadoFilter = filterState;
            document.querySelectorAll('#view-lavado .sub-tab').forEach(el => el.classList.remove('active'));
            btn.classList.add('active');
            renderLavado();
        };

        window.filterCorte = function(filterState, btn) {
            currentCorteFilter = filterState;
            document.querySelectorAll('#view-corte .sub-tab').forEach(el => el.classList.remove('active'));
            btn.classList.add('active');
                    // Mostrar/ocultar filtros por RUTA solo cuando estemos en 'Por Programar' (X PROG)
                    try {
                        const filtEl = document.getElementById('corte-route-filters');
                        if (filtEl) filtEl.style.display = (filterState === 'X PROG') ? 'flex' : 'none';
                    } catch (e) {}
                    // EQ_Corte button removed; nothing to show/hide here.
                    renderCorte();
        };

        // Filter for Corte Bloques (X PROG o PROG)
        window.filterCorteBloques = function(filterState, btn) {
            currentCorteBloquesFilter = filterState;
            document.querySelectorAll('#view-corte-bloques .sub-tab').forEach(el => el.classList.remove('active'));
            if (btn) btn.classList.add('active');
            renderCorteBloques();
        };

        window.filterTransfer = function(filterState, btn) {
            currentTransferFilter = filterState;
            document.querySelectorAll('#view-transfer .sub-tab').forEach(el => el.classList.remove('active'));
            if (btn) btn.classList.add('active');
            
            // Mostrar/ocultar contenedores según el sub-tab
            const normalContainer = document.getElementById('table-container-transfer-normal');
            const asignarContainer = document.getElementById('table-container-transfer-asignar');
            const asignarFilters = document.getElementById('transfer-asignar-filters');
            
            if (filterState === 'ASIGNAR') {
                if (normalContainer) normalContainer.style.display = 'none';
                if (asignarContainer) asignarContainer.style.display = 'block';
                if (asignarFilters) asignarFilters.style.display = 'flex';
                renderTransferAsignar();
            } else {
                if (normalContainer) normalContainer.style.display = 'block';
                if (asignarContainer) asignarContainer.style.display = 'none';
                if (asignarFilters) asignarFilters.style.display = 'none';
                renderTransfer();
            }
        };

        window.filterBordado = function(filterState, btn) {
            window.currentArtesBordadoFilter = filterState;
            document.querySelectorAll('#bordado-subtabs .sub-tab').forEach(el => el.classList.remove('active'));
            if (btn) btn.classList.add('active');
            renderArtesBordado();
        };

        window.currentArtesEstampadoFilter = 'X PROG';
        window.filterEstampado = function(filterState, btn) {
            window.currentArtesEstampadoFilter = filterState;
            document.querySelectorAll('#estampado-subtabs .sub-tab').forEach(el => el.classList.remove('active'));
            if (btn) btn.classList.add('active');
            renderArtesEstampado();
        };

        window.renderTransferAsignar = function() {
            const tbody = document.getElementById('tbody-transfer-asignar');
            if (!tbody) return;
            tbody.innerHTML = '';
            
            // Obtener valores de filtros
            const filterHayDato = document.getElementById('filter-transfer-haydato')?.value || '';
            const filterCliente = document.getElementById('filter-transfer-cliente')?.value || '';
            const filterEstilo = document.getElementById('filter-transfer-estilo')?.value || '';
            
            // Poblar opciones de filtros si están vacíos
            const selectCliente = document.getElementById('filter-transfer-cliente');
            const selectEstilo = document.getElementById('filter-transfer-estilo');
            
            if (selectCliente && selectCliente.options.length <= 1) {
                const clientes = new Set();
                for (let i = 1; i < rawData.length; i++) {
                    const clienteRaw = getVal(rawData[i], 'CLIENTE');
                    const cliente = normalizeClientForTransfer(clienteRaw);
                    if (cliente) clientes.add(cliente);
                }
                Array.from(clientes).sort().forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c;
                    opt.textContent = c;
                    selectCliente.appendChild(opt);
                });
            }
            
            if (selectEstilo) {
                // Reconstruir siempre la lista de estilos según el cliente seleccionado
                selectEstilo.innerHTML = '';
                const defaultOpt = document.createElement('option');
                defaultOpt.value = '';
                defaultOpt.textContent = 'Todos los estilos';
                selectEstilo.appendChild(defaultOpt);

                const estilos = new Set();
                for (let i = 1; i < rawData.length; i++) {
                    const row = rawData[i];
                    const clienteRow = getVal(row, 'CLIENTE');
                    const clienteNorm = normalizeClientForTransfer(clienteRow);
                    // Si hay filtro por cliente, sólo recolectar estilos de ese cliente
                    if (filterCliente && clienteNorm !== filterCliente) continue;
                    const estilo = getVal(row, 'ESTILO');
                    if (estilo) estilos.add(estilo);
                }
                Array.from(estilos).sort().forEach(e => {
                    const opt = document.createElement('option');
                    opt.value = e;
                    opt.textContent = e;
                    selectEstilo.appendChild(opt);
                });

                // Si el estilo actualmente seleccionado ya no existe, resetearlo
                if (filterEstilo) {
                    const exists = Array.from(selectEstilo.options).some(o => o.value === filterEstilo);
                    if (!exists) selectEstilo.value = '';
                    else selectEstilo.value = filterEstilo;
                } else {
                    selectEstilo.value = '';
                }
            }
            
            // Agrupar por CLIENTE + ESTILO único y acumular datos
            const grupoMap = new Map(); // "cliente|estilo" -> { cliente, estilo, totalPds, nTransfValues, rowIndices }
            
            // Buscar índice de n.transfxpda de forma case-insensitive
            let idxNTransf = findHeaderIndexCaseInsensitive('n.transfxpda');
            // Si no se encuentra, intentar con variantes
            if (idxNTransf === -1) idxNTransf = findHeaderIndexCaseInsensitive('ntransfxpda');
            if (idxNTransf === -1) idxNTransf = findHeaderIndexCaseInsensitive('n_transfxpda');
            // Si aún no se encuentra, buscar usando colMap o getColIndex
            if (idxNTransf === -1) idxNTransf = colMap['n.transfxpda'] || colMap['N.TRANSFXPDA'] || -1;
            if (idxNTransf === -1) idxNTransf = getColIndex('n.transfxpda');
            
            // DEBUG TEMPORAL: Mostrar valores crudos de la columna n.transfxpda para ATHLETA
            console.log('=== DEBUG ATHLETA n.transfxpda ===');
            console.log('idxNTransf:', idxNTransf);
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const clienteRaw = (row[3] || '').toString();
                if (clienteRaw.toUpperCase().includes('ATHLETA')) {
                    console.log('Fila', i, '| Cliente:', clienteRaw, '| Estilo:', row[13], '| n.transfxpda (col U/20):', row[20], '| rawData[i][idxNTransf]:', row[idxNTransf]);
                }
            }
            console.log('=================================');
            
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const clienteRaw = getVal(row, 'CLIENTE') || '';
                const cliente = normalizeClientForTransfer(clienteRaw);
                const estilo = getVal(row, 'ESTILO') || '';
                const pds = parseFloat(getVal(row, 'PDS')) || 0;
                
                // Obtener n.transfxpda usando el índice encontrado
                let nTransf = '';
                if (idxNTransf !== -1 && row[idxNTransf] !== undefined && row[idxNTransf] !== null) {
                    nTransf = String(row[idxNTransf]).trim();
                }

                // Obtener tipo-transfer (valor por fila)
                const tipoTransfRaw = (getVal(row, 'tipo-transfer') || getVal(row, 'tipo_transfer') || getVal(row, 'TIPO-TRANSFER')) || '';

                // Aplicar filtros
                if (filterCliente && cliente !== filterCliente) continue;
                if (filterEstilo && estilo !== filterEstilo) continue;
                
                if (!estilo) continue;

                const key = cliente + '|' + estilo;
                if (!grupoMap.has(key)) {
                    grupoMap.set(key, {
                        cliente: cliente,
                        estilo: estilo,
                        totalPds: 0,
                        nTransfValues: [],
                        tipoValues: [],
                        rowIndices: []
                    });
                }
                
                const data = grupoMap.get(key);
                data.totalPds += pds;
                data.rowIndices.push(i);
                // Recopilar todos los valores de n.transfxpda
                // Incluir valores numéricos (1, 2, 3...) y "NO LLEVA", excluir vacíos y "LLEVA?"
                const nTransfUpper = nTransf.toUpperCase();
                if (nTransf !== '' && nTransfUpper !== 'LLEVA?') {
                    data.nTransfValues.push(nTransf);
                }
                // Recopilar valores de tipo-transfer para el grupo
                const tipoNorm = (tipoTransfRaw || '').toString().trim();
                if (tipoNorm !== '') data.tipoValues.push(tipoNorm);
            }
            
            // Función para calcular el valor representativo de n.transfxpda
            function calcularNTransfRepresentativo(values) {
                if (!values || values.length === 0) return '';
                
                // Si algún valor contiene "NO LLEVA", retornar "NO LLEVA"
                const hasNoLleva = values.some(v => String(v).toUpperCase().includes('NO LLEVA'));
                if (hasNoLleva) return 'NO LLEVA';
                
                // Filtrar solo valores numéricos
                const numericValues = values
                    .map(v => parseFloat(v))
                    .filter(v => !isNaN(v));
                
                if (numericValues.length === 0) {
                    // Si no hay valores numéricos, retornar el primer valor o vacío
                    return values[0] || '';
                }
                
                // Calcular promedio y redondear al entero más cercano
                const promedio = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;
                const promedioRedondeado = Math.round(promedio);
                
                return String(promedioRedondeado);
            }
            
            // Convertir grupoMap a estiloMap para compatibilidad con el código existente
            const estiloMap = new Map();
            grupoMap.forEach((data, key) => {
                // Usar la función avgTransfByClienteEstilo existente para mayor consistencia
                let nTransfCalculado = avgTransfByClienteEstilo(data.cliente, data.estilo);
                // Si avgTransfByClienteEstilo retorna null, usar el valor calculado localmente como fallback
                if (nTransfCalculado === null) {
                    nTransfCalculado = calcularNTransfRepresentativo(data.nTransfValues);
                }
                // Determinar valor representativo de tipo-transfer para el grupo
                const uniqueTipos = Array.from(new Set((data.tipoValues || []).filter(v => v && v.toString().trim() !== '')));
                const tipoRepresentativo = (uniqueTipos.length === 1) ? uniqueTipos[0] : '';

                // Incluir aquí también grupos con 'NO LLEVA' — este render es para "Asignar #Trf"
                estiloMap.set(key, {
                    cliente: data.cliente,
                    estilo: data.estilo,
                    totalPds: data.totalPds,
                    nTransf: nTransfCalculado || '',
                    tipoTransf: tipoRepresentativo,
                    rowIndices: data.rowIndices
                });
            });
            
            // Renderizar filas agrupadas por CLIENTE + ESTILO
            Array.from(estiloMap.entries()).sort((a, b) => {
                // Ordenar por cliente primero, luego por estilo
                const clienteA = a[1].cliente || '';
                const clienteB = b[1].cliente || '';
                if (clienteA !== clienteB) return clienteA.localeCompare(clienteB);
                return (a[1].estilo || '').localeCompare(b[1].estilo || '');
            }).forEach(([key, data]) => {
                // Aplicar filtro nuevo: Todos / Con dato / Sin dato
                if (filterHayDato === 'CON') {
                    if (!data.nTransf || String(data.nTransf).trim() === '') return;
                } else if (filterHayDato === 'SIN') {
                    if (data.nTransf && String(data.nTransf).trim() !== '') return;
                }
                const tr = document.createElement('tr');

                // CLIENTE
                const tdCliente = document.createElement('td');
                tdCliente.textContent = data.cliente;
                tr.appendChild(tdCliente);
                
                // ESTILO
                const tdEstilo = document.createElement('td');
                tdEstilo.innerHTML = `<strong>${data.estilo}</strong>`;
                tr.appendChild(tdEstilo);
                // tipo-transfer (valor representativo del grupo) -> mostrar select editable
                const tdTipo = document.createElement('td');
                const selTipo = document.createElement('select');
                selTipo.className = 'table-select sel-tipo-transfer';
                selTipo.setAttribute('data-cliente', data.cliente);
                selTipo.setAttribute('data-estilo', data.estilo);
                // Opciones: LLEVA? (por defecto), NO LLEVA, En pieza, En prenda
                selTipo.innerHTML = `
                    <option value="LLEVA?" ${!data.tipoTransf || data.tipoTransf === 'LLEVA?' ? 'selected' : ''}>LLEVA?</option>
                    <option value="NO LLEVA" ${data.tipoTransf === 'NO LLEVA' ? 'selected' : ''}>NO LLEVA</option>
                    <option value="En pieza" ${data.tipoTransf === 'En pieza' ? 'selected' : ''}>En pieza</option>
                    <option value="En prenda" ${data.tipoTransf === 'En prenda' ? 'selected' : ''}>En prenda</option>
                `;
                selTipo.onchange = function() {
                    handleTipoTransferChange(this);
                };
                tdTipo.appendChild(selTipo);
                tr.appendChild(tdTipo);

                // n.transfxpda (select editable para todo el CLIENTE + ESTILO)
                const tdTransf = document.createElement('td');
                const sel = document.createElement('select');
                sel.className = 'table-select sel-ntransf-transfer';
                sel.setAttribute('data-cliente', data.cliente);
                sel.setAttribute('data-estilo', data.estilo);
                sel.onchange = function() {
                    handleNTransfChange(this);
                };
                // Normalize nTransf to avoid mismatches due to case or surrounding whitespace
                const nValNorm = (data.nTransf || '').toString().toUpperCase().trim();
                sel.innerHTML = `
                    <option value="LLEVA?" ${(nValNorm === '' || nValNorm === 'LLEVA?') ? 'selected' : ''}>LLEVA?</option>
                    <option value="NO LLEVA" ${(nValNorm.indexOf('NO LLEVA') !== -1) ? 'selected' : ''}>NO LLEVA</option>
                    <option value="1" ${(nValNorm === '1') ? 'selected' : ''}>1</option>
                    <option value="2" ${(nValNorm === '2') ? 'selected' : ''}>2</option>
                    <option value="3" ${(nValNorm === '3') ? 'selected' : ''}>3</option>
                    <option value="4" ${(nValNorm === '4') ? 'selected' : ''}>4</option>
                    <option value="5" ${(nValNorm === '5') ? 'selected' : ''}>5</option>
                `;
                tdTransf.appendChild(sel);
                tr.appendChild(tdTransf);
                
                tbody.appendChild(tr);
            });
        };

        // Función para actualizar todas las filas de un CLIENTE + ESTILO específico
        window.updateClienteEstiloTransfer = function(cliente, estilo, value, selectElement) {
            if (!cliente || !estilo) return;
            
            // Buscar índice de n.transfxpda de forma flexible
            let idx = findHeaderIndexCaseInsensitive('n.transfxpda');
            if (idx === -1) idx = colMap['n.transfxpda'];
            if (idx === -1 || idx === undefined) idx = colMap['N.TRANSFXPDA'];
            if (idx === -1 || idx === undefined) idx = getColIndex('n.transfxpda');
            
            if (idx === -1 || idx === undefined) {
                alert('Error: No se encontró la columna n.transfxpda');
                return;
            }
            
            // Recopilar los índices de las filas a actualizar
            const rowsToUpdate = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const rowClienteRaw = getVal(row, 'CLIENTE') || '';
                const rowCliente = normalizeClientForTransfer(rowClienteRaw);
                const rowEstilo = getVal(row, 'ESTILO');
                
                if (rowCliente === cliente && rowEstilo === estilo) {
                    rowsToUpdate.push(i);
                    // Actualizar en rawData localmente
                    rawData[i][idx] = value;
                }
            }
            
            if (rowsToUpdate.length === 0) {
                alert('No se encontraron filas para actualizar');
                return;
            }
            
            // Deshabilitar el select mientras se guarda
            if (selectElement) selectElement.disabled = true;
            
            // Enviar actualizaciones individuales al backend usando action: 'update'
            let completedCount = 0;
            const totalCount = rowsToUpdate.length;
            
            rowsToUpdate.forEach((rowIndex, i) => {
                // Pequeño delay para no saturar el servidor
                setTimeout(() => {
                    fetch(WEB_APP_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'update',
                            row: rowIndex,
                            colName: 'n.transfxpda',
                            value: value
                        })
                    }).then(() => {
                        completedCount++;
                        if (completedCount === totalCount) {
                            if (selectElement) selectElement.disabled = false;
                            updateCounters();
                            renderTransfer();
                            // Also refresh the 'Asignar #Trf' table if visible so the select reflects the new value
                            try { renderTransferAsignar(); } catch(e) { /* ignore if not present */ }
                        }
                    }).catch(err => {
                        console.error('Error al guardar fila', rowIndex, err);
                        completedCount++;
                        if (completedCount === totalCount) {
                            if (selectElement) selectElement.disabled = false;
                        }
                    });
                }, i * 100); // 100ms de delay entre cada petición
            });
        };

        window.guardarCambiosAsignarTransfer = function() {
            alert('Los cambios se guardan automáticamente al seleccionar un valor para cada estilo.');
        };

        // --- ARTES (Pza) : filtros y renderizado ---
        window.currentArtesFilter = 'BORDADO';
        window.currentArtesBordadoFilter = 'X PROG';

        window.filterArtes = function(filterState, btn) {
            window.currentArtesFilter = filterState;
            document.querySelectorAll('#view-artes .sub-tab').forEach(el => el.classList.remove('active'));
            if (btn) btn.classList.add('active');

            // Mostrar/ocultar subtabs de Bordado/Estampado según la pestaña activa
            try {
                const bordadoSubs = document.getElementById('bordado-subtabs');
                const estampadoSubs = document.getElementById('estampado-subtabs');
                if (filterState === 'BORDADO') { if (bordadoSubs) bordadoSubs.style.display = 'flex'; if (estampadoSubs) estampadoSubs.style.display = 'none'; }
                else if (filterState === 'ESTAMPADO') { if (bordadoSubs) bordadoSubs.style.display = 'none'; if (estampadoSubs) estampadoSubs.style.display = 'flex'; }
                else if (filterState === 'ASIGNAR') { if (bordadoSubs) bordadoSubs.style.display = 'none'; if (estampadoSubs) estampadoSubs.style.display = 'none'; }
                else { if (bordadoSubs) bordadoSubs.style.display = 'flex'; if (estampadoSubs) estampadoSubs.style.display = 'none'; }
            } catch(e) {}

            const bordadoContainer = document.getElementById('table-container-artes-bordado');
            const estampadoContainer = document.getElementById('table-container-artes-estampado');
            const asignarContainer = document.getElementById('table-container-artes-asignar');
            const asignarFilters = document.getElementById('artes-asignar-filters');

            if (filterState === 'ASIGNAR') {
                if (bordadoContainer) bordadoContainer.style.display = 'none';
                if (estampadoContainer) estampadoContainer.style.display = 'none';
                if (asignarContainer) asignarContainer.style.display = 'block';
                if (asignarFilters) asignarFilters.style.display = 'flex';
                renderArtesAsignar();
            } else if (filterState === 'ESTAMPADO') {
                if (bordadoContainer) bordadoContainer.style.display = 'none';
                if (estampadoContainer) estampadoContainer.style.display = 'block';
                if (asignarContainer) asignarContainer.style.display = 'none';
                if (asignarFilters) asignarFilters.style.display = 'none';
                // Asegurar que el sub-tab interno de Estampado muestre el estado "activo"
                try {
                    const subs = document.querySelectorAll('#estampado-subtabs .sub-tab');
                    subs.forEach(el => el.classList.remove('active'));
                    const btnId = (window.currentArtesEstampadoFilter && window.currentArtesEstampadoFilter.toUpperCase().indexOf('PROG') !== -1 && window.currentArtesEstampadoFilter.toUpperCase() !== 'X PROG') ? 'btn-estampado-prog' : 'btn-estampado-xprog';
                    const btn = document.getElementById(btnId);
                    if (btn) btn.classList.add('active');
                } catch(e) {}
                renderArtesEstampado();
            } else {
                if (bordadoContainer) bordadoContainer.style.display = 'block';
                if (estampadoContainer) estampadoContainer.style.display = 'none';
                if (asignarContainer) asignarContainer.style.display = 'none';
                if (asignarFilters) asignarFilters.style.display = 'none';
                // Asegurar que el sub-tab interno de Bordado muestre el estado "activo"
                try {
                    const subs = document.querySelectorAll('#bordado-subtabs .sub-tab');
                    subs.forEach(el => el.classList.remove('active'));
                    const btnId = (window.currentArtesBordadoFilter && window.currentArtesBordadoFilter.toUpperCase().indexOf('PROG') !== -1 && window.currentArtesBordadoFilter.toUpperCase() !== 'X PROG') ? 'btn-bordado-prog' : 'btn-bordado-xprog';
                    const btn = document.getElementById(btnId);
                    if (btn) btn.classList.add('active');
                } catch(e) {}
                renderArtesBordado();
            }
        };

        window.renderArtes = function() {
            if (window.currentArtesFilter === 'ASIGNAR') renderArtesAsignar();
            else if (window.currentArtesFilter === 'ESTAMPADO') renderArtesEstampado();
            else renderArtesBordado();
        };

        window.renderArtesBordado = function() {
            const tbody = document.getElementById('tbody-artes-bordado');
            if (!tbody) return; tbody.innerHTML = '';
            // actualizar badges de sub-tabs Bordado (sumar PDS en lugar de contar filas)
            let pdsX = 0, pdsProg = 0;
            const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                let ev = '';
                try {
                    if (idxEv !== -1 && row && row[idxEv] !== undefined) ev = row[idxEv];
                    else ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO ENUMERADO') || getVal(row, 'ESTADO_ENumerado') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || '' }
                const evNorm = (ev || '').toString().toUpperCase().trim();
                if (!(evNorm === 'OK PAQUETEO' || evNorm === 'OK ENM' || evNorm === 'OK S/ENM')) continue;

                // Filtrar por n.BDxpda: mostrar solo si es vacío o 1-4; excluir si indica NO LLEVA
                const rawNbd = getVal(row, 'n.BDxpda') || getVal(row, 'N.BDXPDA') || getVal(row, 'n.BDxpda ') || '';
                const nbdNorm = (rawNbd || '').toString().toUpperCase().trim();
                if (nbdNorm.indexOf('NO LLEVA') !== -1) continue;
                if (nbdNorm !== '' && ['1','2','3','4'].indexOf(nbdNorm) === -1) continue;

                // determinar estado_bordado normalizado (vacío => 'X PROG')
                let rawEstadoB = getVal(row, 'estado_bordado') || '';
                let estadoBNorm = (rawEstadoB || '').toString().trim();
                if (estadoBNorm === '') estadoBNorm = 'X PROG';
                // contar PDS para badges (sumar PDS GIRADAS / PDS)
                const pdsVal = parseFloat(getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || 0) || 0;
                if (estadoBNorm.toUpperCase().indexOf('PROG') !== -1 && estadoBNorm.toUpperCase() !== 'X PROG') pdsProg += pdsVal;
                else pdsX += pdsVal;

                // Aplicar filtro por sub-tab (X PROG / PROG)
                if (window.currentArtesBordadoFilter) {
                    if (window.currentArtesBordadoFilter === 'PROG') {
                        if (!(estadoBNorm.toUpperCase().indexOf('PROG') !== -1 && estadoBNorm.toUpperCase() !== 'X PROG')) continue;
                    } else {
                        // X PROG
                        if (!(estadoBNorm.toUpperCase() === 'X PROG' || estadoBNorm === '')) continue;
                    }
                }

                const tr = document.createElement('tr');

                // F. DESPACHO (formateada)
                const tdFDesp = document.createElement('td'); tdFDesp.className = 'date-cell';
                tdFDesp.innerText = formatValue(getVal(row, 'F. DESPACHO') || getVal(row, 'F DESPACHO') || '', 'date');
                tr.appendChild(tdFDesp);

                // F.ING.COST
                const tdFCost = document.createElement('td'); tdFCost.className = 'date-cell';
                tdFCost.innerText = formatValue(getVal(row, 'F.ING.COST') || getVal(row, 'F ING COST') || '', 'date');
                tr.appendChild(tdFCost);

                // CLIENTE (normalizado)
                const tdCliente = document.createElement('td'); tdCliente.innerText = normalizeClientForTransfer(getVal(row, 'CLIENTE') || ''); tr.appendChild(tdCliente);

                // OC
                const tdOC = document.createElement('td');
                let ocVal = getVal(row, 'OC') || '';
                if ((!ocVal || String(ocVal).trim() === '')) {
                    const opVal = getVal(row, 'OP') || getVal(row, 'OP TELA') || getVal(row, 'OP-PTDA') || '';
                    const corteVal = getVal(row, 'CORTE') || getVal(row, 'PARTIDA') || '';
                    if (opVal && corteVal) ocVal = `${String(opVal).trim()}-${String(corteVal).trim()}`;
                }
                tdOC.innerText = ocVal; tr.appendChild(tdOC);

                // COLOR
                const tdColor = document.createElement('td'); tdColor.innerText = abbreviateHeather(getVal(row, 'COLOR') || ''); tr.appendChild(tdColor);

                // PDS
                const tdPds = document.createElement('td'); tdPds.style.textAlign = 'center'; tdPds.innerText = getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || ''; tr.appendChild(tdPds);

                // PRENDA
                const tdPrenda = document.createElement('td'); tdPrenda.innerText = getVal(row, 'PRENDA') || ''; tr.appendChild(tdPrenda);

                // TIPO CERT.
                const tdTipo = document.createElement('td'); tdTipo.innerText = getVal(row, 'TIPO CERT.') || getVal(row, 'TIPO CERTIFICADO') || ''; tr.appendChild(tdTipo);

                // n.BDxpda (nuevo)
                const tdNbd = document.createElement('td');
                const valNbd = getVal(row, 'n.BDxpda') || getVal(row, 'N.BDXPDA') || getVal(row, 'n.BDx pda') || '';
                tdNbd.innerText = valNbd;
                tr.appendChild(tdNbd);

                // estado_bordado -> mostrar solo el dato (sin desplegable)
                const tdEst = document.createElement('td');
                tdEst.innerText = estadoBNorm;
                tdEst.title = estadoBNorm;
                tr.appendChild(tdEst);

                tbody.appendChild(tr);
            }
            // actualizar badges de subtabs
            try { document.getElementById('artes-bordado-xprog-count').innerText = `[${formatThousands(pdsX,0)}pds]`; } catch(e){}
            try { document.getElementById('artes-bordado-prog-count').innerText = `[${formatThousands(pdsProg,0)}pds]`; } catch(e){}
            // actualizar badge del botón padre (suma de X PROG + PROG)
            try { document.getElementById('artes-pds-bordado').innerText = `[${formatThousands((pdsX||0) + (pdsProg||0),0)}pds]`; } catch(e){}
        };

        window.renderArtesEstampado = function() {
            const tbody = document.getElementById('tbody-artes-estampado');
            if (!tbody) return; tbody.innerHTML = '';

            // Recolectar índices válidos según las reglas previas
            let pdsX = 0, pdsProg = 0;
            const validIndices = [];
            const idxEv = findHeaderIndexCaseInsensitive('estado_enumerado');
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                let ev = '';
                try {
                    if (idxEv !== -1 && row && row[idxEv] !== undefined) ev = row[idxEv];
                    else ev = getVal(row, 'estado_enumerado') || getVal(row, 'ESTADO ENUMERADO') || getVal(row, 'ESTADO_ENumerado') || '';
                } catch (e) { ev = getVal(row, 'estado_enumerado') || '' }
                const evNorm = (ev || '').toString().toUpperCase().trim();
                if (!(evNorm === 'OK PAQUETEO' || evNorm === 'OK ENM' || evNorm === 'OK S/ENM')) continue;

                const rawNest = getVal(row, 'n.ESTAMPxpda') || getVal(row, 'N.ESTAMPXPDA') || getVal(row, 'n.ESTAMP xpda') || '';
                const nestNorm = (rawNest || '').toString().toUpperCase().trim();
                if (nestNorm.indexOf('NO LLEVA') !== -1) continue;
                if (nestNorm !== '' && ['1','2','3','4'].indexOf(nestNorm) === -1) continue;

                let rawEstado = getVal(row, 'estado_estampado') || '';
                let estadoNorm = (rawEstado || '').toString().trim();
                if (estadoNorm === '') estadoNorm = 'X PROG';
                const grupoKey = (estadoNorm.toUpperCase().indexOf('PROG') !== -1 && estadoNorm.toUpperCase() !== 'X PROG') ? 'PROG' : 'X PROG';

                const pdsVal = parseFloat(getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || 0) || 0;
                if (grupoKey === 'X PROG') pdsX += pdsVal; else pdsProg += pdsVal;
                validIndices.push(i);
            }

            // ordenar por OP-PTDA para mantener consistencia visual
            let sorted = validIndices;
            try { sorted = sortBloqueoData(sorted); } catch (e) { /* ignore */ }

            // Renderizar lista plana según sub-tab activo (no headers)
            let lastOpPtda = null;
            let currentGroupClass = 'a';
            sorted.forEach(i => {
                const row = rawData[i];
                let rawEstado = getVal(row, 'estado_estampado') || '';
                let estadoNorm = (rawEstado || '').toString().trim();
                if (estadoNorm === '') estadoNorm = 'X PROG';
                const grupoKey = (estadoNorm.toUpperCase().indexOf('PROG') !== -1 && estadoNorm.toUpperCase() !== 'X PROG') ? 'PROG' : 'X PROG';

                if (grupoKey !== window.currentArtesEstampadoFilter) return; // mostrar solo el sub-tab activo

                const opTela = String(getVal(row, 'OP TELA') || '').trim();
                const partida = String(getVal(row, 'PARTIDA') || '').trim();
                const currentOpPtda = `${opTela}-${partida}`;
                if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                    currentGroupClass = (currentGroupClass === 'a') ? 'b' : 'a';
                }
                lastOpPtda = currentOpPtda;

                const tr = document.createElement('tr');
                tr.className = `group-${currentGroupClass}`;

                // F. DESPACHO
                const tdFDesp = document.createElement('td'); tdFDesp.className = 'date-cell'; tdFDesp.innerText = formatValue(getVal(row, 'F. DESPACHO') || getVal(row, 'F DESPACHO') || '', 'date'); tr.appendChild(tdFDesp);
                // F.ING.COST
                const tdFCost = document.createElement('td'); tdFCost.className = 'date-cell'; tdFCost.innerText = formatValue(getVal(row, 'F.ING.COST') || getVal(row, 'F ING COST') || '', 'date'); tr.appendChild(tdFCost);
                // CLIENTE
                const tdCliente = document.createElement('td'); tdCliente.innerText = normalizeClientForTransfer(getVal(row, 'CLIENTE') || ''); tr.appendChild(tdCliente);
                // OC
                const tdOC = document.createElement('td'); let ocVal = getVal(row, 'OC') || ''; if ((!ocVal || String(ocVal).trim() === '')) { const opVal = getVal(row, 'OP') || getVal(row, 'OP TELA') || getVal(row, 'OP-PTDA') || ''; const corteVal = getVal(row, 'CORTE') || getVal(row, 'PARTIDA') || ''; if (opVal && corteVal) ocVal = `${String(opVal).trim()}-${String(corteVal).trim()}`; } tdOC.innerText = ocVal; tr.appendChild(tdOC);
                // COLOR
                const tdColor = document.createElement('td'); tdColor.innerText = abbreviateHeather(getVal(row, 'COLOR') || ''); tr.appendChild(tdColor);
                // PDS
                const tdPds = document.createElement('td'); tdPds.style.textAlign = 'center'; tdPds.innerText = formatThousands(parseFloat(getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || 0) || 0, 0); tr.appendChild(tdPds);
                // PRENDA
                const tdPrenda = document.createElement('td'); tdPrenda.innerText = getVal(row, 'PRENDA') || ''; tr.appendChild(tdPrenda);
                // TIPO CERT.
                const tdTipo = document.createElement('td'); tdTipo.innerText = getVal(row, 'TIPO CERT.') || getVal(row, 'TIPO CERTIFICADO') || ''; tr.appendChild(tdTipo);
                // n.ESTAMPxpda
                const tdNest = document.createElement('td'); const valNest = getVal(row, 'n.ESTAMPxpda') || getVal(row, 'N.ESTAMPXPDA') || getVal(row, 'n.ESTAMP xpda') || ''; tdNest.innerText = valNest; tr.appendChild(tdNest);

                // estado_estampado -> mostrar solo el dato (sin desplegable)
                const tdEst = document.createElement('td');
                tdEst.innerText = estadoNorm;
                tdEst.title = estadoNorm;
                tr.appendChild(tdEst);

                tbody.appendChild(tr);
            });

            // actualizar badges de subtabs Estampado
            try { document.getElementById('artes-estampado-xprog-count').innerText = `[${formatThousands(pdsX||0,0)}pds]`; } catch(e){}
            try { document.getElementById('artes-estampado-prog-count').innerText = `[${formatThousands(pdsProg||0,0)}pds]`; } catch(e){}
            // actualizar badge del botón padre (suma de X PROG + PROG)
            try { document.getElementById('artes-pds-estampado').innerText = `[${formatThousands((pdsX||0) + (pdsProg||0),0)}pds]`; } catch(e){}
        };

        window.renderArtesAsignar = function() {
            const tbody = document.getElementById('tbody-artes-asignar');
            if (!tbody) return; tbody.innerHTML = '';

            // Poblar selects de cliente y estilo
            const selectCliente = document.getElementById('filter-artes-cliente');
            const selectEstilo = document.getElementById('filter-artes-estilo');
            const filterCliente = document.getElementById('filter-artes-cliente')?.value || '';
            const filterEstilo = document.getElementById('filter-artes-estilo')?.value || '';

            if (selectCliente && selectCliente.options.length <= 1) {
                const clientes = new Set();
                for (let i = 1; i < rawData.length; i++) {
                    const clienteRaw = getVal(rawData[i], 'CLIENTE');
                    const clienteNorm = normalizeClientForTransfer(clienteRaw || '');
                    if (clienteNorm) clientes.add(clienteNorm);
                }
                Array.from(clientes).sort().forEach(c => {
                    const opt = document.createElement('option'); opt.value = c; opt.textContent = c; selectCliente.appendChild(opt);
                });
            }

            if (selectEstilo) {
                selectEstilo.innerHTML = '';
                const defaultOpt = document.createElement('option'); defaultOpt.value = ''; defaultOpt.textContent = 'Todos los estilos'; selectEstilo.appendChild(defaultOpt);
                const estilos = new Set();
                for (let i = 1; i < rawData.length; i++) {
                    const row = rawData[i];
                    const clienteRow = normalizeClientForTransfer(getVal(row,'CLIENTE') || '');
                    if (filterCliente && clienteRow !== filterCliente) continue;
                    const estilo = getVal(row,'ESTILO'); if (estilo) estilos.add(estilo);
                }
                Array.from(estilos).sort().forEach(e => { const opt = document.createElement('option'); opt.value = e; opt.textContent = e; selectEstilo.appendChild(opt); });
                if (filterEstilo) {
                    const exists = Array.from(selectEstilo.options).some(o => o.value === filterEstilo);
                    if (!exists) selectEstilo.value = '';
                    else selectEstilo.value = filterEstilo;
                }
            }

            // Agrupar por CLIENTE|ESTILO
            const grupo = new Map();
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const cliente = normalizeClientForTransfer(getVal(row,'CLIENTE') || '');
                const estilo = getVal(row,'ESTILO') || '';
                if (!estilo) continue;
                if (filterCliente && cliente !== filterCliente) continue;
                if (filterEstilo && estilo !== filterEstilo) continue;
                const key = cliente + '|' + estilo;
                if (!grupo.has(key)) grupo.set(key, {cliente, estilo, rows: []});
                grupo.get(key).rows.push(i);
            }

            Array.from(grupo.values()).sort((a,b)=> (a.cliente||'').localeCompare(b.cliente) || (a.estilo||'').localeCompare(b.estilo)).forEach(g => {
                // calcular representativos para n.BDxpda y n.ESTAMPxpda
                function calcularRepresentativo(colName) {
                    let idx = getColIndex(colName);
                    if (idx === -1) {
                        for (const k in colMap) { if (k.toString().toUpperCase().indexOf(colName.toUpperCase())!==-1) { idx = colMap[k]; break; } }
                    }
                    const counts = {};
                    for (const rIdx of g.rows) {
                        const rv = (idx !== -1 && idx !== undefined) ? rawData[rIdx][idx] : getVal(rawData[rIdx], colName);
                        const v = (rv===undefined || rv===null) ? '' : String(rv).toUpperCase().trim();
                        counts[v] = (counts[v]||0) + 1;
                    }
                    if (counts[''] && counts[''] === g.rows.length) return 'LLEVA?';
                    if (counts['NO LLEVA']) return 'NO LLEVA';
                    let best = ''; let bestC = 0;
                    for (const k in counts) { if (k!=='' && counts[k] > bestC) { best = k; bestC = counts[k]; } }
                    return best || '';
                }

                const repBD = calcularRepresentativo('n.BDxpda');
                const repEST = calcularRepresentativo('n.ESTAMPxpda');

                // aplicar filtro HayDato (CON/SIN) inspeccionando filas reales del grupo
                // CON: mostrar grupos donde exista AL MENOS UNA fila con AMBAS columnas (BD y EST) llenas
                // SIN: mostrar grupos donde exista AL MENOS UNA fila con BD o EST vacía
                const uiFilterHayDato = document.getElementById('filter-artes-haydato')?.value || '';
                let anyRowBothFilled = false;
                let anyRowMissingBDorEST = false;
                // localizar índices si es posible
                let idxBD = getColIndex('n.BDxpda');
                if (idxBD === -1) {
                    for (const k in colMap) { if (k.toString().toUpperCase().indexOf('N.BDXPDA')!==-1) { idxBD = colMap[k]; break; } }
                }
                let idxEST = getColIndex('n.ESTAMPxpda');
                if (idxEST === -1) {
                    for (const k in colMap) { if (k.toString().toUpperCase().indexOf('N.ESTAMPXPDA')!==-1) { idxEST = colMap[k]; break; } }
                }
                for (const rIdx of g.rows) {
                    const rawBD = (idxBD !== -1 && idxBD !== undefined) ? (rawData[rIdx][idxBD] || '') : (getVal(rawData[rIdx],'n.BDxpda') || '');
                    const rawEST = (idxEST !== -1 && idxEST !== undefined) ? (rawData[rIdx][idxEST] || '') : (getVal(rawData[rIdx],'n.ESTAMPxpda') || '');
                    const normBD = (rawBD||'').toString().trim();
                    const normEST = (rawEST||'').toString().trim();
                    const bdHas = (normBD !== '' && normBD.toUpperCase() !== 'LLEVA?');
                    const estHas = (normEST !== '' && normEST.toUpperCase() !== 'LLEVA?');
                    if (bdHas && estHas) anyRowBothFilled = true;
                    if (!bdHas || !estHas) anyRowMissingBDorEST = true;
                }

                if (uiFilterHayDato === 'CON') {
                    if (!anyRowBothFilled) return; // no hay ninguna fila con ambas columnas llenas -> saltar
                } else if (uiFilterHayDato === 'SIN') {
                    if (!anyRowMissingBDorEST) return; // ninguna fila con columna vacía -> saltar
                }

                const tr = document.createElement('tr');
                const tdCliente = document.createElement('td'); tdCliente.textContent = normalizeClientForTransfer(g.cliente || ''); tr.appendChild(tdCliente);
                const tdEstilo = document.createElement('td'); tdEstilo.innerHTML = `<strong>${g.estilo}</strong>`; tr.appendChild(tdEstilo);

                const tdBord = document.createElement('td');
                const selB = document.createElement('select'); selB.className='table-select sel-nbd-artes';
                selB.setAttribute('data-cliente', g.cliente); selB.setAttribute('data-estilo', g.estilo);
                selB.innerHTML = `<option value="LLEVA?">LLEVA?</option><option value="NO LLEVA">NO LLEVA</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option>`;
                try { if (repBD !== '') selB.value = repBD; else selB.value = 'LLEVA?'; } catch(e) {}
                selB.onchange = function(){ handleNBDChange(this); };
                tdBord.appendChild(selB); tr.appendChild(tdBord);

                const tdEst = document.createElement('td');
                const selE = document.createElement('select'); selE.className='table-select sel-nest-artes';
                selE.setAttribute('data-cliente', g.cliente); selE.setAttribute('data-estilo', g.estilo);
                selE.innerHTML = `<option value="LLEVA?">LLEVA?</option><option value="NO LLEVA">NO LLEVA</option><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option>`;
                try { if (repEST !== '') selE.value = repEST; else selE.value = 'LLEVA?'; } catch(e) {}
                selE.onchange = function(){ handleNESTChange(this); };
                tdEst.appendChild(selE); tr.appendChild(tdEst);

                tbody.appendChild(tr);
            });
        };

        window.updateClienteEstiloArtes = function(cliente, estilo, value, colName, selectElement) {
            if (!cliente) return;
            // Si el estilo no provisto y no está en modo 'para todo', no hacemos nada
            const paraTodo = !!document.getElementById('chk-artes-para-todo') && document.getElementById('chk-artes-para-todo').checked;
            if (!estilo && !paraTodo) return;
            // intentar encontrar índice de columna por nombre en colMap
            let idx = getColIndex(colName);
            if (idx === -1) {
                // intenta buscar en colMap por variantes
                for (const k in colMap) { if (k.toString().toUpperCase().indexOf(colName.toUpperCase())!==-1) { idx = colMap[k]; break; } }
            }
            if (idx === -1 || idx === undefined) {
                // no se encontró columna; solo actualizar localmente (comparar clientes normalizados)
                const clienteNorm = normalizeClientForTransfer(cliente || '');
                for (let i=1;i<rawData.length;i++){
                    const rCliente = normalizeClientForTransfer(getVal(rawData[i],'CLIENTE')||'');
                    const rEstilo = (getVal(rawData[i],'ESTILO')||'').toString().trim();
                    if (rCliente===clienteNorm && (paraTodo || rEstilo===estilo)) {
                        rawData[i][idx] = value;
                    }
                }
                alert('Actualizado localmente. Columna no identificada para guardar en servidor.');
                return;
            }

            // Recolectar filas a actualizar.
            // Si 'Para todo' está activo -> aplicar a TODO lo filtrado por los selects actuales (cliente/estilo/haydato).
            // Si no -> aplicar a todas las filas del mismo estilo para el cliente.
            const rowsToUpdate = [];
            const clienteNorm = normalizeClientForTransfer(cliente || '');
            const uiFilterCliente = document.getElementById('filter-artes-cliente')?.value || '';
            const uiFilterEstilo = document.getElementById('filter-artes-estilo')?.value || '';
            const uiFilterHayDato = document.getElementById('filter-artes-haydato')?.value || '';
            for (let i=1;i<rawData.length;i++){
                const rCliente = normalizeClientForTransfer(getVal(rawData[i],'CLIENTE')||'');
                const rEstilo = (getVal(rawData[i],'ESTILO')||'').toString().trim();
                if (rCliente !== clienteNorm) continue;

                if (paraTodo) {
                    // respetar filtros UI: si hay filtro por estilo, aplicarlo; si hay filtro haydato, evaluar la columna objetivo
                    if (uiFilterEstilo && rEstilo !== uiFilterEstilo) continue;

                    if (uiFilterHayDato === 'CON' || uiFilterHayDato === 'SIN') {
                        // verificar valor actual de la columna objetivo en esta fila
                        let idxCheck = getColIndex(colName);
                        if (idxCheck === -1) {
                            for (const k in colMap) { if (k.toString().toUpperCase().indexOf(colName.toUpperCase())!==-1) { idxCheck = colMap[k]; break; } }
                        }
                        const rawVal = (idxCheck !== -1 && idxCheck !== undefined) ? (rawData[i][idxCheck] || '') : (getVal(rawData[i], colName) || '');
                        const rawNorm = (rawVal||'').toString().trim();
                        const hasDato = (rawNorm !== '' && rawNorm.toUpperCase().indexOf('NO LLEVA') === -1);
                        if (uiFilterHayDato === 'CON' && !hasDato) continue;
                        if (uiFilterHayDato === 'SIN' && hasDato) continue;
                    }

                    rowsToUpdate.push(i);
                } else {
                    // aplicar únicamente a filas con el mismo estilo
                    if (rEstilo === estilo) rowsToUpdate.push(i);
                }
            }
            if (rowsToUpdate.length===0) { alert('No se encontraron filas para actualizar'); return; }

            if (selectElement) selectElement.disabled = true;
            // Actualizar localmente primero para respuesta inmediata
            rowsToUpdate.forEach(rowIndex => { rawData[rowIndex][idx] = value; });
            // Enviar todas las peticiones en paralelo (más dinámico). Si el backend acepta batch, mejorar posteriormente.
            const promises = rowsToUpdate.map(rowIndex => {
                return fetch(WEB_APP_URL, {
                    method: 'POST', mode: 'no-cors', headers: {'Content-Type':'application/json'},
                    body: JSON.stringify({ action:'update', row: rowIndex, colName: colName, value: value })
                }).catch(err => { console.error('Err saving row', rowIndex, err); });
            });
            Promise.all(promises).then(()=>{
                if (selectElement) selectElement.disabled = false;
                updateCounters();
                renderArtes();
            }).catch(()=>{
                if (selectElement) selectElement.disabled = false;
                renderArtes();
            });
        };

        window.guardarCambiosAsignarArtes = function() { alert('Los cambios se guardan automáticamente al seleccionar un valor para cada estilo.'); };

        function renderCorteBloques() {
            const tbody = document.getElementById('tbody-corte-bloques');
            if (!tbody) return;
            tbody.innerHTML = '';
            let count = 0;

            let validIndices = [];
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const estadoCorteVal = (row[colMap["STATUS_CORTE"]] || row[colMap["STATUS"]] || row[colMap["status"]] || row[colMap["estado_corte"]] || row[colMap["ESTADO CORTE"]] || row[colMap["ESTADO_CORTE"]]) || "";
                const isCorteOk = String(estadoCorteVal).toUpperCase() === 'OK';
                const estadoCorteNorm = (!estadoCorteVal || estadoCorteVal === '') ? 'X PROG' : String(estadoCorteVal);

                // Mostrar solo filas cuyo estado_bloques === 'OK CORTE' (case-insensitive)
                const estadoBloquesRaw = getVal(row, 'ESTADO BLOQUES') || getVal(row, 'ESTADO_BLOQUES') || getVal(row, 'estado_bloques') || '';
                const estadoBloquesNorm = (estadoBloquesRaw || '').toString().toUpperCase().trim();
                
                if (estadoBloquesNorm === 'OK CORTE') {
                    // Filtrar por estado_corte_bloques según el sub-tab activo
                    let estadoCorteBloqsRaw = getVal(row, 'estado_corte_bloques') || getVal(row, 'ESTADO_CORTE_BLOQUES') || getVal(row, 'ESTADO CORTE BLOQUES') || '';
                    // Fallback robusto: buscar índice de encabezado directamente si getVal no encontró nada
                    if ((!estadoCorteBloqsRaw || estadoCorteBloqsRaw === '') && typeof findHeaderIndexCaseInsensitive === 'function') {
                        const idx = findHeaderIndexCaseInsensitive('estado_corte_bloques');
                        if (idx !== -1 && row[idx] !== undefined) estadoCorteBloqsRaw = row[idx];
                    }
                    const estadoCorteBloqsNorm = (!estadoCorteBloqsRaw || estadoCorteBloqsRaw === '') ? 'X PROG' : String(estadoCorteBloqsRaw);
                    
                    if (estadoCorteBloqsNorm === currentCorteBloquesFilter) {
                        validIndices.push(i);
                    }
                }
            }

            validIndices = sortBloqueoData(validIndices);

            let lastOpPtda = null;
            let currentGroup = 'a';

            validIndices.forEach(i => {
                count++;
                const row = rawData[i];
                const opTela = String(getVal(row, "OP TELA") || "").trim();
                const partida = String(getVal(row, "PARTIDA") || "").trim();
                const currentOpPtda = opTela + "-" + partida;
                if (lastOpPtda !== null && currentOpPtda !== lastOpPtda) {
                    currentGroup = (currentGroup === 'a') ? 'b' : 'a';
                }
                lastOpPtda = currentOpPtda;

                const tr = createRow(row, i, 'corte', currentGroup);

                // Quitar el botón de tendido ('+') que aparece dentro de la celda OC
                // en la vista Corte Bloques: no debe mostrarse aquí.
                try {
                    const tendidoBtn = tr.querySelector('button.btn-tendido');
                    if (tendidoBtn) tendidoBtn.remove();
                } catch (e) {}

                // Remove RIB cell if present (select with onchange updateRow(...,'estado_rib'))
                try {
                    const ribSelect = tr.querySelector('select[onchange*="estado_rib"]');
                    if (ribSelect) {
                        const td = ribSelect.closest('td');
                        if (td) td.remove();
                    }
                } catch (e) {}

                // En la vista "Corte Bloques" mostrar solo texto para `equipo_corte` y `STATUS_CORTE`.
                // Reemplazamos los <select> correspondientes por su valor visible.
                try {
                    const selects = tr.querySelectorAll('select');
                    selects.forEach(s => {
                        const oc = s.getAttribute('onchange') || '';
                        const on = oc.toString().toLowerCase();
                        // equipo_corte -> updateRow(..., 'equipo_corte', ...)
                        if (on.indexOf("'equipo_corte'") !== -1) {
                            const txt = (s.options && s.selectedIndex >= 0 && s.options[s.selectedIndex]) ? s.options[s.selectedIndex].text : (s.value || '');
                            const td = s.closest('td');
                            if (td) td.innerText = txt;
                        }
                        // STATUS_CORTE variants, avoid matching 'estado_corte_bloques'
                        if ((on.indexOf("'status_corte'") !== -1 || on.indexOf("'status'") !== -1 || on.indexOf("'estado_corte'") !== -1) && on.indexOf("'estado_corte_bloques'") === -1) {
                            const txt = (s.options && s.selectedIndex >= 0 && s.options[s.selectedIndex]) ? s.options[s.selectedIndex].text : (s.value || '');
                            const td = s.closest('td');
                            if (td) td.innerText = txt;
                        }
                    });
                } catch (e) {}

                // Remove last two cells (estado_bloques and estado_coll_tap)
                try {
                    for (let k = 0; k < 2; k++) {
                        const tds = tr.querySelectorAll('td');
                        if (tds && tds.length) tds[tds.length - 1].remove();
                    }
                } catch (e) {}

                // Append the new column 'BLOQUES?' (value from estado_bloques) then 'ESTADO_BLOQS' como select
                try {
                    const valBloq = getVal(row, 'ESTADO BLOQUES') || getVal(row, 'ESTADO_BLOQUES') || getVal(row, 'estado_bloques') || '';
                    const tdBloq = document.createElement('td');
                    tdBloq.title = valBloq;
                    tdBloq.innerText = valBloq;
                    tr.appendChild(tdBloq);

                    let val = getVal(row, 'estado_corte_bloques') || getVal(row, 'ESTADO_CORTE_BLOQUES') || getVal(row, 'ESTADO CORTE BLOQUES') || '';
                    // Fallback robusto para leer directamente de rawData si colMap no contiene la columna
                    if ((!val || val === '') && typeof findHeaderIndexCaseInsensitive === 'function') {
                        const idxVal = findHeaderIndexCaseInsensitive('estado_corte_bloques');
                        if (idxVal !== -1 && row[idxVal] !== undefined) val = row[idxVal];
                    }
                    const valNorm = (!val || val === '') ? 'X PROG' : String(val);
                    let selectClass = '';
                    if (valNorm.toUpperCase().includes('PROG') && valNorm !== 'X PROG') selectClass = 'sel-PROG';
                    if (valNorm === 'OK') selectClass = 'sel-OK';
                    
                    const td = document.createElement('td');
                    // Si estamos en Corte Bloques -> Por Programar (X PROG) mostrar solo dato (sin select)
                    try {
                        if (currentCorteBloquesFilter === 'X PROG') {
                            td.title = val;
                            td.innerText = valNorm || '';
                        } else {
                            // Ocultar la opción OK cuando el sub-tab activo sea 'X PROG' (Por Programar)
                            const showOkOption = (typeof currentCorteBloquesFilter === 'undefined') ? true : (currentCorteBloquesFilter !== 'X PROG');
                            td.innerHTML = `
                                <select class="table-select ${selectClass}" onchange="updateRow(${i}, 'estado_corte_bloques', this.value, this)">
                                    <option value="X PROG" ${valNorm === 'X PROG' ? 'selected' : ''}>X PROG</option>
                                    <option value="PROG" ${valNorm === 'PROG' ? 'selected' : ''}>PROG</option>
                                    ${showOkOption ? `<option value="OK" ${valNorm === 'OK' ? 'selected' : ''}>OK</option>` : ''}
                                </select>
                            `;
                        }
                    } catch (e) {
                        td.innerHTML = `
                            <select class="table-select ${selectClass}" onchange="updateRow(${i}, 'estado_corte_bloques', this.value, this)">
                                <option value="X PROG" ${valNorm === 'X PROG' ? 'selected' : ''}>X PROG</option>
                                <option value="PROG" ${valNorm === 'PROG' ? 'selected' : ''}>PROG</option>
                                <option value="OK" ${valNorm === 'OK' ? 'selected' : ''}>OK</option>
                            </select>
                        `;
                    }
                    tr.appendChild(td);
                } catch (e) {}

                tbody.appendChild(tr);
            });

            document.getElementById('tbody-corte-bloques') && (document.getElementById('count-corte-bloques').innerText = count);
            
            // Actualizar badges de pds según el filtro
            updateCorteBloquesCounters();
        }
        
        function updateCorteBloquesCounters() {
            let pds_xprog = 0;
            let pds_prog = 0;
            
            for (let i = 1; i < rawData.length; i++) {
                const row = rawData[i];
                const estadoBloquesRaw = getVal(row, 'ESTADO BLOQUES') || getVal(row, 'ESTADO_BLOQUES') || getVal(row, 'estado_bloques') || '';
                const estadoBloquesNorm = (estadoBloquesRaw || '').toString().toUpperCase().trim();

                if (estadoBloquesNorm === 'OK CORTE') {
                    // Leer estado_corte_bloques robustamente
                    let estadoCorteBloqsRaw = getVal(row, 'estado_corte_bloques') || getVal(row, 'ESTADO_CORTE_BLOQUES') || getVal(row, 'ESTADO CORTE BLOQUES') || '';
                    if ((!estadoCorteBloqsRaw || estadoCorteBloqsRaw === '') && typeof findHeaderIndexCaseInsensitive === 'function') {
                        const idx = findHeaderIndexCaseInsensitive('estado_corte_bloques');
                        if (idx !== -1 && row[idx] !== undefined) estadoCorteBloqsRaw = row[idx];
                    }
                    const estadoCorteBloqsNorm = (!estadoCorteBloqsRaw || estadoCorteBloqsRaw === '') ? 'X PROG' : String(estadoCorteBloqsRaw).toUpperCase().trim();

                    // Leer PDS con fallback a rawData si es necesario
                    let pdsVal = parseFloat(getVal(row, 'PDS') || getVal(row, 'PDS GIRADAS') || 0) || 0;
                    if ((pdsVal === 0 || isNaN(pdsVal)) && typeof findHeaderIndexCaseInsensitive === 'function') {
                        let idxPds = findHeaderIndexCaseInsensitive('PDS GIRADAS');
                        if (idxPds === -1) idxPds = findHeaderIndexCaseInsensitive('PDS');
                        if (idxPds !== -1 && row[idxPds] !== undefined) pdsVal = parseFloat(row[idxPds]) || 0;
                    }

                    if (estadoCorteBloqsNorm === 'X PROG') pds_xprog += pdsVal;
                    if (estadoCorteBloqsNorm === 'PROG') pds_prog += pdsVal;
                }
            }
            
            const elX = document.getElementById('corte-bloques-pds-xprog');
            if (elX) elX.innerText = `[${formatThousands(pds_xprog, 0)}pds]`;
            const elP = document.getElementById('corte-bloques-pds-prog');
            if (elP) elP.innerText = `[${formatThousands(pds_prog, 0)}pds]`;
        }

        // ===============================
        // FUNCIONES DEL MODAL DE TENDIDO
        // ===============================

        window.abrirModalTendido = function(rowIndex, op, corte, color, pdsTotal) {
            // Detectar si el CORTE es ya un tendido (termina en 01, 02, etc.)
            const corteStr = String(corte);
            const lastTwoChars = corteStr.slice(-2);
            const isTendidoExistente = /^0[1-9]$|^[1-9]\d$/.test(lastTwoChars) && corteStr.length > 2;
            
            if (isTendidoExistente) {
                // Modo EDICIÓN: mostrar los tendidos ya existentes
                abrirModalTendidoEdicion(rowIndex, op, corte, color);
            } else {
                // Modo CREACIÓN: crear nuevos tendidos
                abrirModalTendidoCreacion(rowIndex, op, corte, color, pdsTotal);
            }
        };

        window.abrirModalTendidoCreacion = function(rowIndex, op, corte, color, pdsTotal) {
            modalTendidoData = {
                rowIndex: rowIndex,
                oc: `${op}-${corte}`,
                op: op,
                corte: corte,
                color: color,
                pdsTotal: pdsTotal,
                modo: 'crear',
                tendidos: []
            };

            document.getElementById('modal-tendido-title').innerText = `OC: ${op}-${corte}`;
            document.getElementById('modal-tendido-subtitle').innerText = `COLOR: ${color} | PDS: ${formatThousands(pdsTotal, 0)}`;

            const tbody = document.getElementById('modal-tendido-tbody');
            const tendido1 = `${corte}01`;
            const tendido2 = `${corte}02`;

            modalTendidoData.tendidos = [tendido1, tendido2];

            let html = '';
            for (let i = 0; i < modalTendidoData.tendidos.length; i++) {
                const tendido = modalTendidoData.tendidos[i];
                const isLast = (i === modalTendidoData.tendidos.length - 1);
                const btnHTML = isLast ? `<button class="btn-tendido" onclick="agregarTendidoModal()" style="margin-right: 6px;" title="Agregar tendido">+</button>` : '';
                
                if (isLast) {
                    html += `<tr><td style="font-weight: 600; text-align: center;">${btnHTML}${tendido}</td><td><input type="number" id="pds-tendido-${i}" placeholder="Diferencia" oninput="recalcularTendidosModal()" min="0" max="${pdsTotal}"></td></tr>`;
                } else {
                    html += `<tr><td style="font-weight: 600; text-align: center;">${tendido}</td><td><input type="number" id="pds-tendido-${i}" placeholder="Ingrese PDS" oninput="recalcularTendidosModal()" min="0" max="${pdsTotal}"></td></tr>`;
                }
            }
            tbody.innerHTML = html;
            document.getElementById('modal-tendido').classList.add('active');
        };

        window.abrirModalTendidoEdicion = function(rowIndex, op, corte, color) {
            const corteBase = String(corte).slice(0, -2);
            const corteIdx = colMap["CORTE"];
            const pdsIdx = colMap["PDS GIRADAS"];
            
            const tendidos = [];
            const tendidoRows = [];
            const tendidoPds = [];
            
            for (let i = 1; i < rawData.length; i++) {
                const rowCorte = String(rawData[i][corteIdx] || '');
                const match = rowCorte.match(new RegExp(`^${corteBase}(\\d{2})$`));
                if (match) {
                    tendidos.push(rowCorte);
                    tendidoRows.push(i);
                    tendidoPds.push(parseFloat(rawData[i][pdsIdx]) || 0);
                }
            }
            
            const sortedIndices = Array.from(Array(tendidos.length).keys()).sort((a, b) => {
                const numA = parseInt(tendidos[a].slice(-2));
                const numB = parseInt(tendidos[b].slice(-2));
                return numA - numB;
            });
            
            const sortedTendidos = sortedIndices.map(i => tendidos[i]);
            const sortedRows = sortedIndices.map(i => tendidoRows[i]);
            const sortedPds = sortedIndices.map(i => tendidoPds[i]);
            const totalPds = sortedPds.reduce((a, b) => a + b, 0);
            
            modalTendidoData = {
                rowIndex: rowIndex,
                tendidoRows: sortedRows,
                oc: `${op}-${corteBase}`,
                op: op,
                corte: corteBase,
                color: color,
                pdsTotal: totalPds,
                modo: 'editar',
                tendidos: sortedTendidos
            };

            document.getElementById('modal-tendido-title').innerText = `OC: ${op}-${corteBase}`;
            document.getElementById('modal-tendido-subtitle').innerText = `COLOR: ${color} | PDS: ${formatThousands(totalPds, 0)}`;

            const tbody = document.getElementById('modal-tendido-tbody');
            let html = '';
            for (let i = 0; i < sortedTendidos.length; i++) {
                const tendido = sortedTendidos[i];
                const pds = sortedPds[i];
                const isLast = (i === sortedTendidos.length - 1);
                const btnHTML = isLast ? `<button class="btn-tendido" onclick="agregarTendidoModal()" style="margin-right: 6px;" title="Agregar tendido">+</button>` : '';
                html += `<tr><td style="font-weight: 600; text-align: center;">${btnHTML}${tendido}</td><td><input type="number" id="pds-tendido-${i}" value="${pds}" oninput="recalcularTendidosModal()" min="0" max="${totalPds}"></td></tr>`;
            }
            tbody.innerHTML = html;
            document.getElementById('modal-tendido').classList.add('active');
        };

        window.recalcularTendidosModal = function() {
            const total = modalTendidoData.pdsTotal;
            const numTendidos = modalTendidoData.tendidos ? modalTendidoData.tendidos.length : 2;
            
            let sumaParcial = 0;
            for (let i = 0; i < numTendidos - 1; i++) {
                const input = document.getElementById(`pds-tendido-${i}`);
                if (input) {
                    const val = parseFloat(input.value) || 0;
                    sumaParcial += val;
                }
            }
            
            const ultimoInput = document.getElementById(`pds-tendido-${numTendidos - 1}`);
            if (ultimoInput) {
                const diferencia = total - sumaParcial;
                ultimoInput.value = Math.max(0, diferencia);
            }
        };

        window.agregarTendidoModal = function() {
            if (!modalTendidoData.tendidos) {
                alert('Error: No hay datos de tendidos');
                return;
            }
            
            const corte = modalTendidoData.corte;
            const numTendidos = modalTendidoData.tendidos.length;
            const siguienteNum = String(numTendidos + 1).padStart(2, '0');
            const nuevoTendido = `${corte}${siguienteNum}`;
            
            modalTendidoData.tendidos.push(nuevoTendido);
            
            const tbody = document.getElementById('modal-tendido-tbody');
            const total = modalTendidoData.pdsTotal;
            
            let html = '';
            for (let i = 0; i < modalTendidoData.tendidos.length; i++) {
                const tendido = modalTendidoData.tendidos[i];
                const isLast = (i === modalTendidoData.tendidos.length - 1);
                const btnHTML = isLast ? `<button class="btn-tendido" onclick="agregarTendidoModal()" style="margin-right: 6px;" title="Agregar tendido">+</button>` : '';
                
                let inputVal = '';
                const oldInput = document.getElementById(`pds-tendido-${i}`);
                if (oldInput) inputVal = oldInput.value;
                
                html += `<tr><td style="font-weight: 600; text-align: center;">${btnHTML}${tendido}</td><td><input type="number" id="pds-tendido-${i}" value="${inputVal}" oninput="recalcularTendidosModal()" min="0" max="${total}"></td></tr>`;
            }
            tbody.innerHTML = html;
            setTimeout(() => recalcularTendidosModal(), 100);
        };

        window.cerrarModalTendido = function() {
            document.getElementById('modal-tendido').classList.remove('active');
            modalTendidoData = { rowIndex: null, oc: '', op: '', corte: '', color: '', pdsTotal: 0 };
        };

        // Modal para mostrar información OC (RUTA, EQUIPO_CORTE, ESTADO_ENUMERADO)
        window.abrirModalOC = function(rowIndex) {
            try {
                console.log('abrirModalOC called, rowIndex=', rowIndex, 'isHabilitadoView=', isHabilitadoView && isHabilitadoView());
                if (!isHabilitadoView || !isHabilitadoView()) { console.log('abrirModalOC: not in habilitado view'); return; }
                if (typeof rawData === 'undefined') { console.warn('abrirModalOC: rawData undefined'); return; }
                const row = rawData[rowIndex];
                if (!row) return;
                const op = getVal(row,'OP') || '';
                const corte = getVal(row,'CORTE') || '';
                const oc = (op || corte) ? `${op}-${corte}` : '';
                const colorRaw = getVal(row,'COLOR') || '';
                const color = abbreviateHeather(colorRaw);
                const ruta = getVal(row,'RUTA TELA') || getVal(row,'RUTA') || '';
                const equipo = getVal(row,'EQUIPO CORTE') || getVal(row,'EQUIPO_CORTE') || getVal(row,'equipo_corte') || '';
                const estadoEnum = getVal(row,'estado_enumerado') || getVal(row,'ESTADO_ENUMERADO') || getVal(row,'ESTADO ENUMERADO') || '';
                const estadoCorte = getVal(row,'STATUS_CORTE') || getVal(row,'STATUS') || getVal(row,'status') || getVal(row,'ESTADO CORTE') || getVal(row,'ESTADO_CORTE') || getVal(row,'estado_corte') || '';

                document.getElementById('modal-oc-title').innerText = `${oc} ${color}`;
                document.getElementById('modal-oc-subtitle').innerText = '';

                const tbody = document.getElementById('modal-oc-tbody');
                let html = '';
                html += `<tr><td style="font-weight:700;">RUTA</td><td title="${ruta}">${ruta}</td></tr>`;
                html += `<tr><td style="font-weight:700;">EQUIPO_CORTE</td><td title="${equipo}">${equipo}</td></tr>`;
                html += `<tr><td style="font-weight:700;">ESTADO_CORTE</td><td title="${estadoCorte}">${estadoCorte}</td></tr>`;
                html += `<tr><td style="font-weight:700;">ESTADO_ENUMERADO</td><td title="${estadoEnum}">${estadoEnum}</td></tr>`;
                tbody.innerHTML = html;
                document.getElementById('modal-oc').classList.add('active');
            } catch (e) { console.error('abrirModalOC error', e); }
        };

        window.cerrarModalOC = function() {
            try {
                document.getElementById('modal-oc').classList.remove('active');
                const tbody = document.getElementById('modal-oc-tbody'); if (tbody) tbody.innerHTML = '';
            } catch (e) {}
        };

        window.limpiarModalTendido = function() {
            const numTendidos = modalTendidoData.tendidos ? modalTendidoData.tendidos.length : 2;
            for (let i = 0; i < numTendidos; i++) {
                const input = document.getElementById(`pds-tendido-${i}`);
                if (input) input.value = '';
            }
        };

        window.guardarModalTendido = function() {
            const numTendidos = modalTendidoData.tendidos ? modalTendidoData.tendidos.length : 2;
            const pdsValues = [];
            
            for (let i = 0; i < numTendidos; i++) {
                const input = document.getElementById(`pds-tendido-${i}`);
                const pds = parseFloat(input ? input.value : 0) || 0;
                pdsValues.push(pds);
            }

            if (pdsValues.some(v => v <= 0)) {
                alert('Por favor ingrese valores válidos para todos los tendidos.');
                return;
            }

            if (modalTendidoData.modo === 'crear') {
                guardarModalTendidoCreacion(pdsValues);
            } else if (modalTendidoData.modo === 'editar') {
                guardarModalTendidoEdicion(pdsValues);
            }
        };

        window.guardarModalTendidoCreacion = function(pdsValues) {
            const rowIndex = modalTendidoData.rowIndex;
            if (rowIndex === null || !rawData[rowIndex]) {
                alert('Error: No se encontró la fila original.');
                cerrarModalTendido();
                return;
            }

            const originalRow = rawData[rowIndex];
            const corte = modalTendidoData.corte;
            const corteIdx = colMap["CORTE"];
            const pdsIdx = colMap["PDS GIRADAS"];

            if (corteIdx === undefined || corteIdx === -1 || pdsIdx === undefined || pdsIdx === -1) {
                alert('Error: No se encontraron las columnas CORTE o PDS GIRADAS.');
                cerrarModalTendido();
                return;
            }

            try {
                // Reemplazar la fila original con el primer tendido
                const firstTendido = `${corte}01`;
                const firstPds = pdsValues[0];
                
                const newRow1 = [...originalRow];
                newRow1[corteIdx] = firstTendido;
                newRow1[pdsIdx] = firstPds;
                // marcar como recién creado para priorizar su visualización
                try { newRow1._inserted = Date.now(); } catch(e){}
                rawData[rowIndex] = newRow1;

                fetch(WEB_APP_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: JSON.stringify({
                        action: "update",
                        row: rowIndex,
                        colName: "CORTE",
                        value: firstTendido
                    })
                }).catch(e => console.error("Error guardando CORTE tendido 1", e));

                fetch(WEB_APP_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: JSON.stringify({
                        action: "update",
                        row: rowIndex,
                        colName: "PDS GIRADAS",
                        value: firstPds
                    })
                }).catch(e => console.error("Error guardando PDS tendido 1", e));

                // Crear tendidos adicionales (si hay más de uno)
                let alertMsg = `Se han creado los tendidos:\n• ${firstTendido} con ${formatThousands(firstPds, 0)} PDS`;
                
                // Insertar tendidos adicionales inmediatamente después de la fila original
                // para que queden contiguos en la vista.
                for (let i = 1; i < pdsValues.length; i++) {
                    const tendidoNum = String(i + 1).padStart(2, '0');
                    const tendido = `${corte}${tendidoNum}`;
                    const pds = pdsValues[i];

                    const newRow = [...originalRow];
                    newRow[corteIdx] = tendido;
                    newRow[pdsIdx] = pds;
                    try { newRow._inserted = Date.now(); } catch(e){}

                    // Insertar en rawData justo después de la fila original y de los tendidos ya insertados
                    const insertAt = rowIndex + i; // i=1 -> after original, i=2 -> after first inserted, etc.
                    rawData.splice(insertAt, 0, newRow);

                    fetch(WEB_APP_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        body: JSON.stringify({
                            action: "duplicateRow",
                            sourceRow: rowIndex,
                            newCorte: tendido,
                            newPds: pds
                        })
                    }).catch(e => console.error(`Error creando tendido ${i + 1}`, e));

                    alertMsg += `\n• ${tendido} con ${formatThousands(pds, 0)} PDS`;
                }

            } catch (e) {
                console.error('Error guardando tendidos:', e);
                alert('Error al guardar los tendidos.');
                return;
            }

            // Registrar la base como creada para que se muestre priorizada
            try { addCreatedTendidoBase(corte); } catch(e) {}

            // Cerrar modal y re-renderizar
            cerrarModalTendido();
            updateCounters();
            renderCorte();

            alert(alertMsg);
        };

        window.guardarModalTendidoEdicion = function(pdsValues) {
            const tendidoRows = modalTendidoData.tendidoRows || [];
            
            if (tendidoRows.length === 0) {
                alert('Error: No se encontraron los tendidos existentes.');
                cerrarModalTendido();
                return;
            }

            const pdsIdx = colMap["PDS GIRADAS"];
            const corteIdx = colMap["CORTE"];
            
            if (pdsIdx === undefined || pdsIdx === -1 || corteIdx === undefined || corteIdx === -1) {
                alert('Error: No se encontró la columna PDS GIRADAS o CORTE.');
                cerrarModalTendido();
                return;
            }

            try {
                let alertMsg = 'Se han actualizado los tendidos:';
                const corte = modalTendidoData.corte;
                
                // Actualizar tendidos existentes
                for (let i = 0; i < Math.min(pdsValues.length, tendidoRows.length); i++) {
                    const rowIdx = tendidoRows[i];
                    const pds = pdsValues[i];
                    const tendidoNum = String(i + 1).padStart(2, '0');
                    const tendido = `${corte}${tendidoNum}`;
                    
                    rawData[rowIdx][pdsIdx] = pds;

                    fetch(WEB_APP_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        body: JSON.stringify({
                            action: "update",
                            row: rowIdx,
                            colName: "PDS GIRADAS",
                            value: pds
                        })
                    }).catch(e => console.error(`Error guardando PDS tendido ${i + 1}`, e));

                    alertMsg += `\n• ${tendido} con ${formatThousands(pds, 0)} PDS`;
                }
                // Registrar la base como creada (en caso de añadir nuevos tendidos)
                try { addCreatedTendidoBase(corte); } catch(e) {}

                // Crear nuevos tendidos si hay más valores que filas existentes
                if (pdsValues.length > tendidoRows.length) {
                    const sourceRowIdx = tendidoRows[0];
                    const sourceRow = rawData[sourceRowIdx];
                    // Insertar nuevos tendidos justo después del último tendido existente
                    const lastExisting = tendidoRows[tendidoRows.length - 1];
                    let inserted = 0;
                    for (let i = tendidoRows.length; i < pdsValues.length; i++) {
                        const pds = pdsValues[i];
                        const tendidoNum = String(i + 1).padStart(2, '0');
                        const tendido = `${corte}${tendidoNum}`;

                        const newRow = [...sourceRow];
                        newRow[corteIdx] = tendido;
                        newRow[pdsIdx] = pds;
                        try { newRow._inserted = Date.now(); } catch(e){}

                        const insertAt = lastExisting + 1 + inserted; // place after last existing, account inserted
                        rawData.splice(insertAt, 0, newRow);
                        inserted++;

                        fetch(WEB_APP_URL, {
                            method: 'POST',
                            mode: 'no-cors',
                            body: JSON.stringify({
                                action: "duplicateRow",
                                sourceRow: sourceRowIdx,
                                newCorte: tendido,
                                newPds: pds
                            })
                        }).catch(e => console.error(`Error creando tendido ${i + 1}`, e));

                        alertMsg += `\n• ${tendido} con ${formatThousands(pds, 0)} PDS`;
                    }
                }

            } catch (e) {
                console.error('Error guardando cambios de tendidos:', e);
                alert('Error al guardar los cambios.');
                return;
            }

            // Cerrar modal y re-renderizar
            cerrarModalTendido();
            updateCounters();
            renderCorte();

            alert(alertMsg);
        };

        // ===============================
        // FUNCIONES DEL MODAL EQ_CORTE
        // ===============================

        let equiposCorteData = [];

        window.abrirModalEQCorte = function() {
            // Cargar datos de la hoja EQ_Corte
            cargarEquiposCorte();
        };

        function cargarEquiposCorteBackground() {
            // Cargar equipos sin mostrar el modal (para uso en select)
            const script = document.createElement('script');
            script.src = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=responseHandler:loadEQCorteCallback&sheet=EQ_Corte`;
            script.onerror = () => {
                console.error("Error cargando hoja EQ_Corte en background");
                // Datos por defecto en caso de error
                equiposCorteData = [{eq: 1, nombre: "Mesa 1"}, {eq: 2, nombre: "Mesa 2"}];
            };
            document.body.appendChild(script);
        }

        function cargarEquiposCorte() {
            // Mostrar loading en modal
            document.getElementById('modal-eq-corte-tbody').innerHTML = '<tr><td colspan="2" style="text-align:center;padding:20px;">Cargando equipos...</td></tr>';
            document.getElementById('modal-eq-corte').classList.add('active');

            // Usar el mismo método que funciona para los datos principales
            const script = document.createElement('script');
            script.src = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=responseHandler:loadEQCorteCallback&sheet=EQ_Corte`;
            script.onerror = () => {
                console.error("Error cargando hoja EQ_Corte");
                // Datos por defecto en caso de error
                equiposCorteData = [
                    {eq: 1, nombre: "Mesa 1"},
                    {eq: 2, nombre: "Mesa 2"}
                ];
                renderModalEQCorte();
            };
            document.body.appendChild(script);
        }

        // Callback para recibir los datos de la hoja EQ_Corte
        window.loadEQCorteCallback = function(jsonResponse) {
            try {
                if (!jsonResponse || !jsonResponse.table) {
                    throw new Error("Datos inválidos de EQ_Corte");
                }
                
                const rows = jsonResponse.table.rows;
                equiposCorteData = [];
                
                // Procesar las filas (saltar el header)
                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    if (row && row.c && row.c.length >= 2) {
                        const eqValue = row.c[0] ? (row.c[0].v || row.c[0].f || "") : "";
                        const nombreValue = row.c[1] ? (row.c[1].v || row.c[1].f || "") : "";
                        
                        // Solo agregar si tiene datos válidos
                        if (eqValue && nombreValue) {
                            equiposCorteData.push({
                                eq: parseInt(eqValue) || eqValue,
                                nombre: String(nombreValue)
                            });
                        }
                    }
                }
                
                // Si no hay datos, usar valores por defecto
                if (equiposCorteData.length === 0) {
                    equiposCorteData = [
                        {eq: 1, nombre: "Mesa 1"},
                        {eq: 2, nombre: "Mesa 2"}
                    ];
                }
                
                renderModalEQCorte();
                
            } catch (error) {
                console.error("Error procesando datos EQ_Corte:", error);
                // Datos por defecto en caso de error
                equiposCorteData = [
                    {eq: 1, nombre: "Mesa 1"},
                    {eq: 2, nombre: "Mesa 2"}
                ];
                renderModalEQCorte();
            }
        };

        function renderModalEQCorte() {
            const tbody = document.getElementById('modal-eq-corte-tbody');
            let html = '';
            
            equiposCorteData.forEach((equipo, index) => {
                const isLast = (index === equiposCorteData.length - 1);
                const btnHTML = isLast ? '<button class="btn-tendido" onclick="agregarEquipoCorte()" style="margin-right: 6px;" title="Agregar equipo">+</button>' : '';
                html += `
                    <tr>
                        <td style="text-align: center; font-weight: 600;">${btnHTML}${equipo.eq}</td>
                        <td><input type="text" value="${equipo.nombre}" onchange="equiposCorteData[${index}].nombre = this.value" style="width: 100%; padding: 6px; border: 1px solid var(--gray-300); border-radius: 4px;"></td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
        }

        window.agregarEquipoCorte = function() {
            // Calcular el siguiente número EQ basado en los datos existentes
            let nextEQ = 1;
            if (equiposCorteData.length > 0) {
                const maxEQ = Math.max(...equiposCorteData.map(e => parseInt(e.eq) || 0));
                nextEQ = maxEQ + 1;
            }
            
            equiposCorteData.push({
                eq: nextEQ,
                nombre: `Equipo ${nextEQ}`
            });
            renderModalEQCorte();
        };

        window.cerrarModalEQCorte = function() {
            document.getElementById('modal-eq-corte').classList.remove('active');
        };

        window.guardarModalEQCorte = function() {
            // Validar que todos los nombres estén completos
            const nombresVacios = equiposCorteData.some(e => !e.nombre || e.nombre.trim() === '');
            if (nombresVacios) {
                alert('Por favor complete todos los nombres de equipos.');
                return;
            }

            try {
                // Enviar cada equipo al backend
                equiposCorteData.forEach((equipo, index) => {
                    fetch(WEB_APP_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        body: JSON.stringify({
                            action: "updateEQCorte",
                            eq: equipo.eq,
                            nombre: equipo.nombre,
                            row: index + 1 // +1 para header
                        })
                    }).catch(e => console.error(`Error guardando equipo ${equipo.eq}`, e));
                });

                alert(`Se han guardado ${equiposCorteData.length} equipos de corte.`);
                cerrarModalEQCorte();
                
            } catch (e) {
                console.error('Error guardando equipos:', e);
                alert('Error al guardar los equipos.');
            }
        };
    </script>

    <script>
        (function(){
            // Stock funnel: código de visualización removido.
            // Se mantiene una función de cierre mínima para compatibilidad con el modal HTML.
            window.closeStockFunnelModal = function() {
                const modal = document.getElementById('modal-stock-funnel');
                if (!modal) return;
                modal.classList.remove('active');
            };
        })();
    </script>

    <script>
        // Auto-reload every 10 minutes with visible countdown next to title
        (function(){
                try {
            // Use 10 minutes
            window.RELOAD_INTERVAL_MS = 10 * 60 * 1000;
            window.__reloadRemaining = Math.round(window.RELOAD_INTERVAL_MS / 1000);
                window.__reloadPaused = false;

                function updateTimerDisplay() {
                    const el = document.getElementById('auto-reload-timer');
                    if (!el) return;
                    if (window.__reloadPaused) {
                        el.innerText = 'PAUSADO';
                        return;
                    }
                    const s = window.__reloadRemaining;
                    el.innerText = (s >= 60) ? `${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}` : `${s}s`;
                }

                function pauseAutoReload() {
                    window.__reloadPaused = true;
                    updateTimerDisplay();
                }

                function resumeAutoReload(reset) {
                    window.__reloadPaused = false;
                    if (reset) window.__reloadRemaining = Math.round(window.RELOAD_INTERVAL_MS / 1000);
                    updateTimerDisplay();
                }

                // Start countdown shortly after load to avoid interfering with initial actions
                setTimeout(() => {
                    updateTimerDisplay();
                    window.__autoReloadCountdown = setInterval(() => {
                        try {
                            if (window.__reloadPaused) return;
                            window.__reloadRemaining = (window.__reloadRemaining || 0) - 1;
                            if (window.__reloadRemaining <= 0) {
                                try { window.location.reload(); } catch(e) { console.error('Auto-reload error', e); }
                            } else {
                                updateTimerDisplay();
                            }
                        } catch (e) { console.error('Auto-reload countdown error', e); }
                    }, 1000);
                }, 1500);

                // Reset the counter when the page regains focus
                window.addEventListener('focus', function() {
                    try { if (!window.__reloadPaused) { window.__reloadRemaining = Math.round(window.RELOAD_INTERVAL_MS / 1000); updateTimerDisplay(); } } catch(e){}
                });

                // Pause auto-reload when any editable field is focused; resume and reset on blur
                const editableSelector = 'input, textarea, select, [contenteditable]';
                document.addEventListener('focusin', function(e){
                    try {
                        if (e.target && e.target.matches && e.target.matches(editableSelector)) {
                            pauseAutoReload();
                        }
                    } catch (e) {}
                });
                document.addEventListener('focusout', function(e){
                    try {
                        if (e.target && e.target.matches && e.target.matches(editableSelector)) {
                            // small delay to allow focus to move to another field without immediately resuming
                            setTimeout(()=>{ resumeAutoReload(true); }, 300);
                        }
                    } catch (e) {}
                });
            } catch (e) { console.error('Failed to initialize auto-reload', e); }
        })();
    </script>

    </body>
    </html>


